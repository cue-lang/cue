{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "26067944_677bcb98",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2026-02-11T12:06:26Z",
      "side": 1,
      "message": "LGTM with a suggestion for a slightly different regexp caching primitive.",
      "revId": "0b71163c9bb957283729baa85912b3f1a60e1f67",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "987d1b3f_1f39807f",
        "filename": "internal/core/adt/context.go",
        "patchSetId": 1
      },
      "lineNbr": 1237,
      "author": {
        "id": 1017720
      },
      "writtenOn": "2026-02-11T10:25:52Z",
      "side": 1,
      "message": "is it worth simplifying patterns (which regexp/syntax can do) before we look up or insert on the weak map? so that e.g. `fo[o] bar{1}` and `foo bar` share the same entry.\n\nprobably not important in practice, but perhaps worth a comment here to reevaluate if extremely similar but not identical patterns actually pop up in user code.",
      "revId": "0b71163c9bb957283729baa85912b3f1a60e1f67",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9613da1_75cf6ca6",
        "filename": "internal/core/adt/regexp_test.go",
        "patchSetId": 1
      },
      "lineNbr": 79,
      "author": {
        "id": 1017720
      },
      "writtenOn": "2026-02-11T10:25:52Z",
      "side": 1,
      "message": "I get that these benchmarks were useful for the commit message stats, but I don\u0027t think they belong in the adt package at all. They benchmark regexp and WeakMap, and neither is something that we are actually maintaining or optimizing. And in terms of the evaluator, they are low level micro-benchmarks which don\u0027t represent the performance that we actually care about for end users.",
      "revId": "0b71163c9bb957283729baa85912b3f1a60e1f67",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d95b34d_6c715f47",
        "filename": "internal/core/adt/weakmap.go",
        "patchSetId": 1
      },
      "lineNbr": 26,
      "author": {
        "id": 1017720
      },
      "writtenOn": "2026-02-11T10:25:52Z",
      "side": 1,
      "message": "I\u0027d add a TODO saying that this is borrowed from https://github.com/golang/go/issues/43615 and we should replace the implementation if/when the upstream issue is resolved.",
      "revId": "0b71163c9bb957283729baa85912b3f1a60e1f67",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a7f9a791_9841c857",
        "filename": "internal/core/adt/weakmap.go",
        "patchSetId": 1
      },
      "lineNbr": 26,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2026-02-11T12:06:26Z",
      "side": 1,
      "message": "I\u0027d either unexport this or put it in its own package. It doesn\u0027t seem like API that we particularly want to expose from core/adt. It could do with a few unit tests though.\n\nAlso, this seems a bit more memory hungry than necessary (the entry structs) and arguably a bit more complex than it needs to be (when storing we don\u0027t really need to do the Swap dance).\n\nHow about making it a closer fit to the problem being solved, something like this perhaps?\n\n```\n// newMemoizer returns a new memoizer value that caches\n// the results of calling the make function.\n// It does not guarantee that there will be at most one\n// *V value at any one time or that make won\u0027t be invoked concurrently.\n//\n// It does not memoize results when make returns an error,\nfunc newMemoizer[K comparable, V any](make func(K) (*V, error)) *memoizer[K, V] {\n\treturn \u0026memoizer[K, V]{\n\t\tmake: make,\n\t}\n}\n\n// memoizer implements a garbage-collectable cache of\n// results from calling the make function.\ntype memoizer[K comparable, V any] struct {\n\t// make returns a new result for K. It is expected\n\t// that it will always return an equivalent non-nil value\n\t// for a given key.\n\tmake func(K) (*V, error)\n\t// string -\u003e weak.Pointer[V]\n\tm sync.Map\n}\n\n// get returns the result for the key k.\nfunc (c *memoizer[K, V]) get(k K) (*V, error) {\n\tif entry, ok :\u003d c.m.Load(k); ok {\n\t\tif v :\u003d entry.(weak.Pointer[V]).Value(); v !\u003d nil {\n\t\t\treturn v, nil\n\t\t}\n\t}\n\t// Could potentially use singleflight or similar to\n\t// avoid redundant make calls in concurrent situations\n\t// but the redundancy probably isn\u0027t much of an issue\n\t// in practice.\n\tv, err :\u003d c.make(k)\n\tif err !\u003d nil {\n\t\treturn nil, err\n\t}\n\twp :\u003d weak.Make(v)\n\truntime.AddCleanup(v, func(wp weak.Pointer[V]) {\n\t\tc.m.CompareAndDelete(k, wp)\n\t}, wp)\n\tc.m.Store(k, wp)\n\treturn v, nil\n}\n```\n\nThen you won\u0027t need the `cachedRegexp` helper function:\n\n```\nvar regexpCache \u003d newMemoizer(regexp.Compile)\n```",
      "revId": "0b71163c9bb957283729baa85912b3f1a60e1f67",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cae347e9_1f202c6d",
        "filename": "internal/core/adt/weakmap.go",
        "patchSetId": 1
      },
      "lineNbr": 26,
      "author": {
        "id": 1017720
      },
      "writtenOn": "2026-02-11T12:12:59Z",
      "side": 1,
      "message": "FWIW this code is directly lifted from the issue I reference in the earlier review. it\u0027s not an accepted proposal at this point, but it\u0027s likely that the final API will look like that. so I\u0027d lean towards using an interface like that unless there\u0027s a strong reason not to, so that in the long term we\u0027re using an off-the-shelf API.",
      "parentUuid": "a7f9a791_9841c857",
      "revId": "0b71163c9bb957283729baa85912b3f1a60e1f67",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}