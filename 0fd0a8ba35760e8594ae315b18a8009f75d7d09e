{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0fbe00f9_ec770a57",
        "filename": "cue/interpreter/wasm/doc.go",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2023-05-03T15:05:24Z",
      "side": 1,
      "message": "I know we\u0027ve discussed this before, but I\u0027m not that keen on the redundancy involved with this, and I think it would be good to be able to identify wasm assets without scanning the entire source code.\n\nHow about something like this instead?\n\n\t@extern(foo, kind\u003d\"wasm\", filename\u003d\"foo.wasm\", abi\u003dc)\n\t@extern(bar, kind\u003d\"wasm\", filename\u003d\"bar.wasm\", abi\u003dc)\n\tpackage p\n\n\tadd: _ @extern(foo, sig\u003d\"func(int64, int64): int64\")\n\tmul: _ @extern(foo, sig\u003d\"func(float64, float64): float64\")\n\tnot: _ @extern(foo, abi\u003dc, sig\u003d\"func(bool): bool\")\n\tisPrime: _ @extern(bar, name\u003dis_prime, sig\u003d\"func(uint64): bool\")\n\nThat is, the package-level @extern attribute introduces a new identifier, usable inside other @extern attributes in that file, that identifies a Wasm asset and its attributes. The other @extern attributes reference the package-level attribute and specify the actual func signature.\n\nThis way, we can find out what wasm files are in use by just scanning the header.\nWe can also make it an error if there are no uses of the wasm identifier, thus removing false positives (same kind of idea as import directives).",
      "revId": "0fd0a8ba35760e8594ae315b18a8009f75d7d09e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c4328b1_1c6781b0",
        "filename": "cue/interpreter/wasm/doc.go",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1003505
      },
      "writtenOn": "2023-05-03T15:12:34Z",
      "side": 1,
      "message": "I don\u0027t have any strong opinions one way or the other, but this would be quite the change from what we have now.",
      "parentUuid": "0fbe00f9_ec770a57",
      "revId": "0fd0a8ba35760e8594ae315b18a8009f75d7d09e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "01239702_dd5288aa",
        "filename": "cue/interpreter/wasm/doc.go",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1003505
      },
      "writtenOn": "2023-05-11T10:09:16Z",
      "side": 1,
      "message": "After chatting about this with Marcel, let\u0027s go with the current design for now. Wasm is an experimental feature and we have the freedom to change the interface if we see a need or think of a better option.\n\nThat said, there are a few thing I don\u0027t like about your counter-proposal. It introduces what essentially amounts to an identifier in the package-level extern declaration (`foo` and `bar` above). Also, it doesn\u0027t really solve the redundancy, because you still have to repeat this identifier for every function import. Is `foo` really that much better than `\"foo.wasm\"` in every function import?\n\nMarcel also said that `kind\u003d\"wasm\"` makes it look optional, where it is not, and that the type of external interpreter is the fundamental object specified in the package-level declaration, so perhaps it should be something like this instead:\n\n    @extern(\"wasm\", ref\u003dfoo, filename\u003d\"foo.wasm\", abi\u003dc)\n    @extern(\"wasm\", ref\u003dbar, filename\u003d\"bar.wasm\", abi\u003dc)\n    package p\n    \n    add: _ @extern(foo, sig\u003d\"func(int64, int64): int64\")\n    mul: _ @extern(foo, sig\u003d\"func(float64, float64): float64\")\n    not: _ @extern(foo, abi\u003dc, sig\u003d\"func(bool): bool\")\n    isPrime: _ @extern(bar, name\u003dis_prime, sig\u003d\"func(uint64): bool\")\n\nNevertheless, in the interest of progress let\u0027s go with the current design for now.",
      "parentUuid": "8c4328b1_1c6781b0",
      "revId": "0fd0a8ba35760e8594ae315b18a8009f75d7d09e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6f35896c_638f406d",
        "filename": "cue/interpreter/wasm/doc.go",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2023-05-12T12:30:54Z",
      "side": 1,
      "message": "\u003e That said, there are a few thing I don\u0027t like about your counter-proposal. It introduces what essentially amounts to an identifier in the package-level extern declaration (`foo` and `bar` above).\n\nThat\u0027s a fair criticism.\n\n\u003e Also, it doesn\u0027t really solve the redundancy, because you still have to repeat this identifier for every function import. Is `foo` really that much better than `\"foo.wasm\"` in every function import?\n\nIt\u0027s not just `\"foo.wasm\"`, it\u0027s `\"foo.wasm`, abi\u003dc`. The `abi\u003dc` at least seems redundant with respect to the declaration at the top (is it actually possible to have two different ABIs in play in a single wasm file?).\n\nThe thing I\u0027m really looking towards here is the potential for having Wasm blobs outside the module as separate entities so they can (for example) be versioned and attested about independently and so we can avoid the need to have a large binary blob as part of an otherwise exclusively text-based repository.\n\nIn that scenario, we\u0027d probably have those resources declared as part of cue.mod and cue.sum, and there wouldn\u0027t be a filename as such. Instead, there would be some kind of name (analogous to a module name), we\u0027d do something like:\n\n   @extern(\"wasm\", externblob\u003d\"something\", abi\u003dc)\n\nbut then it seems a bit odd that we\u0027d need to change the entry in every function when changing where the blob is located.\n\nStill, I agree, let\u0027s go with this for now, as it\u0027s experimental and can indeed be changed.\n\nThat said, I do think it\u0027s nice to be able to easily identify dependencies by scanning just the header of each file, something that\u0027s particularly nice for module dependency resolution. So we should definitely consider declaring wasm assets at the top level in the future.",
      "parentUuid": "01239702_dd5288aa",
      "revId": "0fd0a8ba35760e8594ae315b18a8009f75d7d09e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5bb65795_2f6683cf",
        "filename": "cue/interpreter/wasm/doc.go",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1003505
      },
      "writtenOn": "2023-05-12T13:00:33Z",
      "side": 1,
      "message": "\u003e is it actually possible to have two different ABIs in play in a single wasm file?\n\nYes, in fact, I expect this to be pretty common.\n\nAs for your blob-based example, I\u0027m thinking that if the blob is like a zip, then there are still files (with filenames) inside. In that case the filename could refer to the \"file\" inside the archive rather than to files on disk, so the name could still be useful, I think.\n\nAlso, I expect these CUE files containing references to concrete Wasm modules to be generated in the future by some tooling layer rather than being written by hand. What I am thinking of is the user simply writing they Go/Rust, and then run `go generate` or `cargo build` which would run our tool that will produce all these files. I do not expect the user to have to write these files by hand in the long run.",
      "parentUuid": "6f35896c_638f406d",
      "revId": "0fd0a8ba35760e8594ae315b18a8009f75d7d09e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "27dff534_dc6acda7",
        "filename": "cue/interpreter/wasm/doc.go",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1013536
      },
      "writtenOn": "2023-05-12T14:54:39Z",
      "side": 1,
      "message": "I agree we can keep it as is. We can find a shorthand down the line if needed. Especially since it may be variable per in-file extern, the current format seemingly has to be supported anyway.",
      "parentUuid": "5bb65795_2f6683cf",
      "revId": "0fd0a8ba35760e8594ae315b18a8009f75d7d09e",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}