{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b4b2b098_f839e192",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2343,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-06-19T14:22:09Z",
      "side": 1,
      "message": "This seems a bit weird. `\u003d\u003d` _is_ comparing values to one another, so ISTM by definition those values are comparable. Non-concrete values are genuinely not comparable, but I\u0027m pretty sure the result is an error, not false.\n\nI think we still need to say that different types compare unequal but carve out a special case for float/int.",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc73a0dd_e69c42a3",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2343,
      "author": {
        "id": 1013536
      },
      "writtenOn": "2025-06-23T15:54:26Z",
      "side": 1,
      "message": "It is all a matter of definition, isn\u0027t it. I think the concept of comparable is still useful. But I\u0027m open to a suggestion of new terminology. I cna\u0027t think of anything better now.",
      "parentUuid": "b4b2b098_f839e192",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8410d1d0_a299fe06",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2343,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-06-23T19:32:48Z",
      "side": 1,
      "message": "Here\u0027s a stab at a rephrasing. I decided that it\u0027s probably important to make \"kind\" (could also call it \"type\") a bit more of an explicit thing, because \"type\" is a bit of a fluid concept in CUE and I don\u0027t believe there\u0027s anywhere else that defines it in a way that\u0027s useful here. It also enables a bit of simplification because we can do away with some of the float/int special-casing in favour of using `number`.\n\nNote: I\u0027ve also deliberately split the `string` and `bytes` cases because it\u0027s otherwise very easy to misread (as I did) that it\u0027s possible to compare a `string` value with a `bytes` value.\n\n```\nIn any comparison, both operands must be concrete; otherwise the result is\nbottom (`_|_`).\n\nWhen comparing concrete operands, first the _kind_ of each operand is\nconsidered, defined as which of the following can be successfully\nunified with the operand: `null`, `bool`, `number`, `string`, `bytes`, `{...}`, `[...]`.\n\nWhen the kinds are different, the result is false for `\u003d\u003d`, true for `!\u003d`,\nand an error (bottom) for ordering comparisons (`\u003c`, `\u003c\u003d`, `\u003e`, `\u003e\u003d`).\nOtherwise comparison is made on a kind-by-kind basis; ordering comparisons\nare only allowed when the kind is ordered:\n\n- Null is equal only to itself.\n- Boolean values are equal if they are either both true or both false.\n- Numeric values are ordered and comparable according to their numeric value;\n  if one number is floating point, the other is first converted to a floating-point\n  value too, then they are compared as per the definitions\n  for binary coded decimals in the IEEE-754-2008 standard.\n- String values are ordered and compared lexically byte-wise.\n- Bytes values are ordered and compared lexically byte-wise.\n- Struct values are equal if they have the same set of regular field labels\n  and the corresponding values are recursively equal. Only regular\n  fields are considered in the comparison; field order and closedness\n  are irrelevant.\n- List values are equal if they have the same length and their corresponding\nelements are recursively equal.\n```",
      "parentUuid": "dc73a0dd_e69c42a3",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "661f937c_fb3fea15",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2343,
      "author": {
        "id": 1013536
      },
      "writtenOn": "2025-06-24T07:26:25Z",
      "side": 1,
      "message": "I still think the older definition is neater: we are already defining the relation, do there is no need for another concept like kind. We just need to consider whether the relationship is defined.",
      "parentUuid": "8410d1d0_a299fe06",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd3599c5_f418620f",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2343,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-06-24T07:41:56Z",
      "side": 1,
      "message": "ISTM that we\u0027re already using a concept like \"kind\" even if we\u0027re not calling it out explicitly: each case that\u0027s explicitly enumerated is a \"kind\" and we\u0027re implicitly saying that values matching that case follow that rule when compared to others that also match that case, but values matching different cases compare false.\n\nWe need to say somehow that values of different basic types compare unequal, but given there\u0027s no real concept of \"basic type\" in CUE, how do we do that?",
      "parentUuid": "661f937c_fb3fea15",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f1175462_d34d4bb8",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2343,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-09-15T16:49:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fd3599c5_f418620f",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e78d45f4_6db5a74a",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2345,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-06-19T14:22:09Z",
      "side": 1,
      "message": "This still doesn\u0027t seem quite right to me. That would imply that 1\u003c\"2\" is OK, but I\u0027m pretty sure it\u0027s not.",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "220252c5_c70ee63d",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2345,
      "author": {
        "id": 1013536
      },
      "writtenOn": "2025-06-23T15:54:26Z",
      "side": 1,
      "message": "I don\u0027t read it the same way. To me it means that the operator is defined for operands on which an ordering is defined. THis is not the case for `1\u003c\"2\"`.\n \nNote that this did not change with this change. It is also the language adopted by Go, so there is precendence.\n\nI changed the language a tiny bit in the hope to clarify this, but not sure it is an improvement, really.",
      "parentUuid": "e78d45f4_6db5a74a",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7a9b16f_2bf52a9a",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2345,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-06-23T19:32:48Z",
      "side": 1,
      "message": "Go only allows comparing of values where one is assignable to the other, but that\u0027s not the case here. We could say \"ordered with respect to one another\" but that a bit circular. Perhaps my stab at a rephrasing of the whole thing above makes this a bit clearer?",
      "parentUuid": "220252c5_c70ee63d",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "90688548_4b36421c",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2345,
      "author": {
        "id": 1013536
      },
      "writtenOn": "2025-06-24T07:26:25Z",
      "side": 1,
      "message": "Here we have a \"comparable\" relationship and there result is false if this relationship is undefined. I don\u0027t see how that is different. The only somewhat confusing part is that the comparison _operator_ is defined even if two values are not comparable. So maybe we want to change the name. But in principle I like expressing things in terms of relationships more than introducing antoher concept.",
      "parentUuid": "f7a9b16f_2bf52a9a",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68c88a9c_74fa3edb",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2345,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-06-24T07:41:56Z",
      "side": 1,
      "message": "\u003e The only somewhat confusing part is that the comparison operator is defined even if two values are not comparable\n\nYes, I think that\u0027s indeed confusing. It seems odd to say that it\u0027s OK to compare \"incomparable\" values with one another.",
      "parentUuid": "90688548_4b36421c",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "387ae4c2_aaeb48e1",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2345,
      "author": {
        "id": 1013536
      },
      "writtenOn": "2025-06-24T10:29:12Z",
      "side": 1,
      "message": "It is just comparable at two different levels. The operator is called _equality_. And it defines the outcome if two values are not comparable to be false, instead of bottom. I think that is fine. I don\u0027t think the definition of `kind` is correct, and it is also another concept that does not add much.\n\nI\u0027ve changed the working back to equality to avoid the double use.\n\nSo we now have comparsion operators for the complete collection. Then the groups of these operators use diferent names again. All there behavior is defined in terms of their relations.\n\nSo we still have \"ordering\" operators vs the \"ordered\" relation, but that was as it was before and is not really part of this change.\n\nCompare this with the \"equality\" operators vs the \"comparable\" relation, which is more distinct.",
      "parentUuid": "68c88a9c_74fa3edb",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bd2263b7_f2f42ff1",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2345,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-09-15T16:49:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "387ae4c2_aaeb48e1",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0a088f2_2157bcc5",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2350,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-06-19T14:22:09Z",
      "side": 1,
      "message": "Now that all concrete values are comparable, I don\u0027t think it makes sense to define comparability on a type-by-type basis, other than for special cases such as float and int.",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0cb85f18_15e84f05",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2350,
      "author": {
        "id": 1013536
      },
      "writtenOn": "2025-06-24T10:29:12Z",
      "side": 1,
      "message": "I\u0027ve emphasized the term equality operators again. By definition, not all values are comparable. Equality is just defined to return false for non-comparable values.",
      "parentUuid": "e0a088f2_2157bcc5",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0e8e8677_7e4a7580",
        "filename": "doc/ref/spec.md",
        "patchSetId": 10
      },
      "lineNbr": 2350,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-09-15T16:49:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0cb85f18_15e84f05",
      "revId": "58ec107dd7183018a68c525d7f91435eae1809e6",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}