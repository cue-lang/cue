{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d1a0710e_43c0f86d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 17
      },
      "lineNbr": 0,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-08-06T15:44:07Z",
      "side": 1,
      "message": "This should give you a bit more to chew on. It\u0027s pretty close (and looks brill in general), but I think I\u0027d like a check over again before it lands.",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85c90b64_8b3ef7f6",
        "filename": "internal/lsp/definitions/definitions.go",
        "patchSetId": 17
      },
      "lineNbr": 532,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-08-06T15:44:07Z",
      "side": 1,
      "message": "Using test coverage shows various omissions here (imports, interpolations, unary expressions, etc): it would be good to be a bit more comprehensive given that it\u0027s easy to do that.",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c689620_c9482f6b",
        "filename": "internal/lsp/definitions/definitions.go",
        "patchSetId": 17
      },
      "lineNbr": 557,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-08-06T15:44:07Z",
      "side": 1,
      "message": "Shouldn\u0027t this be introducing a new lexical scope?",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c04cfb20_ed4d6cd4",
        "filename": "internal/lsp/definitions/definitions.go",
        "patchSetId": 17
      },
      "lineNbr": 557,
      "author": {
        "id": 1038145
      },
      "writtenOn": "2025-08-06T16:03:47Z",
      "side": 1,
      "message": "Ahh, you\u0027re thinking of:\n```\n{\n  {_b: int, a: _b}\n  c: _b\n  _b: 4\n}\n```\n?\n\nMy testing shows the `_b`s do get merged, and _b in `a: _b` does resolve to both. Though this is definitely on the edge of the difference between just resolution, and full evaluation - maybe you have an example where I\u0027m definitely doing the wrong thing?",
      "parentUuid": "7c689620_c9482f6b",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9060b77a_92ff5c5f",
        "filename": "internal/lsp/definitions/definitions.go",
        "patchSetId": 17
      },
      "lineNbr": 557,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-08-07T08:02:29Z",
      "side": 1,
      "message": "I guess I don\u0027t understand _why_ there\u0027s no need to start a lexical scope in this case, given that a struct literal does in fact introduce a new lexical scope AIUI.\n\nAnd I see the lexical scope logic inside the `token.OR` logic and I don\u0027t understand why it should be needed and wonder if it\u0027s there because of the lack of lexical scope logic in the struct-lit case.\n\nAnd, yes, it does seem definitely on the edge of full evaluation.\n\nHere\u0027s an example which is maybe questionable:\n\n```\n{\n\t{_a: int, b: _a}\n\t_a: 2\n} \u0026 {\n\t_a: \u003e1\n}\n```\nin this case, it resolves that first `_a` expression to all the `_a` field definitions. I can\u0027t work out if that\u0027s weird or not: after all, those fields do all end up merged, but on the other hand it\u0027s hard for me to justify saying that the `_a` reference is _actually_ referring to that `_a` field in a struct in a totally different lexical scope.\n\nMaybe this is where the kind of results should be different for the first element (lexical scope) and subsequent elements in the path (navigible/dynamic/object scope)",
      "parentUuid": "c04cfb20_ed4d6cd4",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c135cf9_b3375f62",
        "filename": "internal/lsp/definitions/definitions.go",
        "patchSetId": 17
      },
      "lineNbr": 557,
      "author": {
        "id": 1038145
      },
      "writtenOn": "2025-08-07T08:30:41Z",
      "side": 1,
      "message": "\u003e And I see the lexical scope logic inside the token.OR logic and I don\u0027t understand why it should be needed and wonder if it\u0027s there because of the lack of lexical scope logic in the struct-lit case.\n\nMy thinking is this:\n\na: whatever\n\nis the same as\n\na: {whatever}\n\nSo, when we encounter a field, the field value has to have its own scope. It may well be the case that the value is a structlit. There\u0027s no need for double-wrapping.\n\nSo in general, I\u0027ve taken the approach that the parent context is always responsible for determining when a new scope is needed, and so when you\u0027re in a scope, you just keep unpacking until you get to things (e.g. fields) where you know for certain that you need to create new scopes.\n\nIt\u0027s possible this could all be changed to what you\u0027re thinking, which is that structlit et al are themselves responsible for making their own scopes. There danger that without the flattening effect that we currently have, getting the navigable scopes lined up might become much harder. Consider:\n\n```\nx: {{{{a: 3}}}}\nx: a: int\ny: x.a\n```\n\nWe need the x.a to resolve to both `a: int` and `a: 3`. Flattening out the structlits is the easy way to do this.\n\n\nIn the case of disjunction (and now conjunction too), this is the other side of the coin. The code is currently (unpushed):\n\n```\ncase token.AND, token.OR:\n\tlhs :\u003d ls.newLexicalScope(nil, n.X, nil)\n\trhs :\u003d ls.newLexicalScope(nil, n.Y, nil)\n\tls.resolvesTo \u003d append(ls.resolvesTo, lhs, rhs)\n```\n\nIt is necessary that bindings with X or Y do not pollute the parent, and do not pollute (nor are visible) to each other. For example:\n\n```\na: {b: c, c: 5} | {c: true}\nx: a.c\n```\n\nThe structlits do not create their own scopes, but the binary op does. This ensures that the `b: c` from the lhs, does not resolve the `c` to the `c: true` in the rhs.\n\nBecause both of the new scopes are added to the parent\u0027s `resolvesTo` field, the `a.c` path is able to find both definitions of `c`.\n\nSo essentially, I think the scope creation has been unrolled one loop, or something, so that we can flatten nested embedded scopes. I hope it\u0027s safe to do that, but I don\u0027t really have any proof!",
      "parentUuid": "9060b77a_92ff5c5f",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "673dac55_22e4b681",
        "filename": "internal/lsp/definitions/definitions.go",
        "patchSetId": 17
      },
      "lineNbr": 589,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-08-06T15:44:07Z",
      "side": 1,
      "message": "I don\u0027t understand why this is different from token.AND: there\u0027s no scoping difference between those two operations AFAIK.\n\nAnd indeed, it looks like there is an issue with the existing AND logic: it fails on this test:\n\n```\n\t\t\tarchive: `-- a.cue --\nc: {a: b} \u0026 {b: 3}\nb: 7\nd: c.b\n`,\n\t\t\texpectations: map[*position][]*position{\n\t\t\t\tln(1, 1, \"b\"): {ln(2, 1, \"b\")},\n\t\t\t\tln(3, 1, \"c\"): {ln(1, 1, \"c\")},\n\t\t\t\tln(3, 1, \"b\"): {ln(1, 2, \"b\")},\n\t\t\t},\n```\n\nSpecifically that first `b` reference incorrectly resolves to the `b` in the second struct literal.\n\nI think probably both AND and OR need the same lexical scope treatment (but I still don\u0027t quite understand what\u0027s going on there tbh).",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "195f8db9_a5821365",
        "filename": "internal/lsp/definitions/definitions.go",
        "patchSetId": 17
      },
      "lineNbr": 589,
      "author": {
        "id": 1038145
      },
      "writtenOn": "2025-08-06T16:34:50Z",
      "side": 1,
      "message": "Brilliant, thank you, especially for the test. You\u0027re right - I believe the OR behaviour is correct and the AND is not.",
      "parentUuid": "673dac55_22e4b681",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5180d86_0466b18c",
        "filename": "internal/lsp/definitions/definitions.go",
        "patchSetId": 17
      },
      "lineNbr": 719,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-08-06T15:44:07Z",
      "side": 1,
      "message": "perhaps say something about what the returned slice actually represents?",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "166edd24_48410a9d",
        "filename": "internal/lsp/definitions/definitions.go",
        "patchSetId": 17
      },
      "lineNbr": 719,
      "author": {
        "id": 1038145
      },
      "writtenOn": "2025-08-11T10:50:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d5180d86_0466b18c",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "99cd5ede_51b678b9",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 31,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-08-06T15:44:07Z",
      "side": 1,
      "message": "I\u0027d be tempted to put the tests first (the thing we really care about seeing most) and all the helper stuff afterwards.",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8e92733c_f48e32ea",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 31,
      "author": {
        "id": 1038145
      },
      "writtenOn": "2025-08-07T11:12:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "99cd5ede_51b678b9",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ed74397_1aef334f",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 76,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-08-06T15:44:07Z",
      "side": 1,
      "message": "This checks the results for some chosen offsets. However, ISTM that it would be nicer to have a more comprehensive test that checks the results for every single file offset within the test while using essentially the same test data.\nThis would require a slight change in the data representation: a position currently represents a single offset within the file, but is invariably defined with respect to a string, and hence could be used to define a range (all the characters in the string). So you\u0027d just need to range through all the offsets in all the files: if an offset doesn\u0027t overlap with any \"expectation\" range, we expect an empty result.\n\nThis potentially gives a bunch more coverage without much extra effort.",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "846cee33_6610fe82",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 76,
      "author": {
        "id": 1038145
      },
      "writtenOn": "2025-08-07T15:37:54Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2ed74397_1aef334f",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44c79f00_a24e2c29",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 77,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-08-06T15:44:07Z",
      "side": 1,
      "message": "Why skip the test if there are no wanted positions? Surely we want to be able to test the logic when an identifier doesn\u0027t resolve to anything?",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24589a25_a3b135de",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 77,
      "author": {
        "id": 1038145
      },
      "writtenOn": "2025-08-06T16:03:47Z",
      "side": 1,
      "message": "This is the deliberate difference between nil and the empty list. There are plenty of cases where I explicitly test for the empty list, but as the nearby comment notes, it\u0027s also deliberate the the test does not need to capture every possible resolution.\n\nBut maybe we\u0027re talking past each other and you\u0027ve spotted something that I\u0027m missing?",
      "parentUuid": "44c79f00_a24e2c29",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "863862c8_62fd7cf8",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 77,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-08-07T08:02:29Z",
      "side": 1,
      "message": "I\u0027m fairly sure there are actually no cases where you have an explicit nil (and there are no implicit nils because we\u0027re dealing with a map not a slice): I removed this logic and all the tests passed.",
      "parentUuid": "24589a25_a3b135de",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8ad68b3c_2f900cb2",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 77,
      "author": {
        "id": 1038145
      },
      "writtenOn": "2025-08-07T08:15:50Z",
      "side": 1,
      "message": "I must be misunderstanding you.\n\nAs you say, there are no tests where the positionsWant is explicitly set to nil....\nOh! The penny just dropped. This code is indeed a hang-over from when the expectations was a list, so lots of nil values. It later changed into a map, and yes this code can be removed now. Sorry for the confusion.",
      "parentUuid": "863862c8_62fd7cf8",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d1cf9934_e80da0d6",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 90,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-08-06T15:44:07Z",
      "side": 1,
      "message": "This produces a really unhelpful error when there\u0027s a mismatch in length (we don\u0027t get to see anything of the actual contents). I\u0027d suggest mapping the elements to something in common between both before comparing.\n\nTo potentially save you a bit of work, here\u0027s a diff of the changes that I made to do this when playing with the logic locally: https://gist.github.com/rogpeppe/c63255834b2eb5095c3468d6d55b927b\n\nUpdate: it also doesn\u0027t print the \"from\" offset on failure, which is also important information.",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "043125f1_e720a3b7",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 90,
      "author": {
        "id": 1038145
      },
      "writtenOn": "2025-08-07T11:12:12Z",
      "side": 1,
      "message": "Many thanks - I had been mildly irritated by this, but not sufficiently enough to actually do anything about it!",
      "parentUuid": "d1cf9934_e80da0d6",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "178999b1_39e1e6bb",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 172,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-08-06T15:44:07Z",
      "side": 1,
      "message": "I\u0027d like to see some tests involving string-literal fields. For example, I think that the results of the below should be the same as the first test in this table, but they don\u0027t seem to be:\n\n```\nx: y: a.b\na: b: 5\n\"a\": b: 6\n```",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2c5e2e03_4dec0549",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 172,
      "author": {
        "id": 1038145
      },
      "writtenOn": "2025-08-07T15:52:50Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "178999b1_39e1e6bb",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "300f6750_5dc78c50",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 174,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-08-06T15:44:07Z",
      "side": 1,
      "message": "nit: it\u0027s nice when the test name as printed by `go test` is a literal match for the test name as defined in the code; that makes it easier to copy/paste a search term for the test. In practice, that means avoiding spaces because they\u0027re translated to underscores.\n\nSo I\u0027d probably use names in this style (trying to keep your hierarchy intact)\n\n\n```suggestion\n\t\t\tname: \"Selector_Implicit_ViaRoot\",\n```",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3ee1f1d4_d4067977",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 174,
      "author": {
        "id": 1038145
      },
      "writtenOn": "2025-08-07T11:12:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "300f6750_5dc78c50",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9445152f_dafdc4fe",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 254,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-08-06T15:44:07Z",
      "side": 1,
      "message": "It would be nice to see some test cases involving list literals too.\n\nFor example:\n\n```\nx: [{a: 5}, {b, 6}]\ny: x[0].a\n```\n\n```\nx: [... {a!: int}]\ny: int\nz: x[y].a\n```",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6190689a_5d89787d",
        "filename": "internal/lsp/definitions/definitions_test.go",
        "patchSetId": 17
      },
      "lineNbr": 254,
      "author": {
        "id": 1038145
      },
      "writtenOn": "2025-08-11T10:50:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9445152f_dafdc4fe",
      "revId": "5abc98ba706bd91ee83c2c73c94798b342a84e9b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}