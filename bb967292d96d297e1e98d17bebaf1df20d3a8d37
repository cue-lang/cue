{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "b5609aec_ec3874b5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-10-08T10:19:50Z",
      "side": 1,
      "message": "I think a bit more thought is required here: this runs significant risk of breaking things.",
      "revId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0ed5a316_189ccade",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-10-08T10:36:45Z",
      "side": 1,
      "message": "One more thing I discovered: this seems to break stdlib yaml usage. This example did work but is broken by this CL:\n\n```\nexec cue export foo.cue\n-- foo.cue --\nimport \"encoding/yaml\"\np: yaml.Unmarshal(\"\"\"\n    a: \u0026a 3\n    b: *a\n    \"\"\")\n```",
      "revId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a88a0de8_6bdff227",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1039031
      },
      "writtenOn": "2025-10-08T11:57:47Z",
      "side": 1,
      "message": "I must disclose that I\u0027ve lost personal interest in this change since I\u0027ve moved on from the problem I was working on, and won\u0027t come back to it.\nHowever, I do have free time for the next week so I make the effort to get this merged.\n\nHowever, if this likely to break things all over, and you deem the risk-reward not worth it, we can abandon this altogether - no strings attached. I personally found this useful when importing huge YAMLs, so I thought others would as well.",
      "parentUuid": "b5609aec_ec3874b5",
      "revId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4291b5d6_08d48bd9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1039031
      },
      "writtenOn": "2025-10-08T11:57:47Z",
      "side": 1,
      "message": "I can have a look.",
      "parentUuid": "0ed5a316_189ccade",
      "revId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6b05f25_3a0579dc",
        "filename": "internal/encoding/yaml/decode.go",
        "patchSetId": 2
      },
      "lineNbr": 729,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-10-08T10:19:50Z",
      "side": 1,
      "message": "There is no guarantee that the anchor value is a valid CUE identifier, and indeed it often is not (my first Google hit for \"yaml anchors\" came up with this example https://support.atlassian.com/bitbucket-cloud/docs/yaml-anchors/), so this can end up breaking existing valid YAML imports. For example, this test fails now:\n\n```\nexec cue export x.yaml\n-- x.yaml --\na: \u0026build-test\nb: *build-test\n```\n\nThere is also the risk that these definitions end up clashing with existing definitions. For example, this test passes on the old implementation but fails on the new:\n\n```\nexec cue mod init\nexec cue export .\n-- x.yaml --\na: \u0026anchor\nb: *anchor\n-- foo.cue --\n@extern(embed)\n\npackage foo\n\n_data: _ @embed(file\u003dx.yaml)\n_data\n#anchor: true\n```\n\nI wonder if this should be an opt-in feature.\nAlternatively, perhaps choose names that are more yaml-encoder-specific to avoid the risk of namespace clashes.",
      "revId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6c3ea27_671321c9",
        "filename": "internal/encoding/yaml/decode.go",
        "patchSetId": 2
      },
      "lineNbr": 729,
      "author": {
        "id": 1039031
      },
      "writtenOn": "2025-10-08T11:49:07Z",
      "side": 1,
      "message": "This is good feedback, thanks.\n\nRegarding your first point, I see two ways around it. Either sanitize the YAML anchors to valid CUE identifiers, or outright ignore anchors which are invalid CUE identifiers. I\u0027m leaning towards the second option - but there has to be a clear user warning so the user is aware why such anchors were ignored.\n\nRegarding definition names derived from YAML anchors conflicting with existing CUE definitions. I don\u0027t have a lot of experience with CUE, so I\u0027m unsure how ubiquitous this situation is.\nHowever, I think there are two separate use-cases here. In your example you embed a YAML file, and the definition collision is indeed unwanted behavior. I agree it\u0027s better to turn off this feature in this case, as it pollutes the namespace (as you said).\nThe other use-case would be running `cue import x.yaml`. In which case one can argue the collision is not necessarily undesired. Here\u0027s an example without anchors:\n\n```\n$ cat foo.cue \npackage foo\n\ng: 3\n$ cat x.yaml \ng: 4\n$ cue import -p foo x.yaml\n$ cue export .\ng: conflicting values 4 and 3:\n    ./foo.cue:3:4\n    ./x.cue:3:4\n```\n\nThe import itself doesn\u0027t fail but the export does.\n(and FWIW, embedding this `x.yaml` inside `foo.cue` would also cause an export error, as the YAML would pollute the namespace, it\u0027s just a bit more subtle when it comes to anchors \u003c-\u003e definitions. This also slightly contradicts my sentiment above of disabling this feature when embedding).\n\n\u003e Alternatively, perhaps choose names that are more yaml-encoder-specific to avoid the risk of namespace clashes.\n\nCan you clarify what do you mean by this? Do you mean adding some prefix to the resulting definition names such that \u0026myAnchor would become #yamlEncodermyAnchor?\n\nRegarding this being opt-in - I would rather avoid this if possible. It\u0027s better to introduce something which works well and the user doesn\u0027t have to think about, rather than introduce another flag.\nAdditionally - making this opt-in would introduce maintenance burden. We would have to test both code paths. And on top of this, I\u0027m unsure which changes to the code base does this two-mode encoder imply - I\u0027ll have to take a look.",
      "parentUuid": "e6b05f25_3a0579dc",
      "revId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f233006_bff7a1cf",
        "filename": "internal/encoding/yaml/decode.go",
        "patchSetId": 2
      },
      "lineNbr": 729,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-10-08T12:18:21Z",
      "side": 1,
      "message": "I guess the larger question here is: is it valid to consider anchors to be part of the \"public API\" of a YAML document? The unstated assumption of this CL is that it is: if a YAML document is updated and changes the anchor name, then it will change the CUE API surface area.\n\nI suspect that there\u0027s no single answer here and that it depends very much on the YAML in question. That\u0027s why I\u0027m suggesting the possibility of making it a decoding option.\n\nWe could just use `let` statements and avoid the question for now, I guess. But were you intending to use the anchor references directly in your use case?\n\n\u003e Can you clarify what do you mean by this? Do you mean adding some prefix to the resulting definition names such that \u0026myAnchor would become #yamlEncodermyAnchor?\n\nThat kind of thing, yeah. Or `_#yaml.myAnchor` or whatever.",
      "parentUuid": "e6c3ea27_671321c9",
      "revId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b96c2de_39f963c0",
        "filename": "internal/encoding/yaml/decode.go",
        "patchSetId": 2
      },
      "lineNbr": 729,
      "author": {
        "id": 1039031
      },
      "writtenOn": "2025-10-08T12:49:57Z",
      "side": 1,
      "message": "\u003e I guess the larger question here is: is it valid to consider anchors to be part of the \"public API\" of a YAML document?\n\nMy first instinctive answer to this question is plainly \"no\". Even most YAML libraries across different programming languages usually do not expose the anchors when deserializing YAML files.\n\nHowever, I disagree about the assumption I had in mind when writing this CL. The underlying assumption was that the equivalent CUE representation for a YAML file with anchors, is a CUE file where each anchor is converted to an identifier.\nThis strengthens the notion that this feature should probably be disabled when embedding YAML files, since the anchors are not a part of their \"public API\".\n\nThough when doing a one-off `cue import`, I think this feature gives a more accurate representation of the current state of the YAML file.\n\n\u003e We could just use `let` statements and avoid the question for now, I guess.\n\nCan you elaborate why would this solve the issue? Daniel proposed this initially but I went for definitions since the scope for the let expressions does not behave like YAML anchor scopes (YAML anchors are valid from the line they are defined until the line they are overridden, or the end of the document).\n\nI just fail to understand how would this solve the issue. What am I missing here?\n\n\u003e But were you intending to use the anchor references directly in your use case?\n\nMy specific use case was importing YAML files with tens of thousands of lines, containing complex anchors. I was trying to simplify the definitions and improving the readability of the documents by adding constraints which you can do in CUE and not in YAML, obviously.",
      "parentUuid": "7f233006_bff7a1cf",
      "revId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0edc8af_c1ec746b",
        "filename": "internal/encoding/yaml/decode.go",
        "patchSetId": 2
      },
      "lineNbr": 729,
      "author": {
        "id": 1007275
      },
      "writtenOn": "2025-10-08T14:10:51Z",
      "side": 1,
      "message": "\u003e The underlying assumption was that the equivalent CUE representation for a YAML file with anchors, is a CUE file where each anchor is converted to an identifier.\n\nI agree with this. But an \"identifier\" in CUE can be several kinds of things: a string label, a definition label, a let definition, etc.\n\n\u003e Can you elaborate why would this solve the issue? Daniel proposed this initially but I went for definitions since the scope for the let expressions does not behave like YAML anchor scopes (YAML anchors are valid from the line they are defined until the line they are overridden, or the end of the document).\n\nIt would solve the problem because `let` just defines identifiers locally so they\u0027re available in the local lexical scope and nowhere else.\n\nI agree the scope of let expressions does not behave like YAML anchor scopes, but neither do CUE definitions: I don\u0027t entirely see how one is more aligned than the other in this respect.\n\n\u003e My specific use case was importing YAML files with tens of thousands of lines, containing complex anchors.\nThat\u0027s good to know, thanks! So it seems that there\u0027s no inherent reason you\u0027d need actual definitions vs lets, right?",
      "parentUuid": "7b96c2de_39f963c0",
      "revId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a5ba9ed_bb5cbf9b",
        "filename": "internal/encoding/yaml/decode.go",
        "patchSetId": 2
      },
      "lineNbr": 729,
      "author": {
        "id": 1039031
      },
      "writtenOn": "2025-10-08T14:50:28Z",
      "side": 1,
      "message": "\u003e I agree with this. But an \"identifier\" in CUE can be several kinds of things: a string label, a definition label, a let definition, etc.\n\nYeah I meant definition.\n\n\u003e That\u0027s good to know, thanks! So it seems that there\u0027s no inherent reason you\u0027d need actual definitions vs lets, right?\n\nRethinking this, I probably don\u0027t.\n\nI\u0027ll have a look at re-writing this using let declarations. Which I suppose leaves us with with the invalid identifier problem - do you think it makes sense to ignore invalid identifiers and warn the user?",
      "parentUuid": "c0edc8af_c1ec746b",
      "revId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "984be7f1_59f43142",
        "filename": "internal/encoding/yaml/decode.go",
        "patchSetId": 2
      },
      "lineNbr": 729,
      "author": {
        "id": 1039031
      },
      "writtenOn": "2025-10-09T07:39:52Z",
      "side": 1,
      "message": "I changed the code to produce let declarations instead, however I started getting collisions between alias names and field names, since I removed the leading `#`. Would it make sense to prefix the let identifier with `#` or is this reserved *just* for definitions?",
      "parentUuid": "4a5ba9ed_bb5cbf9b",
      "revId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93598a44_418ed824",
        "filename": "internal/encoding/yaml/decode.go",
        "patchSetId": 2
      },
      "lineNbr": 729,
      "author": {
        "id": 1017720
      },
      "writtenOn": "2025-10-09T08:28:55Z",
      "side": 1,
      "message": "For the updated change - could you send it via Gerrit directly? That way it can be reviewed and merged here, without us having to do the dance of importing a GitHub PR. I\u0027d then abandon this one. See: https://github.com/cue-lang/cue/blob/master/CONTRIBUTING.md#preparing-for-gerrithub-cl-contributions",
      "parentUuid": "984be7f1_59f43142",
      "revId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9f84378c_f7ad5d1a",
        "filename": "internal/encoding/yaml/decode.go",
        "patchSetId": 2
      },
      "lineNbr": 729,
      "author": {
        "id": 1039031
      },
      "writtenOn": "2025-10-10T11:28:58Z",
      "side": 1,
      "message": "@mvdan@mvdan.cc\nI tried sending it via Gerrit, but that failed. Maybe you have to set me as the owner of this change? It\u0027s my first time using Gerrit so maybe I did something wrong?\n\nI ran `git push gerrit HEAD:refs/for/master` where `gerrit` is the SSH remote pointing to Gerrit, and I get the following error:\n\n```\n ! [remote rejected]     HEAD -\u003e refs/for/master (cannot add patch set to 1223900.)\n```",
      "parentUuid": "93598a44_418ed824",
      "revId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1af6cd8b_6b61970e",
        "filename": "internal/encoding/yaml/decode.go",
        "patchSetId": 2
      },
      "lineNbr": 729,
      "author": {
        "id": 1017720
      },
      "writtenOn": "2025-10-10T11:45:09Z",
      "side": 1,
      "message": "You need a new Change-id trailer so that it sends a new patch; otherwise you cannot edit my patch here directly",
      "parentUuid": "9f84378c_f7ad5d1a",
      "revId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "At least one Code-Review+2 is required. Self review is not allowed, except for Marcel."
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader OR label:Code-Review\u003dMAX,user\u003dmpvl@gmail.com"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader OR label:Code-Review=MAX,user=mpvl@gmail.com"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Code-Review=MAX,user=non_uploader","label:Code-Review=MAX,user=mpvl@gmail.com"],"atomExplanations":{"value":{"label:Code-Review=MAX,user=non_uploader":"","label:Code-Review=MAX,user=mpvl@gmail.com":""}}}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Do-Not-Review",
        "description": {
          "value": "Changes that have DO NOT REVIEW in their commit message are not submittable."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (R|r)(E|e)(V|v)(I|i)(E|e)(W|w).*\""
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:false"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (R|r)(E|e)(V|v)(I|i)(E|e)(W|w).*\""},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (R|r)(E|e)(V|v)(I|i)(E|e)(W|w).*\""],"atomExplanations":{"value":{"message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (R|r)(E|e)(V|v)(I|i)(E|e)(W|w).*\"":""}}}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:false"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[],"atomExplanations":{"value":null}}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Do-Not-Submit",
        "description": {
          "value": "Changes that have DO NOT SUBMIT in their commit message are not submittable."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (S|s)(U|u)(B|b)(M|m)(I|i)(T|t).*\""
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:false"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (S|s)(U|u)(B|b)(M|m)(I|i)(T|t).*\""},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (S|s)(U|u)(B|b)(M|m)(I|i)(T|t).*\""],"atomExplanations":{"value":{"message:\"^.*(D|d)(O|o) (N|n)(O|o)(T|t) (S|s)(U|u)(B|b)(M|m)(I|i)(T|t).*\"":""}}}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:false"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[],"atomExplanations":{"value":null}}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "No-Holds",
        "description": {
          "value": "Changes with a Hold+1 vote are not submittable."
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "NOT label:Hold\u003d1"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"NOT label:Hold=1"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":["label:Hold=1"],"failingAtoms":[],"atomExplanations":{"value":{"label:Hold=1":""}}}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "TryBot-Result",
        "description": {
          "value": "TryBot-Result+1 is required. Unity-Result is not, as intentional breakages can happen. Can be bypassed by Chief Cueckoo with Code-Review+2."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "-branch:refs/meta/config"
          }
        },
        "submittabilityExpression": {
          "expressionString": "label:TryBot-Result\u003dMAX OR label:Code-Review\u003dMAX,user\u003dchief.cueckoo@gmail.com"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"-branch:refs/meta/config"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["branch:refs/meta/config"],"atomExplanations":{"value":{"branch:refs/meta/config":""}}}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:TryBot-Result=MAX OR label:Code-Review=MAX,user=chief.cueckoo@gmail.com"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["label:TryBot-Result=MAX"],"failingAtoms":["label:Code-Review=MAX,user=chief.cueckoo@gmail.com"],"atomExplanations":{"value":{"label:TryBot-Result=MAX":"","label:Code-Review=MAX,user=chief.cueckoo@gmail.com":""}}}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "bb967292d96d297e1e98d17bebaf1df20d3a8d37",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}