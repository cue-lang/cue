// Copyright 2024 CUE Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"cuelang.org/go/cue"
	"cuelang.org/go/cue/ast"
	"cuelang.org/go/cue/build"
	"cuelang.org/go/cue/load"
	"cuelang.org/go/mod/module"
	"github.com/spf13/cobra"
)

func newExpCmd(c *Command) *cobra.Command {
	cmd := &cobra.Command{
		// Experimental commands are hidden by design.
		Hidden: true,

		Use:   "exp <cmd> [arguments]",
		Short: "experimental commands",
		Long: `
exp groups commands which are still in an experimental stage.

Experimental commands may be changed or removed at any time,
as the objective is to gain experience and then move the feature elsewhere.
`[1:],
		RunE: mkRunE(c, func(cmd *Command, args []string) error {
			stderr := cmd.Stderr()
			if len(args) == 0 {
				fmt.Fprintln(stderr, "exp must be run as one of its subcommands")
			} else {
				fmt.Fprintf(stderr, "exp must be run as one of its subcommands: unknown subcommand %q\n", args[0])
			}
			fmt.Fprintln(stderr, "Run 'cue help exp' for known subcommands.")
			return ErrPrintedError
		}),
	}

	cmd.AddCommand(newExpGenGoTypesCmd(c))
	return cmd
}

func newExpGenGoTypesCmd(c *Command) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "gengotypes",
		Short: "generate Go types from CUE definitions",
		Long: `
gengotypes generates Go type definitions from any CUE definition
at the top level or underneath other definitions.

Dependencies are generated automatically as well, to ensure working Go code.
The generated code is placed in cue_gen.go files in the directory of each package.

@go attributes can be used to override which name or type to be generated, for example:

    renamed: int @go(BetterName)
    retyped: string @go(,type=foo.com/bar.NamedString)

`[1:],
		// TODO: write a long help text once the feature set is reasonably stable.
		RunE: mkRunE(c, runExpGenGoTypes),
	}

	return cmd
}

func runExpGenGoTypes(cmd *Command, args []string) error {
	insts := load.Instances(args, &load.Config{})

	// record which package instances have already been generated
	instDone := make(map[*build.Instance]bool)

	for len(insts) > 0 { // we append imports to this list
		inst := insts[0]
		insts = insts[1:]
		if err := inst.Err; err != nil {
			return err
		}
		if instDone[inst] {
			continue
		}
		println(inst.ImportPath)
		instDone[inst] = true

		instVal := cmd.ctx.BuildInstance(inst)
		if err := instVal.Validate(); err != nil {
			return err
		}
		g := generator{
			pkgRoot:    instVal,
			defsAdded:  make(map[cue.Value]bool),
			importedAs: make(map[string]string),
		}
		iter, err := instVal.Fields(cue.Definitions(true), cue.Hidden(true))
		if err != nil {
			return err
		}
		for iter.Next() {
			sel := iter.Selector()
			if sel.IsDefinition() {
				val := iter.Value()
				g.defsAdded[val] = true
				g.defsList = append(g.defsList, cue.MakePath(sel))
			}

		}
		for len(g.defsList) > 0 {
			path := g.defsList[0]
			g.defsList = g.defsList[1:]

			name := goNameFromPath(path, true)
			val := instVal.LookupPath(path)

			g.emitDocs(name, val.Doc())
			g.appendf("type %s ", name)
			if err := g.emitType(val); err != nil {
				return err
			}
			g.appendf("\n\n")
		}

		typesBuf := g.dst
		g.dst = nil

		// TODO: we should refuse to generate for packages which are not
		// part of the main module, as they may be inside the read-only module cache.
		for _, imp := range inst.Imports {
			if !instDone[imp] && g.importedAs[imp.ImportPath] != "" {
				insts = append(insts, imp)
			}
		}

		g.appendf("// Code generated by \"cue exp gengotypes\"; DO NOT EDIT.\n\n")
		g.appendf("package %s\n\n", inst.PkgName)
		// TODO: maps.Keys etc
		var imported []string
		for _, path := range g.importedAs {
			imported = append(imported, path)
		}
		// TODO: need to remove dupes here too
		sort.Strings(imported)
		if len(imported) > 0 {
			g.appendf("import (\n")
			for _, path := range imported {
				g.appendf("\t%q\n", path)
			}
			g.appendf(")\n")
		}
		g.appendf("%s", typesBuf)
		formatted, err := format.Source(g.dst)
		if err != nil {
			// Showing the generated Go code helps debug where the syntax error is.
			// This should only occur if our code generator is buggy.
			fmt.Fprintf(os.Stderr, "-- %s/cue_gen.go --\n%s\n--\n", inst.Dir, g.dst)
			return err
		}
		// TODO: this won't work for multi-package directories.
		outfile := filepath.Join(inst.Dir, "cue_gen.go")
		if err := os.WriteFile(outfile, formatted, 0o666); err != nil {
			return err
		}
	}
	return nil
}

// generator holds the state for generating Go code for one CUE package instance.
type generator struct {
	dst []byte

	// defsAdded records which definitions have already been added to [generator.defsList].
	defsAdded map[cue.Value]bool

	// defsList records the remaining definitions which need to be generated.
	// Any definition at the top level or underneath other definitions must be added here.
	defsList []cue.Path

	// importedAs records which packages need to be importedAs in the generated Go package.
	// This is collected as we emit types, given that some CUE fields and types are omitted
	// and we don't want to end up with unused Go imports.
	//
	// The keys are the full CUE import paths; the values are the unqualified Go import paths.
	importedAs map[string]string

	// pkgRoot is the root value of the CUE package, necessary to tell if a referenced value
	// belongs to the current package or not.
	pkgRoot cue.Value
}

func (g *generator) appendf(format string, args ...any) {
	g.dst = fmt.Appendf(g.dst, format, args...)
}

// emitType generates a CUE value as a Go type.
// When possible, the Go type is emitted in the form of a reference.
// Otherwise, an inline Go type expression is used.
func (g *generator) emitType(val cue.Value) error {
	if g.emitTypeReference(val) {
		return nil
	}
	switch k := val.IncompleteKind(); k {
	case cue.StructKind:
		if elem := val.LookupPath(cue.MakePath(cue.AnyString)); elem.Err() == nil {
			g.appendf("map[string]")
			if err := g.emitType(elem); err != nil {
				return err
			}
			break
		}
		// TODO: treat a single embedding like `{[string]: int}` like we would `[string]: int`
		g.appendf("struct {\n")
		iter, err := val.Fields(cue.Definitions(true), cue.Hidden(true), cue.Optional(true))
		if err != nil {
			return err
		}
		for iter.Next() {
			sel := iter.Selector()
			val := iter.Value()
			if sel.IsDefinition() {
				if g.defsAdded[val] {
					continue
				}
				g.defsAdded[val] = true
				fmt.Println(sel.String(), val.Path().String())
				g.defsList = append(g.defsList, val.Path())
				continue
			}
			cueName := sel.String()
			cueName = strings.TrimRight(cueName, "?!")
			g.emitDocs(cueName, val.Doc())
			optional := sel.ConstraintType()&cue.OptionalConstraint != 0

			// We want the Go name from just this selector, even when it's not a definition.
			goName := goNameFromPath(cue.MakePath(sel), false)

			goAttr := val.Attribute("go")
			if s, _ := goAttr.String(0); s != "" {
				goName = s
			}

			g.appendf("%s ", goName)
			if s, _, _ := goAttr.Lookup(1, "type"); s != "" {
				i := strings.LastIndexByte(s, '.')
				if i > 0 {
					// For "type=foo.Name", we need to ensure that "foo" is imported.
					pkgPath := s[:i]
					g.importedAs[pkgPath] = pkgPath
					// For "type=foo/bar.Name", the selector is just "bar.Name".
					// Note that this doesn't support Go packages whose name does not match
					// the last element of their import path. That seems OK for now.
					if i := strings.LastIndexByte(s, '/'); i > 0 {
						s = s[i+1:]
					}
				}
				g.appendf("%s", s)
			} else if err := g.emitType(val); err != nil {
				return err
			}
			// TODO: should we generate cuego tags like `cue:"expr"`?
			g.appendf(" `json:\"%s", cueName)
			if optional {
				g.appendf(",omitempty")
			}
			g.appendf("\"`")
			g.appendf("\n\n")
		}
		g.appendf("}")
	case cue.ListKind:
		// We mainly care about patterns like [...string].
		// Anything else can convert into []any as a fallback.
		g.appendf("[]")
		elem := val.LookupPath(cue.MakePath(cue.AnyIndex))
		if err := g.emitType(elem); err != nil {
			return err
		}

	case cue.NullKind:
		g.appendf("*struct{} /* CUE null */")
	case cue.BoolKind:
		g.appendf("bool")
	case cue.IntKind:
		g.appendf("int64")
	case cue.FloatKind:
		g.appendf("float64")
	case cue.StringKind:
		g.appendf("string")
	case cue.BytesKind:
		g.appendf("[]byte")

	case cue.NumberKind:
		// Can we do better for numbers?
		g.appendf("any /* CUE number; int64 or float64 */")

	case cue.TopKind:
		g.appendf("any /* CUE top */")

	// TODO: generate e.g. int8 where appropriate
	// TODO: uint64 would be marginally better than int64 for unsigned integer types

	default:
		g.appendf("any /* TODO: IncompleteKind: %s */", k)
	}
	return nil
}

// goNameFromPath transforms a CUE path, such as "#foo.bar?",
// into a suitable name for a generated Go type, such as "Foo_bar".
func goNameFromPath(path cue.Path, defsOnly bool) string {
	export := true
	var sb strings.Builder
	for i, sel := range path.Selectors() {
		if defsOnly && !sel.IsDefinition() {
			return ""
		}
		if i > 0 {
			// To aid in readability, nested names are separated with underscores.
			sb.WriteString("_")
		}
		str := sel.String()
		str, hidden := strings.CutPrefix(str, "_")
		if hidden {
			// If any part of the path is hidden, we are not exporting.
			export = false
		}
		// Leading or trailing characters for definitions, optional, or required
		// are not included as part of Go names.
		str = strings.TrimPrefix(str, "#")
		str = strings.TrimRight(str, "?!")
		sb.WriteString(str)
	}
	name := sb.String()
	if export {
		name = strings.Title(name)
	}
	return name
}

// emitTypeReference attempts to generate a CUE value as a Go type via a reference,
// either to a type in the same Go package, or to a type in an imported package.
func (g *generator) emitTypeReference(val cue.Value) (emitted bool) {
	// References to existing names, either from the same package or an imported package.
	root, path := val.ReferencePath()
	// TODO: surely there is a better way to check whether ReferencePath returned "no path",
	// such as a possible path.IsValid method?
	if len(path.Selectors()) == 0 {
		return false
	}
	inst := root.BuildInstance()
	// Go has no notion of qualified import paths; if a CUE file imports
	// "foo.com/bar:qualified", we import just "foo.com/bar" on the Go side.
	// TODO: deal with multiple packages existing in the same directory.
	unqualifiedPath := module.ParseImportPath(inst.ImportPath).Unqualified().String()

	var sb strings.Builder
	if root != g.pkgRoot {
		defer func() {
			if emitted {
				g.importedAs[inst.ImportPath] = unqualifiedPath
			}
		}()

		sb.WriteString(inst.PkgName)
		sb.WriteString(".")
	}

	// As a special case, some CUE standard library types are allowed as references
	// even though they aren't definitions.
	defsOnly := true
	switch fmt.Sprintf("%s.%s", unqualifiedPath, path) {
	case "time.Duration", "time.Time":
		defsOnly = false
	}

	name := goNameFromPath(path, defsOnly)
	if name == "" {
		return false // Not a path we are generating.
	}

	sb.WriteString(name)
	g.appendf("%s", sb.String())
	return true
}

// emitDocs generates the documentation comments attached to the following declaration.
func (g *generator) emitDocs(name string, groups []*ast.CommentGroup) {
	// TODO: place the comment group starting with `// $name ...` first.
	// TODO: ensure that the Go name is used in the godoc.
	for i, group := range groups {
		if i > 0 {
			g.appendf("//\n")
		}
		for _, line := range group.List {
			g.appendf("%s\n", line.Text)
		}
	}
}
