[!exec:curl] skip 'no curl command available'

exec cue cmd serve &

exec sleep 1

exec curl -X GET http://localhost:8082/test
stdout 'ack: using method GET'

exec curl -X GET http://localhost:8082/one/1/two/i/i
stdout 'ack: one/1 two/i/i'

exec curl -X GET http://localhost:8082/authz/alice
stdout 'true'

exec curl -X GET http://localhost:8082/authz/bob
stdout 'false'

exec curl -w '\n' -X GET http://localhost:8082/schema/api/vm?r=research
cmp stdout out/vm-research

exec curl -L 'http://localhost:8082/api/vm?u=alice' -H 'Content-Type: application/json' -d '{"os":"Linux","arch":"x86","mem":10000000000,"disk":20000000000,"access": {"public":true}}'
stdout 'OK'

exec curl -L 'http://localhost:8082/authz' -H 'Content-Type: application/json' -d '{"user":"alice"}'
stdout 'true'

exec curl -L 'http://localhost:8082/authz' -H 'Content-Type: application/json' -d '{"user":"bob"}'
stdout 'false'

stop

-- authz_tool.cue --
package vm

import "encoding/json"

#Authz: {
	user!: string

	authz: *false | bool

    authz: allow && !deny

    deny: *false | bool // default(false)
    allow: *false | bool  // default(true)

    if user == "alice" {
        allow: true
    }
}

// We have two kinds of authz endpoints: one that takes the user
// as part of the URL path, and one that takes a JSON body.
//
// The main purpose here is to show that requests can be routed based on their
// method type.
//
// This pattern constraint sets up the common aspects for both.
command: serve: [=~"^/authz"]: ServeJSON & {
	request: value: #Authz
	response: value: request.value.authz
}

// authz returns a boolean indicating whether the user is authorized.
// The user is specified as part of the URL path.
command: serve: "/authz/{user}": {
	method: "GET"
	request: value: user: request.pathValues.user
}

// authz returns a boolean indicating whether the user is authorized.
// The user is specified in the JSON body.
command: serve: "/authz": {
	method: "POST"
	request: value: json.Unmarshal(request.body)
}

-- api_tool.cue --
package vm

import (
	"encoding/json"
	"encoding/openapi"
)

//#Machine describes a virtual machine.
#Machine: {
	os:     "Windows" | "Linux" | "MacOS"
	arch:   "x86" | "arm64"
	mem:    int
	disk:   int
	access: {
		public: bool
	}
}

// MachineByRole defines different machine configurations that are allowed
// based on user role.
MachineByRole: {
	admin: #Machine

	// Interns are only afforded smaller machines.
	intern: #Machine&{
		mem:  <=4Gi
		disk: <=100G
	}

	research: #Machine&{
		// The research team cannot launch public-facing machines.
		access: public: false
		os: "Linux" | "Windows"
	}
	default: null
}

Membership: alice: "admin"
Membership: bob: "research"
Membership: taylor: "intern"

// This API gets the allowed VM configurations for a given user defined as
// OpenAPI. The user is specified as a query parameter.
// If no user is given, a generic OpenAPI schema for Machine is returned.
command: serve: "/schema/api/vm": {
	routing: method: "GET"

	// Define default for user query parameter.
	request: from: r: *[""] | [...string]

	let role = request.form.r[0]
	let X = [// select first
		if role != "" {
			config: {
				version: "3.0.0"
				info: title: "Machine for \(role)"
			}
			machine: MachineByRole[(*role | "default")]
		},
		{
			config: {
				version: "3.0.0"
				info: title: "Machine"
			}
			machine: #Machine
		}, // default
	][0]

	response: body: json.Indent(
		openapi.MarshalSchema(X.config, {#Machine: X.machine}), "", "  ")
}

// This API simulates creating a new VM for a given user, specified as a query
// parameter. The machine is requested in the JSON body. It is than checked
// that the user can actually use the machine.
command: serve: "/api/vm": {
	routing: method: "POST"

	// Further constrain user permissions.
	request: form: u: [string]

	let user = request.form.u[0]
	let role = Membership[user]

	// Validate the request to create a new VM against the VM schema.
	X: #Machine
	X: json.Unmarshal(request.body)
	X: MachineByRole[role]

	response: {
		header: "Content-Type": "application/json"

		result: "OK"
		body:   json.Marshal(result)
	}
}

-- server_tool.cue --
package vm

import (
	"encoding/json"
	"tool/http"
)

// Test serves as an endpoint for simple testing.
command: serve: "/test": http.Serve & {
	request: _
	response: body: "ack: using method \(request.method)"
}

// This endpoint demonstrates capture all path parameters.
command: serve: "/one/{one}/{two...}": http.Serve & {
	request: _
	response: body: "ack: one/\(request.pathValues.one) \(request.pathValues.two)"
}


// ServeJSON is a helper for endpoints that serve JSON.
ServeJSON: {
	response: {
		value: _
		body:  json.Marshal(value)
	}
}

// All our endpoints serve from the same address.
// We take the convention that the name of the "subcommand" is the path prefix.
command: serve: [Prefix=string]: http.Serve & {
	listenAddr: ":8082"
	routing: path: Prefix
}
-- out/vm-research --
{
  "openapi": "3.0.0",
  "info": {
    "title": "Machine for research"
  },
  "paths": {},
  "components": {
    "schemas": {
      "Machine": {
        "type": "object",
        "required": [
          "access",
          "arch",
          "disk",
          "mem",
          "os"
        ],
        "properties": {
          "access": {
            "type": "object",
            "properties": {
              "public": {
                "type": "boolean"
              }
            },
            "allOf": [
              {
                "required": [
                  "public"
                ]
              },
              {
                "required": [
                  "public"
                ]
              }
            ]
          },
          "arch": {
            "type": "string",
            "enum": [
              "x86",
              "arm64"
            ]
          },
          "disk": {
            "type": "integer"
          },
          "mem": {
            "type": "integer"
          },
          "os": {
            "type": "string",
            "enum": [
              "Linux",
              "Windows"
            ]
          }
        }
      }
    }
  }
}
