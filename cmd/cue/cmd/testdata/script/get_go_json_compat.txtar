# Check that the CUE generated by 'cue get go' is actually compatible
# with encoding and decoding values via Go's encoding/json package.

exec cue get go --local ./...
cmp decls/p_go_gen.cue decls/p_go_gen.cue.golden

# Marshal via Go's encoding/json and validate with the generated CUE schema.
exec go run ./marshal
cp stdout go_marshal.json
cmp go_marshal.json go_marshal.json.golden
exec cue vet go_marshal.json schema.cue

# Export from CUE and Unmarshal via Go's encoding/json.
exec cue export ./decls
cmp stdout cue_export.json.golden
stdin stdout
exec go run ./unmarshal

-- schema.cue --
package schema

import "mod.test/decls"

decls.#Root

-- go.mod --
module mod.test

go 1.21
-- cue.mod/module.cue --
module: "mod.test"
language: version: "v0.9.0"
-- decls/export.cue --
package decls

#Root & {
	Duration: #ValueSecond
}
-- go_marshal.json.golden --
{"Duration":3000000000}
-- cue_export.json.golden --
{
    "Duration": 3000000000
}
-- decls/p.go --
package decls

import "time"

type Root struct {
	Duration time.Duration
}

const ValueSecond = 3 * time.Second
-- decls/p_go_gen.cue.golden --
// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go mod.test/decls

package decls

#Root: {
	Duration: int @go(,time.Duration)
}

#ValueSecond: int & 3000000000
-- marshal/main.go --
package main

import (
	"encoding/json"
	"fmt"
	"log"

	"mod.test/decls"
)

func main() {
	r := decls.Root{Duration: decls.ValueSecond}
	data, err := json.Marshal(r)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("%s\n", data)
}
-- unmarshal/main.go --
package main

import (
	"encoding/json"
	"io"
	"os"
	"fmt"
	"log"

	"mod.test/decls"
)

func main() {
	data, err := io.ReadAll(os.Stdin)
	if err != nil {
		log.Fatal(err)
	}
	var r decls.Root
	if err := json.Unmarshal(data, &r); err != nil {
		log.Fatal(err)
	}
	fmt.Printf("%s\n", data)
}
