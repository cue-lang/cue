#name: disjunctions
#evalPartial
-- in.cue --
o1:  1 | 2 | 3
o2:  (1 | 2 | 3) & 1
o3:  2 & (1 | *2 | 3)
o4:  (1 | *2 | 3) & (1 | 2 | *3)
o5:  (1 | *2 | 3) & (3 | *2 | 1)
o6:  (1 | 2 | 3) & (3 | 1 | 2)
o7:  (1 | 2 | 3) & (2 | 3)
o8:  (1 | 2 | 3) & (3 | 2)
o9:  (2 | 3) & (1 | 2 | 3)
o10: (3 | 2) & (1 | *2 | 3)

m1: (1 | (*2 | 3)) & (>=2 & <=3)
m2: (1 | (*2 | 3)) & (2 | 3)
m3: (*1 | *(*2 | 3)) & (2 | 3)
m4: (2 | 3) & (*2 | 3)
m5: (*2 | 3) & (2 | 3)

// (*2 | 3) & (2 | 3)
// (2 | 3) & (*2 | 3)
// 2&(*2 | 3) | 3&(*2 | 3)
// (*1 | (*2 | 3)) & (2 | 3)
// *1& (2 | 3) | (*2 | 3)&(2 | 3)
// *2&(2 | 3) | 3&(2 | 3)

// (2 | 3)&(*1 | (*2 | 3))
// 2&(*1 | (*2 | 3)) | 3&(*1 | (*2 | 3))
// *1&2 | (*2 | 3)&2 | *1&3 | (*2 | 3)&3
// (*2 | 3)&2 | (*2 | 3)&3
// *2 | 3

// All errors are treated the same as per the unification model.
i1: [1, 2][3] | "c"
-- out/compile --
--- in.cue
{
  o1: (1|2|3)
  o2: ((1|2|3) & 1)
  o3: (2 & (1|*2|3))
  o4: ((1|*2|3) & (1|2|*3))
  o5: ((1|*2|3) & (3|*2|1))
  o6: ((1|2|3) & (3|1|2))
  o7: ((1|2|3) & (2|3))
  o8: ((1|2|3) & (3|2))
  o9: ((2|3) & (1|2|3))
  o10: ((3|2) & (1|*2|3))
  m1: ((1|(*2|3)) & (>=2 & <=3))
  m2: ((1|(*2|3)) & (2|3))
  m3: ((*1|*(*2|3)) & (2|3))
  m4: ((2|3) & (*2|3))
  m5: ((*2|3) & (2|3))
  i1: ([
    1,
    2,
  ][3]|"c")
}
-- out/eval --
(struct){
  o1: (int){ |((int){ 1 }, (int){ 2 }, (int){ 3 }) }
  o2: (int){ 1 }
  o3: (int){ 2 }
  o4: (int){ |((int){ 1 }, (int){ 2 }, (int){ 3 }) }
  o5: (int){ |(*(int){ 2 }, (int){ 1 }, (int){ 3 }) }
  o6: (int){ |((int){ 1 }, (int){ 2 }, (int){ 3 }) }
  o7: (int){ |((int){ 2 }, (int){ 3 }) }
  o8: (int){ |((int){ 2 }, (int){ 3 }) }
  o9: (int){ |((int){ 2 }, (int){ 3 }) }
  o10: (int){ |(*(int){ 2 }, (int){ 3 }) }
  m1: (int){ |(*(int){ 2 }, (int){ 3 }) }
  m2: (int){ |(*(int){ 2 }, (int){ 3 }) }
  m3: (int){ |(*(int){ 2 }, (int){ 3 }) }
  m4: (int){ |(*(int){ 2 }, (int){ 3 }) }
  m5: (int){ |(*(int){ 2 }, (int){ 3 }) }
  i1: (string){ "c" }
}
