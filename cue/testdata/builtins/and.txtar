-- in.cue --
merge: and([1, 1])

// ensure definitions along embedded scalars are preserved.
embed: and([{2, #x: 1}, {2, #x: 2}])

issue3719: {
    #openStruct: {...}
	_filledLater: #openStruct.foo

	// The comprehension below should work regardless of whether it's wrapped in "and".

	withoutAnd: {
		for k, v in _filledLater.bar {
			(k): v
		}
	}
	withAnd: and([
		for k, v in _filledLater.bar {
			(k): v
		}
	])
}
-- out/eval/stats --
Leaks:  2
Freed:  4
Reused: 1
Allocs: 5
Retain: 2

Unifications: 6
Conjuncts:    13
Disjuncts:    6
-- out/evalalpha --
Errors:
embed.#x: conflicting values 2 and 1:
    ./in.cue:4:13
    ./in.cue:4:21
    ./in.cue:4:25
    ./in.cue:4:33

Result:
(_|_){
  // [eval]
  merge: (int){ 1 }
  embed: (_|_){
    // [eval]
    #x: (_|_){
      // [eval] embed.#x: conflicting values 2 and 1:
      //     ./in.cue:4:13
      //     ./in.cue:4:21
      //     ./in.cue:4:25
      //     ./in.cue:4:33
    }
  }
  issue3719: (struct){
    #openStruct: (#struct){
    }
    _filledLater: (_|_){
      // [incomplete] issue3719._filledLater: undefined field: foo:
      //     ./in.cue:8:28
    }
    withoutAnd: (_|_){
      // [incomplete] issue3719._filledLater: undefined field: foo:
      //     ./in.cue:8:28
    }
    withAnd: (_|_){
      // [incomplete] issue3719._filledLater: undefined field: foo:
      //     ./in.cue:8:28
    }
  }
}
-- diff/-out/evalalpha<==>+out/eval --
diff old new
--- old
+++ new
@@ -1,6 +1,8 @@
 Errors:
 embed.#x: conflicting values 2 and 1:
+    ./in.cue:4:13
     ./in.cue:4:21
+    ./in.cue:4:25
     ./in.cue:4:33
 
 Result:
@@ -11,8 +13,26 @@
     // [eval]
     #x: (_|_){
       // [eval] embed.#x: conflicting values 2 and 1:
+      //     ./in.cue:4:13
       //     ./in.cue:4:21
+      //     ./in.cue:4:25
       //     ./in.cue:4:33
     }
   }
+  issue3719: (struct){
+    #openStruct: (#struct){
+    }
+    _filledLater: (_|_){
+      // [incomplete] issue3719._filledLater: undefined field: foo:
+      //     ./in.cue:8:28
+    }
+    withoutAnd: (_|_){
+      // [incomplete] issue3719._filledLater: undefined field: foo:
+      //     ./in.cue:8:28
+    }
+    withAnd: (_|_){
+      // [incomplete] issue3719._filledLater: undefined field: foo:
+      //     ./in.cue:8:28
+    }
+  }
 }
-- out/eval --
Errors:
embed.#x: conflicting values 2 and 1:
    ./in.cue:4:21
    ./in.cue:4:33

Result:
(_|_){
  // [eval]
  merge: (int){ 1 }
  embed: (_|_){
    // [eval]
    #x: (_|_){
      // [eval] embed.#x: conflicting values 2 and 1:
      //     ./in.cue:4:21
      //     ./in.cue:4:33
    }
  }
}
-- out/compile --
--- in.cue
{
  merge: and([
    1,
    1,
  ])
  embed: and([
    {
      2
      #x: 1
    },
    {
      2
      #x: 2
    },
  ])
  issue3719: {
    #openStruct: {
      ...
    }
    _filledLater: 〈0;#openStruct〉.foo
    withoutAnd: {
      for k, v in 〈1;_filledLater〉.bar {
        〈1;k〉: 〈1;v〉
      }
    }
    withAnd: and([
      for k, v in 〈1;_filledLater〉.bar {
        〈1;k〉: 〈1;v〉
      },
    ])
  }
}
