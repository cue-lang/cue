-- in.cue --
import "math"

#Foo: {
	a: int
}

match: {
	[=~"^single"]: matchN(1, [#Foo])
	singleOK: a: 2
	singleErr: a: "foo"

	[=~"^incomplete"]: matchN(1, [#Foo])
	incompleteOK: a: int
	incompleteErr: a: string

	#A: {
		a: int
		b: _
		...
	}

	defaults: {
		// Because validators distribute over disjunctions, this validator may erase
		// a default value. Nonethenless, it will be guaranteed that the value
		// resulting from evaluation does not violate the validator.
		// TODO(defaults): take this use case into consideration for the defaults
		// rethink, as it seems less than ideal. Note that this typically not an
		// issue if the schema matched against is not concrete.
		[=~"^pickTop"]: matchN(1, [2])
		pickTopOK1: *2 | int
		pickTopOK2: int
		pickTopErr: *3 | int // Final values taken.

		// Nested default values will be evaluated and may not be overridden by
		// values in the validator.
		[=~"^pickNested1"]: matchN(1, [{a: 2}])
		pickNested1OK1: a: *2 | int
		pickNested1OK2: a: int
		pickNested1Err: a: *3 | int

		[=~"^pickNested2"]: matchN(1, [{a: <=2}])
		pickNested2OK1: a: *2 | int
		pickNested2OK2: a: int
		pickNested2Err: a: *3 | int
	}

	// Stress test potential exponential behavior.
	nestedOK: {
		matchN(4, [#A, #A, #A, #A])

		a: 2
		b: {
			matchN(4, [#A, #A, #A, #A])
	
			a: 3
			b: matchN(4, [#A, #A, #A, #A])
			b: a: 4
			c: matchN(4, [#A, #A, #A, #A])
			c: a: 5
		}
		c: {
			matchN(4, [#A, #A, #A, #A])
	
			a: 3
			b: matchN(4, [#A, #A, #A, #A])
			b: a: 4
			c: matchN(4, [#A, #A, #A, #A])
			c: a: 5
		}
	}
}

not: {
	[=~"^single"]: matchN(0, [#Foo])
	singleOK: a: "foo"
	singleErr: a: 2

	[=~"^double"]: matchN(0, [matchN(0, [#Foo])])
	doubleOK: a: 2
	doubleErr: a: "foo"
}

oneOf: {
	[=~"^multiple1"]: matchN(1, [math.MultipleOf(3), math.MultipleOf(5)])

	multiple1Err1: 1

	multiple1OK1: 3
	multiple1OK2: 5

	multiple1Err2: 15
}

anyOf: {
	[=~"^multiple1"]: matchN(>0, [math.MultipleOf(3), math.MultipleOf(5)])

	multiple1Err1: 1

	multiple1OK1: 3
	multiple1OK2: 5
	multiple1OK3: 15
}


allOf: {
	[=~"^multiple1"]: matchN(2, [math.MultipleOf(3), math.MultipleOf(5)])

	multiple1Err1: 1
	multiple1Err2: 3
	multiple1Err3: 5

	multiple1OK1: 15
}

bare: {
	embed: t1: {
		a: {matchN(1, [>10])}
		b: {a}
	}
	embed: t2: {
		b: {a}
		a: {matchN(1, [>10])}
	}
	direct: t1: {
		a: matchN(1, [>10])
		b: a
	}
	direct: t2: {
		b: a
		a: matchN(1, [>10])
	}
}

required: {
	ok1: {
		x: matchN(0, [{foo!: string}])
		x: bar: 2
	}
	ok2: {
		x: matchN(0, [{foo!: string}])
	}
	// not matching for different reasons
	ok3: {
		x: matchN(0, [{bar!: string}])
		x: bar: 2
	}
}

// A struct with extra fields should match whether or not inside a list.
// evalv2 would get this wrong but evalv3 got it right.
issue3575: {
	test1: {
		#x: matchN(1, [
			[{}],
		])
		x: #x
		x: [{a: 1}]
	}
	test2: {
		#x: matchN(1, [
			{},
		])
		x: #x
		x: {a: 1}
	}
}

-- incomplete.cue --
import "math"

// The errors in this section should be "incomplete" errors.
incomplete: {
	// foo could still be provided later.
	incomplete1: {
		x: matchN(1, [{foo!: string}])
		x: bar: 2
	}
	// foo could still be provided later.
	incomplete2: {
		x: matchN(1, [{foo!: string}])
	}
	// in case of doubt, we should mark an error as incomplete to be safe.
	incomplete3: {
		x: matchN(math.MultipleOf(2), [{bar!: int}, {foo!: int}])
		x: bar: 2
	}
	incomplete4: {
		x: matchN(math.MultipleOf(2), [{bar!: int}, {foo!: int}, {baz!: int}])
		x: bar: 2
	}
	incomplete5: {
		x: matchN(>1 & <=3, [{bar!: int}, {foo!: int}, {baz!: int}])
		x: bar: 2
	}
	incomplete6: {
		x: matchN(2|3, [{bar!: int}, {foo!: int}, {baz!: int}])
		x: bar: 2
	}

	// incorrect type cannot be corrected
	err1: {
		x: matchN(1, [{bar!: string}])
		x: bar: 2
	}
	// additional incomplete matches should not be counted if they can otherwise
	// not satisfy the constraint.
	err2: {
		x: matchN(0, [{bar!: int}, {foo!: int}])
		x: bar: 2
	}
	// additional incomplete matches should not be counted if they can otherwise
	// not satisfy the constraint.
	err3: {
		x: matchN(2, [{bar!: string}, {foo!: string}])
		x: bar: 2
	}
	// one additional potential match cannot make up to satisfy the bound.
	err4: {
		x: matchN(>1, [{bar!: string}, {foo!: string}])
		x: bar: 2
	}
	err5: {
		x: matchN(<1, [{bar!: int}, {foo!: int}])
		x: bar: 2
	}
}
issue3389: {
	// only report schema errors that are of a lesser severity.
	x: bar: 2
	x: matchN(1, [{bar: 3}, {bar: 2, foo!: int}])
}
-- closedness.cue --
ellipsis: ok: {
	out: #Schema & {
		field: shouldBeAllowed: 123
	}
	#Schema: {
		field?: #anything
		#anything: matchN(1, [{ ... }])
	}
}
// Arguments to function are not closed by enclosing definition.
openArguments: ok1: {
	#Schema: {{
		a: matchN(1, ["all", {foo: "bar"}])
	}}
	out: #Schema & {
		a: baz: "allowed"
	}
}
openArguments: err2: {
	#Schema: {{
        a?: matchN(1, [ //fails
				null, // fail
				{ [string]: string }, // pass
				{b: {...}}, // pass
			])
	}}
	out: #Schema & {
		a: allowed: "once"
	}
}
explicitClose: err1: {
	#Schema: {{
		a: matchN(1, ["all", close({foo: "bar"})])
	}}
	out: #Schema & {
		a: baz: "notAllowed"
	}
}
explicitClose: ok2: {
	#Schema: {{
        a?: matchN(1, [
				null, // fail
				close({ [string]: string }), // pass
				close({b: {...}}), // fail
			])
	}}
	out: #Schema & {
		a: allowed: "once"
	}
}
mixed: ok3: {
	#Schema: {
		exports?: matchN(1, [
			close({ never?: _ }), // fail
			#exportsObject,       // pass
		])

		#exports: matchN(1, [string, #exportsObject])
		#exportsObject: exp1?: #exports
	}

	out: #Schema & {
		exports: exp1: "./main-module.js"
	}
}

closedByDefinition: ok4: {
	#Schema: {
		exports?: matchN(1, [string, #exportsObject])
		#exports: matchN(1, [string, #exportsObject])
		#exportsObject: exp1?: #exports
	}

	out: #Schema & {
		exports: exp1: "./main-module.js"
	}
}
closedByDefinition: err5: {
	#Schema: {
		exports?: matchN(1, [null, #exportsObject])
		#exports: matchN(1, [null, #exportsObject])
		#exportsObject: exp1?: #exports
	}

	out: #Schema & {
		exports: exp1: "./main-module.js"
	}
}
-- issue3694.cue --
issue3694: full: {
	#step: matchN(1, [{
		uses!: _
		...
	}, {
		run!: _
		...
	}])
	#step: close({
		uses?: string
		run?:  string
	})

	s: #step & {
		run: "echo hello world"
	}
}
issue3694: simple: {
	#step: matchN(1, [{
		uses!: _
	}])
	#step: close({
		uses?: string
	})
}
-- out/evalalpha/stats --
Leaks:  129
Freed:  1059
Reused: 1029
Allocs: 159
Retain: 0

Unifications: 971
Conjuncts:    1551
Disjuncts:    16

NumCloseIDs: 483
-- out/eval/stats --
Leaks:  52
Freed:  951
Reused: 944
Allocs: 59
Retain: 129

Unifications: 987
Conjuncts:    1635
Disjuncts:    1081
-- out/eval --
Errors:
closedByDefinition.err5.out.exports: conflicting values null and {exp1:"./main-module.js"} (mismatched types null and struct):
    ./closedness.cue:80:13
    ./closedness.cue:80:24
    ./closedness.cue:85:7
    ./closedness.cue:86:12
closedByDefinition.err5.out.exports.exp1: conflicting values "./main-module.js" and null (mismatched types string and null):
    ./closedness.cue:80:30
    ./closedness.cue:81:24
    ./closedness.cue:82:26
    ./closedness.cue:85:7
    ./closedness.cue:86:18
closedByDefinition.err5.out.exports.exp1: conflicting values "./main-module.js" and {exp1?:#exports} (mismatched types string and struct):
    ./closedness.cue:80:30
    ./closedness.cue:81:30
    ./closedness.cue:82:19
    ./closedness.cue:82:26
    ./closedness.cue:85:7
    ./closedness.cue:86:18
explicitClose.err1.out.a: conflicting values "all" and {baz:"notAllowed"} (mismatched types string and struct):
    ./closedness.cue:32:11
    ./closedness.cue:32:12
    ./closedness.cue:33:6
    ./closedness.cue:33:17
    ./closedness.cue:35:7
    ./closedness.cue:36:6
incomplete.err1.x.bar: conflicting values 2 and string (mismatched types int and string):
    ./incomplete.cue:34:24
    ./incomplete.cue:35:11
incomplete.err3.x.bar: conflicting values 2 and string (mismatched types int and string):
    ./incomplete.cue:46:24
    ./incomplete.cue:47:11
incomplete.err4.x.bar: conflicting values 2 and string (mismatched types int and string):
    ./incomplete.cue:51:25
    ./incomplete.cue:52:11
match.defaults.pickNested1Err.a: conflicting values 2 and 3:
    ./in.cue:36:38
    ./in.cue:39:23
match.incompleteErr.a: conflicting values string and int (mismatched types string and int):
    ./in.cue:4:5
    ./in.cue:12:32
    ./in.cue:14:20
match.singleErr.a: conflicting values "foo" and int (mismatched types string and int):
    ./in.cue:4:5
    ./in.cue:8:28
    ./in.cue:10:16
openArguments.err2.out.a: conflicting values null and {allowed:"once"} (mismatched types null and struct):
    ./closedness.cue:20:11
    ./closedness.cue:20:12
    ./closedness.cue:21:13
    ./closedness.cue:22:5
    ./closedness.cue:27:7
    ./closedness.cue:28:6
openArguments.err2.out.a: invalid value {allowed:"once"} (does not satisfy matchN): 2 matched, expected 1:
    ./closedness.cue:21:13
    ./closedness.cue:21:20
    ./closedness.cue:28:6
explicitClose.err1.out.a: invalid value {baz:"notAllowed"} (does not satisfy matchN): 0 matched, expected 1:
    ./closedness.cue:33:6
    ./closedness.cue:33:13
    ./closedness.cue:36:6
explicitClose.err1.out.a.baz: field not allowed:
    ./closedness.cue:33:6
    ./closedness.cue:32:12
    ./closedness.cue:33:24
    ./closedness.cue:33:30
    ./closedness.cue:35:7
    ./closedness.cue:36:11
closedByDefinition.err5.out.exports: invalid value {exp1:"./main-module.js"} (does not satisfy matchN): 0 matched, expected 1:
    ./closedness.cue:80:13
    ./closedness.cue:80:20
    ./closedness.cue:86:12
closedByDefinition.err5.out.exports.exp1: invalid value "./main-module.js" (does not satisfy matchN): 0 matched, expected 1:
    ./closedness.cue:81:13
    ./closedness.cue:81:20
    ./closedness.cue:82:26
    ./closedness.cue:86:18
match.singleErr: invalid value {a:"foo"} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:8:17
    ./in.cue:8:24
    ./in.cue:10:13
match.incompleteErr: invalid value {a:string} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:12:21
    ./in.cue:12:28
    ./in.cue:14:17
match.defaults.pickNested1Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:36:23
    ./in.cue:36:30
    ./in.cue:39:19
match.defaults.pickNested2Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:41:23
    ./in.cue:41:30
    ./in.cue:44:19
match.defaults.pickNested2Err.a: invalid value 3 (out of bound <=2):
    ./in.cue:41:38
    ./in.cue:44:23
not.singleErr: invalid value {a:2} (does not satisfy matchN): 1 matched, expected 0:
    ./in.cue:74:17
    ./in.cue:74:24
    ./in.cue:76:13
not.doubleErr: invalid value {a:"foo"} (does not satisfy matchN): 1 matched, expected 0:
    ./in.cue:78:17
    ./in.cue:78:24
    ./in.cue:80:13
oneOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:84:20
    ./in.cue:84:27
    ./in.cue:86:17
oneOf.multiple1Err2: invalid value 15 (does not satisfy matchN): 2 matched, expected 1:
    ./in.cue:84:20
    ./in.cue:84:27
    ./in.cue:91:17
oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
    ./in.cue:84:31
    ./in.cue:84:20
    ./in.cue:84:47
    ./in.cue:86:17
oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
    ./in.cue:84:51
    ./in.cue:84:20
    ./in.cue:84:67
    ./in.cue:86:17
anyOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected >0:
    ./in.cue:95:20
    ./in.cue:95:27
    ./in.cue:97:17
anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
    ./in.cue:95:32
    ./in.cue:95:20
    ./in.cue:95:48
    ./in.cue:97:17
anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
    ./in.cue:95:52
    ./in.cue:95:20
    ./in.cue:95:68
    ./in.cue:97:17
allOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 2:
    ./in.cue:106:20
    ./in.cue:106:27
    ./in.cue:108:17
allOf.multiple1Err2: invalid value 3 (does not satisfy matchN): 1 matched, expected 2:
    ./in.cue:106:20
    ./in.cue:106:27
    ./in.cue:109:17
allOf.multiple1Err3: invalid value 5 (does not satisfy matchN): 1 matched, expected 2:
    ./in.cue:106:20
    ./in.cue:106:27
    ./in.cue:110:17
allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
    ./in.cue:106:31
    ./in.cue:106:20
    ./in.cue:106:47
    ./in.cue:108:17
allOf.multiple1Err3: invalid value 5 (does not satisfy math.MultipleOf(3)):
    ./in.cue:106:31
    ./in.cue:106:20
    ./in.cue:106:47
    ./in.cue:110:17
allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
    ./in.cue:106:51
    ./in.cue:106:20
    ./in.cue:106:67
    ./in.cue:108:17
allOf.multiple1Err2: invalid value 3 (does not satisfy math.MultipleOf(5)):
    ./in.cue:106:51
    ./in.cue:106:20
    ./in.cue:106:67
    ./in.cue:109:17
incomplete.err1.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
    ./incomplete.cue:34:6
    ./incomplete.cue:34:13
    ./incomplete.cue:35:6
incomplete.err2.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected 0:
    ./incomplete.cue:40:6
    ./incomplete.cue:40:13
    ./incomplete.cue:41:6
incomplete.err3.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 2:
    ./incomplete.cue:46:6
    ./incomplete.cue:46:13
    ./incomplete.cue:47:6
incomplete.err4.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected >1:
    ./incomplete.cue:51:6
    ./incomplete.cue:51:13
    ./incomplete.cue:52:6
incomplete.err5.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected <1:
    ./incomplete.cue:55:6
    ./incomplete.cue:55:13
    ./incomplete.cue:56:6

Result:
(_|_){
  // [eval]
  ellipsis: (struct){
    ok: (struct){
      out: (#struct){
        field: (#struct){
          shouldBeAllowed: (int){ 123 }
        }
        #anything: (_){ matchN(1, (#list){
            0: (_|_){// {
              //   ...
              // }
            }
          }) }
      }
      #Schema: (#struct){
        field?: (_){ matchN(1, (#list){
            0: (_|_){// {
              //   ...
              // }
            }
          }) }
        #anything: (_){ matchN(1, (#list){
            0: (_|_){// {
              //   ...
              // }
            }
          }) }
      }
    }
  }
  openArguments: (_|_){
    // [eval]
    ok1: (struct){
      #Schema: (#struct){
        a: (_){ matchN(1, (#list){
            0: (_|_){// "all"
            }
            1: (_|_){// {
              //   foo: "bar"
              // }
            }
          }) }
      }
      out: (#struct){
        a: (#struct){
          baz: (string){ "allowed" }
        }
      }
    }
    err2: (_|_){
      // [eval]
      #Schema: (#struct){
        a?: (_){ matchN(1, (#list){
            0: (_|_){// null
            }
            1: (_|_){// {
              //   [string]: string
              // }
            }
            2: (_|_){// {
              //   b: {
              //     ...
              //   }
              // }
            }
          }) }
      }
      out: (_|_){
        // [eval]
        a: (_|_){
          // [eval] openArguments.err2.out.a: conflicting values null and {allowed:"once"} (mismatched types null and struct):
          //     ./closedness.cue:20:11
          //     ./closedness.cue:20:12
          //     ./closedness.cue:21:13
          //     ./closedness.cue:22:5
          //     ./closedness.cue:27:7
          //     ./closedness.cue:28:6
          // openArguments.err2.out.a: invalid value {allowed:"once"} (does not satisfy matchN): 2 matched, expected 1:
          //     ./closedness.cue:21:13
          //     ./closedness.cue:21:20
          //     ./closedness.cue:28:6
          allowed: (string){ "once" }
        }
      }
    }
  }
  explicitClose: (_|_){
    // [eval]
    err1: (_|_){
      // [eval]
      #Schema: (#struct){
        a: (_){ matchN(1, (#list){
            0: (_|_){// "all"
            }
            1: (_|_){// close({
              //   foo: "bar"
              // })
            }
          }) }
      }
      out: (_|_){
        // [eval]
        a: (_|_){
          // [eval] explicitClose.err1.out.a: conflicting values "all" and {baz:"notAllowed"} (mismatched types string and struct):
          //     ./closedness.cue:32:11
          //     ./closedness.cue:32:12
          //     ./closedness.cue:33:6
          //     ./closedness.cue:33:17
          //     ./closedness.cue:35:7
          //     ./closedness.cue:36:6
          // explicitClose.err1.out.a: invalid value {baz:"notAllowed"} (does not satisfy matchN): 0 matched, expected 1:
          //     ./closedness.cue:33:6
          //     ./closedness.cue:33:13
          //     ./closedness.cue:36:6
          // explicitClose.err1.out.a.baz: field not allowed:
          //     ./closedness.cue:33:6
          //     ./closedness.cue:36:11
          baz: (string){ "notAllowed" }
        }
      }
    }
    ok2: (struct){
      #Schema: (#struct){
        a?: (_){ matchN(1, (#list){
            0: (_|_){// null
            }
            1: (_|_){// close({
              //   [string]: string
              // })
            }
            2: (_|_){// close({
              //   b: {
              //     ...
              //   }
              // })
            }
          }) }
      }
      out: (#struct){
        a: (#struct){
          allowed: (string){ "once" }
        }
      }
    }
  }
  mixed: (struct){
    ok3: (struct){
      #Schema: (#struct){
        exports?: (_){ matchN(1, (#list){
            0: (_|_){// close({
              //   never?: _
              // })
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exports: (_){ matchN(1, (#list){
            0: (_|_){// string
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exportsObject: (#struct){
          exp1?: (_){ matchN(1, (#list){
              0: (_|_){// string
              }
              1: (_|_){// 〈1;#exportsObject〉
              }
            }) }
        }
      }
      out: (#struct){
        exports: (#struct){
          exp1: (string){ "./main-module.js" }
        }
        #exports: (_){ matchN(1, (#list){
            0: (_|_){// string
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exportsObject: (#struct){
          exp1?: (_){ matchN(1, (#list){
              0: (_|_){// string
              }
              1: (_|_){// 〈1;#exportsObject〉
              }
            }) }
        }
      }
    }
  }
  closedByDefinition: (_|_){
    // [eval]
    ok4: (struct){
      #Schema: (#struct){
        exports?: (_){ matchN(1, (#list){
            0: (_|_){// string
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exports: (_){ matchN(1, (#list){
            0: (_|_){// string
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exportsObject: (#struct){
          exp1?: (_){ matchN(1, (#list){
              0: (_|_){// string
              }
              1: (_|_){// 〈1;#exportsObject〉
              }
            }) }
        }
      }
      out: (#struct){
        exports: (#struct){
          exp1: (string){ "./main-module.js" }
        }
        #exports: (_){ matchN(1, (#list){
            0: (_|_){// string
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exportsObject: (#struct){
          exp1?: (_){ matchN(1, (#list){
              0: (_|_){// string
              }
              1: (_|_){// 〈1;#exportsObject〉
              }
            }) }
        }
      }
    }
    err5: (_|_){
      // [eval]
      #Schema: (#struct){
        exports?: (_){ matchN(1, (#list){
            0: (_|_){// null
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exports: (_){ matchN(1, (#list){
            0: (_|_){// null
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exportsObject: (#struct){
          exp1?: (_){ matchN(1, (#list){
              0: (_|_){// null
              }
              1: (_|_){// 〈1;#exportsObject〉
              }
            }) }
        }
      }
      out: (_|_){
        // [eval]
        exports: (_|_){
          // [eval] closedByDefinition.err5.out.exports: conflicting values null and {exp1:"./main-module.js"} (mismatched types null and struct):
          //     ./closedness.cue:80:13
          //     ./closedness.cue:80:24
          //     ./closedness.cue:85:7
          //     ./closedness.cue:86:12
          // closedByDefinition.err5.out.exports.exp1: conflicting values "./main-module.js" and null (mismatched types string and null):
          //     ./closedness.cue:80:30
          //     ./closedness.cue:81:24
          //     ./closedness.cue:82:26
          //     ./closedness.cue:85:7
          //     ./closedness.cue:86:18
          // closedByDefinition.err5.out.exports.exp1: conflicting values "./main-module.js" and {exp1?:#exports} (mismatched types string and struct):
          //     ./closedness.cue:80:30
          //     ./closedness.cue:81:30
          //     ./closedness.cue:82:19
          //     ./closedness.cue:82:26
          //     ./closedness.cue:85:7
          //     ./closedness.cue:86:18
          // closedByDefinition.err5.out.exports: invalid value {exp1:"./main-module.js"} (does not satisfy matchN): 0 matched, expected 1:
          //     ./closedness.cue:80:13
          //     ./closedness.cue:80:20
          //     ./closedness.cue:86:12
          // closedByDefinition.err5.out.exports.exp1: invalid value "./main-module.js" (does not satisfy matchN): 0 matched, expected 1:
          //     ./closedness.cue:81:13
          //     ./closedness.cue:81:20
          //     ./closedness.cue:82:26
          //     ./closedness.cue:86:18
          exp1: (string){ "./main-module.js" }
        }
        #exports: (_){ matchN(1, (#list){
            0: (_|_){// null
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exportsObject: (#struct){
          exp1?: (_){ matchN(1, (#list){
              0: (_|_){// null
              }
              1: (_|_){// 〈1;#exportsObject〉
              }
            }) }
        }
      }
    }
  }
  #Foo: (#struct){
    a: (int){ int }
  }
  match: (_|_){
    // [eval]
    singleOK: (struct){
      a: (int){ 2 }
    }
    singleErr: (_|_){
      // [eval] match.singleErr.a: conflicting values "foo" and int (mismatched types string and int):
      //     ./in.cue:4:5
      //     ./in.cue:8:28
      //     ./in.cue:10:16
      // match.singleErr: invalid value {a:"foo"} (does not satisfy matchN): 0 matched, expected 1:
      //     ./in.cue:8:17
      //     ./in.cue:8:24
      //     ./in.cue:10:13
      a: (string){ "foo" }
    }
    incompleteOK: (struct){
      a: (int){ int }
    }
    incompleteErr: (_|_){
      // [eval] match.incompleteErr.a: conflicting values string and int (mismatched types string and int):
      //     ./in.cue:4:5
      //     ./in.cue:12:32
      //     ./in.cue:14:20
      // match.incompleteErr: invalid value {a:string} (does not satisfy matchN): 0 matched, expected 1:
      //     ./in.cue:12:21
      //     ./in.cue:12:28
      //     ./in.cue:14:17
      a: (string){ string }
    }
    #A: (#struct){
      a: (int){ int }
      b: (_){ _ }
    }
    defaults: (_|_){
      // [eval]
      pickTopOK1: (int){ |(*(int){ 2 }, (int){ &(matchN(1, (#list){
            0: (int){ 2 }
          }), int) }) }
      pickTopOK2: (int){ &(matchN(1, (#list){
          0: (_|_){// 2
          }
        }), int) }
      pickTopErr: (int){ &(matchN(1, (#list){
          0: (int){ 2 }
        }), int) }
      pickNested1OK1: (struct){
        a: (int){ |(*(int){ 2 }, (int){ int }) }
      }
      pickNested1OK2: (struct){
        a: (int){ int }
      }
      pickNested1Err: (_|_){
        // [eval] match.defaults.pickNested1Err.a: conflicting values 2 and 3:
        //     ./in.cue:36:38
        //     ./in.cue:39:23
        // match.defaults.pickNested1Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
        //     ./in.cue:36:23
        //     ./in.cue:36:30
        //     ./in.cue:39:19
        a: (int){ |(*(int){ 3 }, (int){ int }) }
      }
      pickNested2OK1: (struct){
        a: (int){ |(*(int){ 2 }, (int){ int }) }
      }
      pickNested2OK2: (struct){
        a: (int){ int }
      }
      pickNested2Err: (_|_){
        // [eval] match.defaults.pickNested2Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
        //     ./in.cue:41:23
        //     ./in.cue:41:30
        //     ./in.cue:44:19
        // match.defaults.pickNested2Err.a: invalid value 3 (out of bound <=2):
        //     ./in.cue:41:38
        //     ./in.cue:44:23
        a: (int){ |(*(int){ 3 }, (int){ int }) }
      }
    }
    nestedOK: (struct){
      a: (int){ 2 }
      b: (struct){
        a: (int){ 3 }
        b: (struct){
          a: (int){ 4 }
        }
        c: (struct){
          a: (int){ 5 }
        }
      }
      c: (struct){
        a: (int){ 3 }
        b: (struct){
          a: (int){ 4 }
        }
        c: (struct){
          a: (int){ 5 }
        }
      }
    }
  }
  not: (_|_){
    // [eval]
    singleOK: (struct){
      a: (string){ "foo" }
    }
    singleErr: (_|_){
      // [eval] not.singleErr: invalid value {a:2} (does not satisfy matchN): 1 matched, expected 0:
      //     ./in.cue:74:17
      //     ./in.cue:74:24
      //     ./in.cue:76:13
      a: (int){ 2 }
    }
    doubleOK: (struct){
      a: (int){ 2 }
    }
    doubleErr: (_|_){
      // [eval] not.doubleErr: invalid value {a:"foo"} (does not satisfy matchN): 1 matched, expected 0:
      //     ./in.cue:78:17
      //     ./in.cue:78:24
      //     ./in.cue:80:13
      a: (string){ "foo" }
    }
  }
  oneOf: (_|_){
    // [eval]
    multiple1Err1: (_|_){
      // [eval] oneOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 1:
      //     ./in.cue:84:20
      //     ./in.cue:84:27
      //     ./in.cue:86:17
      // oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:84:31
      //     ./in.cue:84:20
      //     ./in.cue:84:47
      //     ./in.cue:86:17
      // oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:84:51
      //     ./in.cue:84:20
      //     ./in.cue:84:67
      //     ./in.cue:86:17
    }
    multiple1OK1: (int){ 3 }
    multiple1OK2: (int){ 5 }
    multiple1Err2: (_|_){
      // [eval] oneOf.multiple1Err2: invalid value 15 (does not satisfy matchN): 2 matched, expected 1:
      //     ./in.cue:84:20
      //     ./in.cue:84:27
      //     ./in.cue:91:17
    }
  }
  anyOf: (_|_){
    // [eval]
    multiple1Err1: (_|_){
      // [eval] anyOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected >0:
      //     ./in.cue:95:20
      //     ./in.cue:95:27
      //     ./in.cue:97:17
      // anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:95:32
      //     ./in.cue:95:20
      //     ./in.cue:95:48
      //     ./in.cue:97:17
      // anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:95:52
      //     ./in.cue:95:20
      //     ./in.cue:95:68
      //     ./in.cue:97:17
    }
    multiple1OK1: (int){ 3 }
    multiple1OK2: (int){ 5 }
    multiple1OK3: (int){ 15 }
  }
  allOf: (_|_){
    // [eval]
    multiple1Err1: (_|_){
      // [eval] allOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 2:
      //     ./in.cue:106:20
      //     ./in.cue:106:27
      //     ./in.cue:108:17
      // allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:106:31
      //     ./in.cue:106:20
      //     ./in.cue:106:47
      //     ./in.cue:108:17
      // allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:106:51
      //     ./in.cue:106:20
      //     ./in.cue:106:67
      //     ./in.cue:108:17
    }
    multiple1Err2: (_|_){
      // [eval] allOf.multiple1Err2: invalid value 3 (does not satisfy matchN): 1 matched, expected 2:
      //     ./in.cue:106:20
      //     ./in.cue:106:27
      //     ./in.cue:109:17
      // allOf.multiple1Err2: invalid value 3 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:106:51
      //     ./in.cue:106:20
      //     ./in.cue:106:67
      //     ./in.cue:109:17
    }
    multiple1Err3: (_|_){
      // [eval] allOf.multiple1Err3: invalid value 5 (does not satisfy matchN): 1 matched, expected 2:
      //     ./in.cue:106:20
      //     ./in.cue:106:27
      //     ./in.cue:110:17
      // allOf.multiple1Err3: invalid value 5 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:106:31
      //     ./in.cue:106:20
      //     ./in.cue:106:47
      //     ./in.cue:110:17
    }
    multiple1OK1: (int){ 15 }
  }
  bare: (struct){
    embed: (struct){
      t1: (struct){
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
      t2: (struct){
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
    }
    direct: (struct){
      t1: (struct){
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
      t2: (struct){
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
    }
  }
  required: (struct){
    ok1: (struct){
      x: (struct){
        bar: (int){ 2 }
      }
    }
    ok2: (struct){
      x: (_){ matchN(0, (#list){
          0: (_|_){// {
            //   foo!: string
            // }
          }
        }) }
    }
    ok3: (struct){
      x: (struct){
        bar: (int){ 2 }
      }
    }
  }
  issue3575: (struct){
    test1: (struct){
      #x: (_){ matchN(1, (#list){
          0: (_|_){// [
            //   {},
            // ]
          }
        }) }
      x: (#list){
        0: (struct){
          a: (int){ 1 }
        }
      }
    }
    test2: (struct){
      #x: (_){ matchN(1, (#list){
          0: (_|_){// {}
          }
        }) }
      x: (#struct){
        a: (int){ 1 }
      }
    }
  }
  incomplete: (_|_){
    // [eval]
    incomplete1: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete1.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
        //     ./incomplete.cue:7:6
        //     ./incomplete.cue:7:13
        //     ./incomplete.cue:8:6
        // incomplete.incomplete1.x.foo: field is required but not present:
        //     ./incomplete.cue:7:6
        //     ./incomplete.cue:7:18
        bar: (int){ 2 }
      }
    }
    incomplete2: (struct){
      x: (_){ matchN(1, (#list){
          0: (_|_){// {
            //   foo!: string
            // }
          }
        }) }
    }
    incomplete3: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete3.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected math.MultipleOf(2):
        //     ./incomplete.cue:16:6
        //     ./incomplete.cue:16:13
        //     ./incomplete.cue:17:6
        // incomplete.incomplete3.x.foo: field is required but not present:
        //     ./incomplete.cue:16:6
        //     ./incomplete.cue:16:48
        bar: (int){ 2 }
      }
    }
    incomplete4: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete4.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected math.MultipleOf(2):
        //     ./incomplete.cue:20:6
        //     ./incomplete.cue:20:13
        //     ./incomplete.cue:21:6
        // incomplete.incomplete4.x.baz: field is required but not present:
        //     ./incomplete.cue:20:6
        //     ./incomplete.cue:20:61
        // incomplete.incomplete4.x.foo: field is required but not present:
        //     ./incomplete.cue:20:6
        //     ./incomplete.cue:20:48
        bar: (int){ 2 }
      }
    }
    incomplete5: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete5.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected >1 & <=3:
        //     ./incomplete.cue:24:6
        //     ./incomplete.cue:24:13
        //     ./incomplete.cue:25:6
        // incomplete.incomplete5.x.baz: field is required but not present:
        //     ./incomplete.cue:24:6
        //     ./incomplete.cue:24:51
        // incomplete.incomplete5.x.foo: field is required but not present:
        //     ./incomplete.cue:24:6
        //     ./incomplete.cue:24:38
        bar: (int){ 2 }
      }
    }
    incomplete6: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete6.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected 2 | 3:
        //     ./incomplete.cue:28:6
        //     ./incomplete.cue:28:13
        //     ./incomplete.cue:29:6
        // incomplete.incomplete6.x.baz: field is required but not present:
        //     ./incomplete.cue:28:6
        //     ./incomplete.cue:28:46
        // incomplete.incomplete6.x.foo: field is required but not present:
        //     ./incomplete.cue:28:6
        //     ./incomplete.cue:28:33
        bar: (int){ 2 }
      }
    }
    err1: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err1.x.bar: conflicting values 2 and string (mismatched types int and string):
        //     ./incomplete.cue:34:24
        //     ./incomplete.cue:35:11
        // incomplete.err1.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
        //     ./incomplete.cue:34:6
        //     ./incomplete.cue:34:13
        //     ./incomplete.cue:35:6
        bar: (int){ 2 }
      }
    }
    err2: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err2.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected 0:
        //     ./incomplete.cue:40:6
        //     ./incomplete.cue:40:13
        //     ./incomplete.cue:41:6
        bar: (int){ 2 }
      }
    }
    err3: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err3.x.bar: conflicting values 2 and string (mismatched types int and string):
        //     ./incomplete.cue:46:24
        //     ./incomplete.cue:47:11
        // incomplete.err3.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 2:
        //     ./incomplete.cue:46:6
        //     ./incomplete.cue:46:13
        //     ./incomplete.cue:47:6
        bar: (int){ 2 }
      }
    }
    err4: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err4.x.bar: conflicting values 2 and string (mismatched types int and string):
        //     ./incomplete.cue:51:25
        //     ./incomplete.cue:52:11
        // incomplete.err4.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected >1:
        //     ./incomplete.cue:51:6
        //     ./incomplete.cue:51:13
        //     ./incomplete.cue:52:6
        bar: (int){ 2 }
      }
    }
    err5: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err5.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected <1:
        //     ./incomplete.cue:55:6
        //     ./incomplete.cue:55:13
        //     ./incomplete.cue:56:6
        bar: (int){ 2 }
      }
    }
  }
  issue3389: (struct){
    x: (_|_){
      // [incomplete] issue3389.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
      //     ./incomplete.cue:62:5
      //     ./incomplete.cue:61:5
      //     ./incomplete.cue:62:12
      // issue3389.x.foo: field is required but not present:
      //     ./incomplete.cue:62:5
      //     ./incomplete.cue:62:35
      bar: (int){ 2 }
    }
  }
  issue3694: (struct){
    full: (struct){
      #step: (_|_){
        // [incomplete] issue3694.full.#step: invalid value {uses?:string,run?:string} (does not satisfy matchN): 0 matched, expected 1:
        //     ./issue3694.cue:2:9
        //     ./issue3694.cue:2:16
        //     ./issue3694.cue:9:9
        // issue3694.full.#step.run: field is required but not present:
        //     ./issue3694.cue:2:9
        //     ./issue3694.cue:6:3
        // issue3694.full.#step.uses: field is required but not present:
        //     ./issue3694.cue:2:9
        //     ./issue3694.cue:3:3
        uses?: (string){ string }
        run?: (string){ string }
      }
      s: (#struct){
        uses?: (string){ string }
        run: (string){ "echo hello world" }
      }
    }
    simple: (struct){
      #step: (_|_){
        // [incomplete] issue3694.simple.#step: invalid value {uses?:string} (does not satisfy matchN): 0 matched, expected 1:
        //     ./issue3694.cue:19:9
        //     ./issue3694.cue:19:16
        //     ./issue3694.cue:22:9
        // issue3694.simple.#step.uses: field is required but not present:
        //     ./issue3694.cue:19:9
        //     ./issue3694.cue:20:3
        uses?: (string){ string }
      }
    }
  }
}
-- out/evalalpha --
Errors:
closedByDefinition.err5.out.exports: conflicting values null and {exp1:"./main-module.js"} (mismatched types null and struct):
    ./closedness.cue:80:13
    ./closedness.cue:80:24
    ./closedness.cue:85:7
    ./closedness.cue:86:12
closedByDefinition.err5.out.exports.exp1: conflicting values "./main-module.js" and null (mismatched types string and null):
    ./closedness.cue:80:30
    ./closedness.cue:81:24
    ./closedness.cue:82:26
    ./closedness.cue:85:7
    ./closedness.cue:86:18
closedByDefinition.err5.out.exports.exp1: conflicting values "./main-module.js" and {exp1?:#exports} (mismatched types string and struct):
    ./closedness.cue:80:30
    ./closedness.cue:81:30
    ./closedness.cue:82:19
    ./closedness.cue:82:26
    ./closedness.cue:85:7
    ./closedness.cue:86:18
explicitClose.err1.out.a: conflicting values "all" and {baz:"notAllowed"} (mismatched types string and struct):
    ./closedness.cue:32:11
    ./closedness.cue:32:12
    ./closedness.cue:33:6
    ./closedness.cue:33:17
    ./closedness.cue:35:7
    ./closedness.cue:36:6
incomplete.err1.x.bar: conflicting values 2 and string (mismatched types int and string):
    ./incomplete.cue:34:24
    ./incomplete.cue:35:11
incomplete.err3.x.bar: conflicting values 2 and string (mismatched types int and string):
    ./incomplete.cue:46:24
    ./incomplete.cue:47:11
incomplete.err4.x.bar: conflicting values 2 and string (mismatched types int and string):
    ./incomplete.cue:51:25
    ./incomplete.cue:52:11
match.defaults.pickNested1Err.a: conflicting values 2 and 3:
    ./in.cue:36:38
    ./in.cue:39:23
match.incompleteErr.a: conflicting values string and int (mismatched types string and int):
    ./in.cue:4:5
    ./in.cue:12:32
    ./in.cue:14:20
match.singleErr.a: conflicting values "foo" and int (mismatched types string and int):
    ./in.cue:4:5
    ./in.cue:8:28
    ./in.cue:10:16
openArguments.err2.out.a: conflicting values null and {allowed:"once"} (mismatched types null and struct):
    ./closedness.cue:20:11
    ./closedness.cue:20:12
    ./closedness.cue:21:13
    ./closedness.cue:22:5
    ./closedness.cue:27:7
    ./closedness.cue:28:6
openArguments.err2.out.a: invalid value {allowed:"once"} (does not satisfy matchN): 2 matched, expected 1:
    ./closedness.cue:21:13
    ./closedness.cue:21:20
    ./closedness.cue:28:6
explicitClose.err1.out.a: invalid value {baz:"notAllowed"} (does not satisfy matchN): 0 matched, expected 1:
    ./closedness.cue:33:6
    ./closedness.cue:33:13
    ./closedness.cue:36:6
explicitClose.err1.out.a.baz: field not allowed:
    ./closedness.cue:33:6
    ./closedness.cue:36:11
closedByDefinition.err5.out.exports: invalid value {exp1:"./main-module.js"} (does not satisfy matchN): 0 matched, expected 1:
    ./closedness.cue:80:13
    ./closedness.cue:80:20
    ./closedness.cue:86:12
closedByDefinition.err5.out.exports.exp1: invalid value "./main-module.js" (does not satisfy matchN): 0 matched, expected 1:
    ./closedness.cue:81:13
    ./closedness.cue:81:20
    ./closedness.cue:82:26
    ./closedness.cue:86:18
match.singleErr: invalid value {a:"foo"} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:8:17
    ./in.cue:8:24
    ./in.cue:10:13
match.incompleteErr: invalid value {a:string} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:12:21
    ./in.cue:12:28
    ./in.cue:14:17
match.defaults.pickNested1Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:36:23
    ./in.cue:36:30
    ./in.cue:39:19
match.defaults.pickNested2Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:41:23
    ./in.cue:41:30
    ./in.cue:44:19
match.defaults.pickNested2Err.a: invalid value 3 (out of bound <=2):
    ./in.cue:41:38
    ./in.cue:44:23
not.singleErr: invalid value {a:2} (does not satisfy matchN): 1 matched, expected 0:
    ./in.cue:74:17
    ./in.cue:74:24
    ./in.cue:76:13
not.doubleErr: invalid value {a:"foo"} (does not satisfy matchN): 1 matched, expected 0:
    ./in.cue:78:17
    ./in.cue:78:24
    ./in.cue:80:13
oneOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:84:20
    ./in.cue:84:27
    ./in.cue:86:17
oneOf.multiple1Err2: invalid value 15 (does not satisfy matchN): 2 matched, expected 1:
    ./in.cue:84:20
    ./in.cue:84:27
    ./in.cue:91:17
oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
    ./in.cue:84:31
    ./in.cue:84:20
    ./in.cue:84:47
    ./in.cue:86:17
oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
    ./in.cue:84:51
    ./in.cue:84:20
    ./in.cue:84:67
    ./in.cue:86:17
anyOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected >0:
    ./in.cue:95:20
    ./in.cue:95:27
    ./in.cue:97:17
anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
    ./in.cue:95:32
    ./in.cue:95:20
    ./in.cue:95:48
    ./in.cue:97:17
anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
    ./in.cue:95:52
    ./in.cue:95:20
    ./in.cue:95:68
    ./in.cue:97:17
allOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 2:
    ./in.cue:106:20
    ./in.cue:106:27
    ./in.cue:108:17
allOf.multiple1Err2: invalid value 3 (does not satisfy matchN): 1 matched, expected 2:
    ./in.cue:106:20
    ./in.cue:106:27
    ./in.cue:109:17
allOf.multiple1Err3: invalid value 5 (does not satisfy matchN): 1 matched, expected 2:
    ./in.cue:106:20
    ./in.cue:106:27
    ./in.cue:110:17
allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
    ./in.cue:106:31
    ./in.cue:106:20
    ./in.cue:106:47
    ./in.cue:108:17
allOf.multiple1Err3: invalid value 5 (does not satisfy math.MultipleOf(3)):
    ./in.cue:106:31
    ./in.cue:106:20
    ./in.cue:106:47
    ./in.cue:110:17
allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
    ./in.cue:106:51
    ./in.cue:106:20
    ./in.cue:106:67
    ./in.cue:108:17
allOf.multiple1Err2: invalid value 3 (does not satisfy math.MultipleOf(5)):
    ./in.cue:106:51
    ./in.cue:106:20
    ./in.cue:106:67
    ./in.cue:109:17
incomplete.err1.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
    ./incomplete.cue:34:6
    ./incomplete.cue:34:13
    ./incomplete.cue:35:6
incomplete.err2.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected 0:
    ./incomplete.cue:40:6
    ./incomplete.cue:40:13
    ./incomplete.cue:41:6
incomplete.err3.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 2:
    ./incomplete.cue:46:6
    ./incomplete.cue:46:13
    ./incomplete.cue:47:6
incomplete.err4.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected >1:
    ./incomplete.cue:51:6
    ./incomplete.cue:51:13
    ./incomplete.cue:52:6
incomplete.err5.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected <1:
    ./incomplete.cue:55:6
    ./incomplete.cue:55:13
    ./incomplete.cue:56:6

Result:
(_|_){
  // [eval]
  ellipsis: (struct){
    ok: (struct){
      out: (#struct){
        field: (#struct){
          shouldBeAllowed: (int){ 123 }
        }
        #anything: (_){ matchN(1, (#list){
            0: (_|_){// {
              //   ...
              // }
            }
          }) }
      }
      #Schema: (#struct){
        field?: (_){ matchN(1, (#list){
            0: (_|_){// {
              //   ...
              // }
            }
          }) }
        #anything: (_){ matchN(1, (#list){
            0: (_|_){// {
              //   ...
              // }
            }
          }) }
      }
    }
  }
  openArguments: (_|_){
    // [eval]
    ok1: (struct){
      #Schema: (#struct){
        a: (_){ matchN(1, (#list){
            0: (_|_){// "all"
            }
            1: (_|_){// {
              //   foo: "bar"
              // }
            }
          }) }
      }
      out: (#struct){
        a: (#struct){
          baz: (string){ "allowed" }
        }
      }
    }
    err2: (_|_){
      // [eval]
      #Schema: (#struct){
        a?: (_){ matchN(1, (#list){
            0: (_|_){// null
            }
            1: (_|_){// {
              //   [string]: string
              // }
            }
            2: (_|_){// {
              //   b: {
              //     ...
              //   }
              // }
            }
          }) }
      }
      out: (_|_){
        // [eval]
        a: (_|_){
          // [eval] openArguments.err2.out.a: conflicting values null and {allowed:"once"} (mismatched types null and struct):
          //     ./closedness.cue:20:11
          //     ./closedness.cue:20:12
          //     ./closedness.cue:21:13
          //     ./closedness.cue:22:5
          //     ./closedness.cue:27:7
          //     ./closedness.cue:28:6
          // openArguments.err2.out.a: invalid value {allowed:"once"} (does not satisfy matchN): 2 matched, expected 1:
          //     ./closedness.cue:21:13
          //     ./closedness.cue:21:20
          //     ./closedness.cue:28:6
          allowed: (string){ "once" }
        }
      }
    }
  }
  explicitClose: (_|_){
    // [eval]
    err1: (_|_){
      // [eval]
      #Schema: (#struct){
        a: (_){ matchN(1, (#list){
            0: (_|_){// "all"
            }
            1: (_|_){// close({
              //   foo: "bar"
              // })
            }
          }) }
      }
      out: (_|_){
        // [eval]
        a: (_|_){
          // [eval] explicitClose.err1.out.a: conflicting values "all" and {baz:"notAllowed"} (mismatched types string and struct):
          //     ./closedness.cue:32:11
          //     ./closedness.cue:32:12
          //     ./closedness.cue:33:6
          //     ./closedness.cue:33:17
          //     ./closedness.cue:35:7
          //     ./closedness.cue:36:6
          // explicitClose.err1.out.a: invalid value {baz:"notAllowed"} (does not satisfy matchN): 0 matched, expected 1:
          //     ./closedness.cue:33:6
          //     ./closedness.cue:33:13
          //     ./closedness.cue:36:6
          // explicitClose.err1.out.a.baz: field not allowed:
          //     ./closedness.cue:33:6
          //     ./closedness.cue:36:11
          baz: (string){ "notAllowed" }
        }
      }
    }
    ok2: (struct){
      #Schema: (#struct){
        a?: (_){ matchN(1, (#list){
            0: (_|_){// null
            }
            1: (_|_){// close({
              //   [string]: string
              // })
            }
            2: (_|_){// close({
              //   b: {
              //     ...
              //   }
              // })
            }
          }) }
      }
      out: (#struct){
        a: (#struct){
          allowed: (string){ "once" }
        }
      }
    }
  }
  mixed: (struct){
    ok3: (struct){
      #Schema: (#struct){
        exports?: (_){ matchN(1, (#list){
            0: (_|_){// close({
              //   never?: _
              // })
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exports: (_){ matchN(1, (#list){
            0: (_|_){// string
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exportsObject: (#struct){
          exp1?: (_){ matchN(1, (#list){
              0: (_|_){// string
              }
              1: (_|_){// 〈1;#exportsObject〉
              }
            }) }
        }
      }
      out: (#struct){
        exports: (#struct){
          exp1: (string){ "./main-module.js" }
        }
        #exports: (_){ matchN(1, (#list){
            0: (_|_){// string
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exportsObject: (#struct){
          exp1?: (_){ matchN(1, (#list){
              0: (_|_){// string
              }
              1: (_|_){// 〈1;#exportsObject〉
              }
            }) }
        }
      }
    }
  }
  closedByDefinition: (_|_){
    // [eval]
    ok4: (struct){
      #Schema: (#struct){
        exports?: (_){ matchN(1, (#list){
            0: (_|_){// string
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exports: (_){ matchN(1, (#list){
            0: (_|_){// string
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exportsObject: (#struct){
          exp1?: (_){ matchN(1, (#list){
              0: (_|_){// string
              }
              1: (_|_){// 〈1;#exportsObject〉
              }
            }) }
        }
      }
      out: (#struct){
        exports: (#struct){
          exp1: (string){ "./main-module.js" }
        }
        #exports: (_){ matchN(1, (#list){
            0: (_|_){// string
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exportsObject: (#struct){
          exp1?: (_){ matchN(1, (#list){
              0: (_|_){// string
              }
              1: (_|_){// 〈1;#exportsObject〉
              }
            }) }
        }
      }
    }
    err5: (_|_){
      // [eval]
      #Schema: (#struct){
        exports?: (_){ matchN(1, (#list){
            0: (_|_){// null
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exports: (_){ matchN(1, (#list){
            0: (_|_){// null
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exportsObject: (#struct){
          exp1?: (_){ matchN(1, (#list){
              0: (_|_){// null
              }
              1: (_|_){// 〈1;#exportsObject〉
              }
            }) }
        }
      }
      out: (_|_){
        // [eval]
        exports: (_|_){
          // [eval] closedByDefinition.err5.out.exports: conflicting values null and {exp1:"./main-module.js"} (mismatched types null and struct):
          //     ./closedness.cue:80:13
          //     ./closedness.cue:80:24
          //     ./closedness.cue:85:7
          //     ./closedness.cue:86:12
          // closedByDefinition.err5.out.exports.exp1: conflicting values "./main-module.js" and null (mismatched types string and null):
          //     ./closedness.cue:80:30
          //     ./closedness.cue:81:24
          //     ./closedness.cue:82:26
          //     ./closedness.cue:85:7
          //     ./closedness.cue:86:18
          // closedByDefinition.err5.out.exports.exp1: conflicting values "./main-module.js" and {exp1?:#exports} (mismatched types string and struct):
          //     ./closedness.cue:80:30
          //     ./closedness.cue:81:30
          //     ./closedness.cue:82:19
          //     ./closedness.cue:82:26
          //     ./closedness.cue:85:7
          //     ./closedness.cue:86:18
          // closedByDefinition.err5.out.exports: invalid value {exp1:"./main-module.js"} (does not satisfy matchN): 0 matched, expected 1:
          //     ./closedness.cue:80:13
          //     ./closedness.cue:80:20
          //     ./closedness.cue:86:12
          // closedByDefinition.err5.out.exports.exp1: invalid value "./main-module.js" (does not satisfy matchN): 0 matched, expected 1:
          //     ./closedness.cue:81:13
          //     ./closedness.cue:81:20
          //     ./closedness.cue:82:26
          //     ./closedness.cue:86:18
          exp1: (string){ "./main-module.js" }
        }
        #exports: (_){ matchN(1, (#list){
            0: (_|_){// null
            }
            1: (_|_){// 〈1;#exportsObject〉
            }
          }) }
        #exportsObject: (#struct){
          exp1?: (_){ matchN(1, (#list){
              0: (_|_){// null
              }
              1: (_|_){// 〈1;#exportsObject〉
              }
            }) }
        }
      }
    }
  }
  #Foo: (#struct){
    a: (int){ int }
  }
  match: (_|_){
    // [eval]
    singleOK: (struct){
      a: (int){ 2 }
    }
    singleErr: (_|_){
      // [eval] match.singleErr.a: conflicting values "foo" and int (mismatched types string and int):
      //     ./in.cue:4:5
      //     ./in.cue:8:28
      //     ./in.cue:10:16
      // match.singleErr: invalid value {a:"foo"} (does not satisfy matchN): 0 matched, expected 1:
      //     ./in.cue:8:17
      //     ./in.cue:8:24
      //     ./in.cue:10:13
      a: (string){ "foo" }
    }
    incompleteOK: (struct){
      a: (int){ int }
    }
    incompleteErr: (_|_){
      // [eval] match.incompleteErr.a: conflicting values string and int (mismatched types string and int):
      //     ./in.cue:4:5
      //     ./in.cue:12:32
      //     ./in.cue:14:20
      // match.incompleteErr: invalid value {a:string} (does not satisfy matchN): 0 matched, expected 1:
      //     ./in.cue:12:21
      //     ./in.cue:12:28
      //     ./in.cue:14:17
      a: (string){ string }
    }
    #A: (#struct){
      a: (int){ int }
      b: (_){ _ }
    }
    defaults: (_|_){
      // [eval]
      pickTopOK1: (int){ |(*(int){ 2 }, (int){ &(matchN(1, (#list){
            0: (int){ 2 }
          }), int) }) }
      pickTopOK2: (int){ &(matchN(1, (#list){
          0: (_|_){// 2
          }
        }), int) }
      pickTopErr: (int){ &(matchN(1, (#list){
          0: (int){ 2 }
        }), int) }
      pickNested1OK1: (struct){
        a: (int){ |(*(int){ 2 }, (int){ int }) }
      }
      pickNested1OK2: (struct){
        a: (int){ int }
      }
      pickNested1Err: (_|_){
        // [eval] match.defaults.pickNested1Err.a: conflicting values 2 and 3:
        //     ./in.cue:36:38
        //     ./in.cue:39:23
        // match.defaults.pickNested1Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
        //     ./in.cue:36:23
        //     ./in.cue:36:30
        //     ./in.cue:39:19
        a: (int){ |(*(int){ 3 }, (int){ int }) }
      }
      pickNested2OK1: (struct){
        a: (int){ |(*(int){ 2 }, (int){ int }) }
      }
      pickNested2OK2: (struct){
        a: (int){ int }
      }
      pickNested2Err: (_|_){
        // [eval] match.defaults.pickNested2Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
        //     ./in.cue:41:23
        //     ./in.cue:41:30
        //     ./in.cue:44:19
        // match.defaults.pickNested2Err.a: invalid value 3 (out of bound <=2):
        //     ./in.cue:41:38
        //     ./in.cue:44:23
        a: (int){ |(*(int){ 3 }, (int){ int }) }
      }
    }
    nestedOK: (struct){
      a: (int){ 2 }
      b: (struct){
        a: (int){ 3 }
        b: (struct){
          a: (int){ 4 }
        }
        c: (struct){
          a: (int){ 5 }
        }
      }
      c: (struct){
        a: (int){ 3 }
        b: (struct){
          a: (int){ 4 }
        }
        c: (struct){
          a: (int){ 5 }
        }
      }
    }
  }
  not: (_|_){
    // [eval]
    singleOK: (struct){
      a: (string){ "foo" }
    }
    singleErr: (_|_){
      // [eval] not.singleErr: invalid value {a:2} (does not satisfy matchN): 1 matched, expected 0:
      //     ./in.cue:74:17
      //     ./in.cue:74:24
      //     ./in.cue:76:13
      a: (int){ 2 }
    }
    doubleOK: (struct){
      a: (int){ 2 }
    }
    doubleErr: (_|_){
      // [eval] not.doubleErr: invalid value {a:"foo"} (does not satisfy matchN): 1 matched, expected 0:
      //     ./in.cue:78:17
      //     ./in.cue:78:24
      //     ./in.cue:80:13
      a: (string){ "foo" }
    }
  }
  oneOf: (_|_){
    // [eval]
    multiple1Err1: (_|_){
      // [eval] oneOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 1:
      //     ./in.cue:84:20
      //     ./in.cue:84:27
      //     ./in.cue:86:17
      // oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:84:31
      //     ./in.cue:84:20
      //     ./in.cue:84:47
      //     ./in.cue:86:17
      // oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:84:51
      //     ./in.cue:84:20
      //     ./in.cue:84:67
      //     ./in.cue:86:17
    }
    multiple1OK1: (int){ 3 }
    multiple1OK2: (int){ 5 }
    multiple1Err2: (_|_){
      // [eval] oneOf.multiple1Err2: invalid value 15 (does not satisfy matchN): 2 matched, expected 1:
      //     ./in.cue:84:20
      //     ./in.cue:84:27
      //     ./in.cue:91:17
    }
  }
  anyOf: (_|_){
    // [eval]
    multiple1Err1: (_|_){
      // [eval] anyOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected >0:
      //     ./in.cue:95:20
      //     ./in.cue:95:27
      //     ./in.cue:97:17
      // anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:95:32
      //     ./in.cue:95:20
      //     ./in.cue:95:48
      //     ./in.cue:97:17
      // anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:95:52
      //     ./in.cue:95:20
      //     ./in.cue:95:68
      //     ./in.cue:97:17
    }
    multiple1OK1: (int){ 3 }
    multiple1OK2: (int){ 5 }
    multiple1OK3: (int){ 15 }
  }
  allOf: (_|_){
    // [eval]
    multiple1Err1: (_|_){
      // [eval] allOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 2:
      //     ./in.cue:106:20
      //     ./in.cue:106:27
      //     ./in.cue:108:17
      // allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:106:31
      //     ./in.cue:106:20
      //     ./in.cue:106:47
      //     ./in.cue:108:17
      // allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:106:51
      //     ./in.cue:106:20
      //     ./in.cue:106:67
      //     ./in.cue:108:17
    }
    multiple1Err2: (_|_){
      // [eval] allOf.multiple1Err2: invalid value 3 (does not satisfy matchN): 1 matched, expected 2:
      //     ./in.cue:106:20
      //     ./in.cue:106:27
      //     ./in.cue:109:17
      // allOf.multiple1Err2: invalid value 3 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:106:51
      //     ./in.cue:106:20
      //     ./in.cue:106:67
      //     ./in.cue:109:17
    }
    multiple1Err3: (_|_){
      // [eval] allOf.multiple1Err3: invalid value 5 (does not satisfy matchN): 1 matched, expected 2:
      //     ./in.cue:106:20
      //     ./in.cue:106:27
      //     ./in.cue:110:17
      // allOf.multiple1Err3: invalid value 5 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:106:31
      //     ./in.cue:106:20
      //     ./in.cue:106:47
      //     ./in.cue:110:17
    }
    multiple1OK1: (int){ 15 }
  }
  bare: (struct){
    embed: (struct){
      t1: (struct){
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
      t2: (struct){
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
    }
    direct: (struct){
      t1: (struct){
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
      t2: (struct){
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
    }
  }
  required: (struct){
    ok1: (struct){
      x: (struct){
        bar: (int){ 2 }
      }
    }
    ok2: (struct){
      x: (_){ matchN(0, (#list){
          0: (_|_){// {
            //   foo!: string
            // }
          }
        }) }
    }
    ok3: (struct){
      x: (struct){
        bar: (int){ 2 }
      }
    }
  }
  issue3575: (struct){
    test1: (struct){
      #x: (_){ matchN(1, (#list){
          0: (_|_){// [
            //   {},
            // ]
          }
        }) }
      x: (#list){
        0: (struct){
          a: (int){ 1 }
        }
      }
    }
    test2: (struct){
      #x: (_){ matchN(1, (#list){
          0: (_|_){// {}
          }
        }) }
      x: (#struct){
        a: (int){ 1 }
      }
    }
  }
  incomplete: (_|_){
    // [eval]
    incomplete1: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete1.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
        //     ./incomplete.cue:7:6
        //     ./incomplete.cue:7:13
        //     ./incomplete.cue:8:6
        // incomplete.incomplete1.x.foo: field is required but not present:
        //     ./incomplete.cue:7:6
        //     ./incomplete.cue:7:18
        bar: (int){ 2 }
      }
    }
    incomplete2: (struct){
      x: (_){ matchN(1, (#list){
          0: (_|_){// {
            //   foo!: string
            // }
          }
        }) }
    }
    incomplete3: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete3.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected math.MultipleOf(2):
        //     ./incomplete.cue:16:6
        //     ./incomplete.cue:16:13
        //     ./incomplete.cue:17:6
        // incomplete.incomplete3.x.foo: field is required but not present:
        //     ./incomplete.cue:16:6
        //     ./incomplete.cue:16:48
        bar: (int){ 2 }
      }
    }
    incomplete4: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete4.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected math.MultipleOf(2):
        //     ./incomplete.cue:20:6
        //     ./incomplete.cue:20:13
        //     ./incomplete.cue:21:6
        // incomplete.incomplete4.x.baz: field is required but not present:
        //     ./incomplete.cue:20:6
        //     ./incomplete.cue:20:61
        // incomplete.incomplete4.x.foo: field is required but not present:
        //     ./incomplete.cue:20:6
        //     ./incomplete.cue:20:48
        bar: (int){ 2 }
      }
    }
    incomplete5: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete5.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected >1 & <=3:
        //     ./incomplete.cue:24:6
        //     ./incomplete.cue:24:13
        //     ./incomplete.cue:25:6
        // incomplete.incomplete5.x.baz: field is required but not present:
        //     ./incomplete.cue:24:6
        //     ./incomplete.cue:24:51
        // incomplete.incomplete5.x.foo: field is required but not present:
        //     ./incomplete.cue:24:6
        //     ./incomplete.cue:24:38
        bar: (int){ 2 }
      }
    }
    incomplete6: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete6.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected 2 | 3:
        //     ./incomplete.cue:28:6
        //     ./incomplete.cue:28:13
        //     ./incomplete.cue:29:6
        // incomplete.incomplete6.x.baz: field is required but not present:
        //     ./incomplete.cue:28:6
        //     ./incomplete.cue:28:46
        // incomplete.incomplete6.x.foo: field is required but not present:
        //     ./incomplete.cue:28:6
        //     ./incomplete.cue:28:33
        bar: (int){ 2 }
      }
    }
    err1: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err1.x.bar: conflicting values 2 and string (mismatched types int and string):
        //     ./incomplete.cue:34:24
        //     ./incomplete.cue:35:11
        // incomplete.err1.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
        //     ./incomplete.cue:34:6
        //     ./incomplete.cue:34:13
        //     ./incomplete.cue:35:6
        bar: (int){ 2 }
      }
    }
    err2: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err2.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected 0:
        //     ./incomplete.cue:40:6
        //     ./incomplete.cue:40:13
        //     ./incomplete.cue:41:6
        bar: (int){ 2 }
      }
    }
    err3: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err3.x.bar: conflicting values 2 and string (mismatched types int and string):
        //     ./incomplete.cue:46:24
        //     ./incomplete.cue:47:11
        // incomplete.err3.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 2:
        //     ./incomplete.cue:46:6
        //     ./incomplete.cue:46:13
        //     ./incomplete.cue:47:6
        bar: (int){ 2 }
      }
    }
    err4: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err4.x.bar: conflicting values 2 and string (mismatched types int and string):
        //     ./incomplete.cue:51:25
        //     ./incomplete.cue:52:11
        // incomplete.err4.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected >1:
        //     ./incomplete.cue:51:6
        //     ./incomplete.cue:51:13
        //     ./incomplete.cue:52:6
        bar: (int){ 2 }
      }
    }
    err5: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err5.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected <1:
        //     ./incomplete.cue:55:6
        //     ./incomplete.cue:55:13
        //     ./incomplete.cue:56:6
        bar: (int){ 2 }
      }
    }
  }
  issue3389: (struct){
    x: (_|_){
      // [incomplete] issue3389.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
      //     ./incomplete.cue:62:5
      //     ./incomplete.cue:61:5
      //     ./incomplete.cue:62:12
      // issue3389.x.foo: field is required but not present:
      //     ./incomplete.cue:62:5
      //     ./incomplete.cue:62:35
      bar: (int){ 2 }
    }
  }
  issue3694: (struct){
    full: (struct){
      #step: (_|_){
        // [incomplete] issue3694.full.#step: invalid value {uses?:string,run?:string} (does not satisfy matchN): 0 matched, expected 1:
        //     ./issue3694.cue:2:9
        //     ./issue3694.cue:2:16
        //     ./issue3694.cue:9:9
        // issue3694.full.#step.run: field is required but not present:
        //     ./issue3694.cue:2:9
        //     ./issue3694.cue:6:3
        // issue3694.full.#step.uses: field is required but not present:
        //     ./issue3694.cue:2:9
        //     ./issue3694.cue:3:3
        uses?: (string){ string }
        run?: (string){ string }
      }
      s: (#struct){
        run: (string){ "echo hello world" }
        uses?: (string){ string }
      }
    }
    simple: (struct){
      #step: (_|_){
        // [incomplete] issue3694.simple.#step: invalid value {uses?:string} (does not satisfy matchN): 0 matched, expected 1:
        //     ./issue3694.cue:19:9
        //     ./issue3694.cue:19:16
        //     ./issue3694.cue:22:9
        // issue3694.simple.#step.uses: field is required but not present:
        //     ./issue3694.cue:19:9
        //     ./issue3694.cue:20:3
        uses?: (string){ string }
      }
    }
  }
}
-- diff/explanation --
The old evaluator does not correctly handle ToDataAll if a node is
mid-evaluation. The new evaluator does.
issue3575: the old evaluator was incorrect in behaving differently when using structs inside lists
closedness.cue: several discrepancies. EvalV3 is correct in all cases.
-- diff/todo/p3 --
Missing error positions.
-- out/compile --
--- closedness.cue
{
  ellipsis: {
    ok: {
      out: (〈0;#Schema〉 & {
        field: {
          shouldBeAllowed: 123
        }
      })
      #Schema: {
        field?: 〈0;#anything〉
        #anything: matchN(1, [
          {
            ...
          },
        ])
      }
    }
  }
  openArguments: {
    ok1: {
      #Schema: {
        {
          a: matchN(1, [
            "all",
            {
              foo: "bar"
            },
          ])
        }
      }
      out: (〈0;#Schema〉 & {
        a: {
          baz: "allowed"
        }
      })
    }
  }
  openArguments: {
    err2: {
      #Schema: {
        {
          a?: matchN(1, [
            null,
            {
              [string]: string
            },
            {
              b: {
                ...
              }
            },
          ])
        }
      }
      out: (〈0;#Schema〉 & {
        a: {
          allowed: "once"
        }
      })
    }
  }
  explicitClose: {
    err1: {
      #Schema: {
        {
          a: matchN(1, [
            "all",
            close({
              foo: "bar"
            }),
          ])
        }
      }
      out: (〈0;#Schema〉 & {
        a: {
          baz: "notAllowed"
        }
      })
    }
  }
  explicitClose: {
    ok2: {
      #Schema: {
        {
          a?: matchN(1, [
            null,
            close({
              [string]: string
            }),
            close({
              b: {
                ...
              }
            }),
          ])
        }
      }
      out: (〈0;#Schema〉 & {
        a: {
          allowed: "once"
        }
      })
    }
  }
  mixed: {
    ok3: {
      #Schema: {
        exports?: matchN(1, [
          close({
            never?: _
          }),
          〈1;#exportsObject〉,
        ])
        #exports: matchN(1, [
          string,
          〈1;#exportsObject〉,
        ])
        #exportsObject: {
          exp1?: 〈1;#exports〉
        }
      }
      out: (〈0;#Schema〉 & {
        exports: {
          exp1: "./main-module.js"
        }
      })
    }
  }
  closedByDefinition: {
    ok4: {
      #Schema: {
        exports?: matchN(1, [
          string,
          〈1;#exportsObject〉,
        ])
        #exports: matchN(1, [
          string,
          〈1;#exportsObject〉,
        ])
        #exportsObject: {
          exp1?: 〈1;#exports〉
        }
      }
      out: (〈0;#Schema〉 & {
        exports: {
          exp1: "./main-module.js"
        }
      })
    }
  }
  closedByDefinition: {
    err5: {
      #Schema: {
        exports?: matchN(1, [
          null,
          〈1;#exportsObject〉,
        ])
        #exports: matchN(1, [
          null,
          〈1;#exportsObject〉,
        ])
        #exportsObject: {
          exp1?: 〈1;#exports〉
        }
      }
      out: (〈0;#Schema〉 & {
        exports: {
          exp1: "./main-module.js"
        }
      })
    }
  }
}
--- in.cue
{
  #Foo: {
    a: int
  }
  match: {
    [=~"^single"]: matchN(1, [
      〈2;#Foo〉,
    ])
    singleOK: {
      a: 2
    }
    singleErr: {
      a: "foo"
    }
    [=~"^incomplete"]: matchN(1, [
      〈2;#Foo〉,
    ])
    incompleteOK: {
      a: int
    }
    incompleteErr: {
      a: string
    }
    #A: {
      a: int
      b: _
      ...
    }
    defaults: {
      [=~"^pickTop"]: matchN(1, [
        2,
      ])
      pickTopOK1: (*2|int)
      pickTopOK2: int
      pickTopErr: (*3|int)
      [=~"^pickNested1"]: matchN(1, [
        {
          a: 2
        },
      ])
      pickNested1OK1: {
        a: (*2|int)
      }
      pickNested1OK2: {
        a: int
      }
      pickNested1Err: {
        a: (*3|int)
      }
      [=~"^pickNested2"]: matchN(1, [
        {
          a: <=2
        },
      ])
      pickNested2OK1: {
        a: (*2|int)
      }
      pickNested2OK2: {
        a: int
      }
      pickNested2Err: {
        a: (*3|int)
      }
    }
    nestedOK: {
      matchN(4, [
        〈2;#A〉,
        〈2;#A〉,
        〈2;#A〉,
        〈2;#A〉,
      ])
      a: 2
      b: {
        matchN(4, [
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
        ])
        a: 3
        b: matchN(4, [
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
        ])
        b: {
          a: 4
        }
        c: matchN(4, [
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
        ])
        c: {
          a: 5
        }
      }
      c: {
        matchN(4, [
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
        ])
        a: 3
        b: matchN(4, [
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
        ])
        b: {
          a: 4
        }
        c: matchN(4, [
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
        ])
        c: {
          a: 5
        }
      }
    }
  }
  not: {
    [=~"^single"]: matchN(0, [
      〈2;#Foo〉,
    ])
    singleOK: {
      a: "foo"
    }
    singleErr: {
      a: 2
    }
    [=~"^double"]: matchN(0, [
      matchN(0, [
        〈3;#Foo〉,
      ]),
    ])
    doubleOK: {
      a: 2
    }
    doubleErr: {
      a: "foo"
    }
  }
  oneOf: {
    [=~"^multiple1"]: matchN(1, [
      〈import;math〉.MultipleOf(3),
      〈import;math〉.MultipleOf(5),
    ])
    multiple1Err1: 1
    multiple1OK1: 3
    multiple1OK2: 5
    multiple1Err2: 15
  }
  anyOf: {
    [=~"^multiple1"]: matchN(>0, [
      〈import;math〉.MultipleOf(3),
      〈import;math〉.MultipleOf(5),
    ])
    multiple1Err1: 1
    multiple1OK1: 3
    multiple1OK2: 5
    multiple1OK3: 15
  }
  allOf: {
    [=~"^multiple1"]: matchN(2, [
      〈import;math〉.MultipleOf(3),
      〈import;math〉.MultipleOf(5),
    ])
    multiple1Err1: 1
    multiple1Err2: 3
    multiple1Err3: 5
    multiple1OK1: 15
  }
  bare: {
    embed: {
      t1: {
        a: {
          matchN(1, [
            >10,
          ])
        }
        b: {
          〈1;a〉
        }
      }
    }
    embed: {
      t2: {
        b: {
          〈1;a〉
        }
        a: {
          matchN(1, [
            >10,
          ])
        }
      }
    }
    direct: {
      t1: {
        a: matchN(1, [
          >10,
        ])
        b: 〈0;a〉
      }
    }
    direct: {
      t2: {
        b: 〈0;a〉
        a: matchN(1, [
          >10,
        ])
      }
    }
  }
  required: {
    ok1: {
      x: matchN(0, [
        {
          foo!: string
        },
      ])
      x: {
        bar: 2
      }
    }
    ok2: {
      x: matchN(0, [
        {
          foo!: string
        },
      ])
    }
    ok3: {
      x: matchN(0, [
        {
          bar!: string
        },
      ])
      x: {
        bar: 2
      }
    }
  }
  issue3575: {
    test1: {
      #x: matchN(1, [
        [
          {},
        ],
      ])
      x: 〈0;#x〉
      x: [
        {
          a: 1
        },
      ]
    }
    test2: {
      #x: matchN(1, [
        {},
      ])
      x: 〈0;#x〉
      x: {
        a: 1
      }
    }
  }
}
--- incomplete.cue
{
  incomplete: {
    incomplete1: {
      x: matchN(1, [
        {
          foo!: string
        },
      ])
      x: {
        bar: 2
      }
    }
    incomplete2: {
      x: matchN(1, [
        {
          foo!: string
        },
      ])
    }
    incomplete3: {
      x: matchN(〈import;math〉.MultipleOf(2), [
        {
          bar!: int
        },
        {
          foo!: int
        },
      ])
      x: {
        bar: 2
      }
    }
    incomplete4: {
      x: matchN(〈import;math〉.MultipleOf(2), [
        {
          bar!: int
        },
        {
          foo!: int
        },
        {
          baz!: int
        },
      ])
      x: {
        bar: 2
      }
    }
    incomplete5: {
      x: matchN((>1 & <=3), [
        {
          bar!: int
        },
        {
          foo!: int
        },
        {
          baz!: int
        },
      ])
      x: {
        bar: 2
      }
    }
    incomplete6: {
      x: matchN((2|3), [
        {
          bar!: int
        },
        {
          foo!: int
        },
        {
          baz!: int
        },
      ])
      x: {
        bar: 2
      }
    }
    err1: {
      x: matchN(1, [
        {
          bar!: string
        },
      ])
      x: {
        bar: 2
      }
    }
    err2: {
      x: matchN(0, [
        {
          bar!: int
        },
        {
          foo!: int
        },
      ])
      x: {
        bar: 2
      }
    }
    err3: {
      x: matchN(2, [
        {
          bar!: string
        },
        {
          foo!: string
        },
      ])
      x: {
        bar: 2
      }
    }
    err4: {
      x: matchN(>1, [
        {
          bar!: string
        },
        {
          foo!: string
        },
      ])
      x: {
        bar: 2
      }
    }
    err5: {
      x: matchN(<1, [
        {
          bar!: int
        },
        {
          foo!: int
        },
      ])
      x: {
        bar: 2
      }
    }
  }
  issue3389: {
    x: {
      bar: 2
    }
    x: matchN(1, [
      {
        bar: 3
      },
      {
        bar: 2
        foo!: int
      },
    ])
  }
}
--- issue3694.cue
{
  issue3694: {
    full: {
      #step: matchN(1, [
        {
          uses!: _
          ...
        },
        {
          run!: _
          ...
        },
      ])
      #step: close({
        uses?: string
        run?: string
      })
      s: (〈0;#step〉 & {
        run: "echo hello world"
      })
    }
  }
  issue3694: {
    simple: {
      #step: matchN(1, [
        {
          uses!: _
        },
      ])
      #step: close({
        uses?: string
      })
    }
  }
}
