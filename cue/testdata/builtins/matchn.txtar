-- in.cue --
import "math"

#Foo: {
	a: int
}

match: {
	[=~"^single"]: matchN(1, [#Foo])
	singleOK: a: 2
	singleErr: a: "foo"

	[=~"^incomplete"]: matchN(1, [#Foo])
	incompleteOK: a: int
	incompleteErr: a: string

	#A: {
		a: int
		b: _
		...
	}

	defaults: {
		// Because validators distribute over disjunctions, this validator may erase
		// a default value. Nonethenless, it will be guaranteed that the value
		// resulting from evaluation does not violate the validator.
		// TODO(defaults): take this use case into consideration for the defaults
		// rethink, as it seems less than ideal. Note that this typically not an
		// issue if the schema matched against is not concrete.
		[=~"^pickTop"]: matchN(1, [2])
		pickTopOK1: *2 | int
		pickTopOK2: int
		pickTopErr: *3 | int // Final values taken.

		// Nested default values will be evaluated and may not be overridden by
		// values in the validator.
		[=~"^pickNested1"]: matchN(1, [{a: 2}])
		pickNested1OK1: a: *2 | int
		pickNested1OK2: a: int
		pickNested1Err: a: *3 | int

		[=~"^pickNested2"]: matchN(1, [{a: <=2}])
		pickNested2OK1: a: *2 | int
		pickNested2OK2: a: int
		pickNested2Err: a: *3 | int
	}

	// Stress test potential exponential behavior.
	nestedOK: {
		matchN(4, [#A, #A, #A, #A])

		a: 2
		b: {
			matchN(4, [#A, #A, #A, #A])
	
			a: 3
			b: matchN(4, [#A, #A, #A, #A])
			b: a: 4
			c: matchN(4, [#A, #A, #A, #A])
			c: a: 5
		}
		c: {
			matchN(4, [#A, #A, #A, #A])
	
			a: 3
			b: matchN(4, [#A, #A, #A, #A])
			b: a: 4
			c: matchN(4, [#A, #A, #A, #A])
			c: a: 5
		}
	}
}

not: {
	[=~"^single"]: matchN(0, [#Foo])
	singleOK: a: "foo"
	singleErr: a: 2

	[=~"^double"]: matchN(0, [matchN(0, [#Foo])])
	doubleOK: a: 2
	doubleErr: a: "foo"
}

oneOf: {
	[=~"^multiple1"]: matchN(1, [math.MultipleOf(3), math.MultipleOf(5)])

	multiple1Err1: 1

	multiple1OK1: 3
	multiple1OK2: 5

	multiple1Err2: 15
}

anyOf: {
	[=~"^multiple1"]: matchN(>0, [math.MultipleOf(3), math.MultipleOf(5)])

	multiple1Err1: 1

	multiple1OK1: 3
	multiple1OK2: 5
	multiple1OK3: 15
}


allOf: {
	[=~"^multiple1"]: matchN(2, [math.MultipleOf(3), math.MultipleOf(5)])

	multiple1Err1: 1
	multiple1Err2: 3
	multiple1Err3: 5

	multiple1OK1: 15
}

bare: {
	embed: t1: {
		a: {matchN(1, [>10])}
		b: {a}
	}
	embed: t2: {
		b: {a}
		a: {matchN(1, [>10])}
	}
	direct: t1: {
		a: matchN(1, [>10])
		b: a
	}
	direct: t2: {
		b: a
		a: matchN(1, [>10])
	}
}

required: {
	ok1: {
		x: matchN(0, [{foo!: string}])
		x: bar: 2
	}
	ok2: {
		x: matchN(0, [{foo!: string}])
	}
	// not matching for different reasons
	ok3: {
		x: matchN(0, [{bar!: string}])
		x: bar: 2
	}
}

// A struct with extra fields should match whether or not inside a list.
// evalv2 would get this wrong but evalv3 got it right.
issue3575: {
	test1: {
		#x: matchN(1, [
			[{}],
		])
		x: #x
		x: [{a: 1}]
	}
	test2: {
		#x: matchN(1, [
			{},
		])
		x: #x
		x: {a: 1}
	}
}

-- incomplete.cue --
import "math"

// The errors in this section should be "incomplete" errors.
incomplete: {
	// foo could still be provided later.
	incomplete1: {
		x: matchN(1, [{foo!: string}])
		x: bar: 2
	}
	// foo could still be provided later.
	incomplete2: {
		x: matchN(1, [{foo!: string}])
	}
	// in case of doubt, we should mark an error as incomplete to be safe.
	incomplete3: {
		x: matchN(math.MultipleOf(2), [{bar!: int}, {foo!: int}])
		x: bar: 2
	}
	incomplete4: {
		x: matchN(math.MultipleOf(2), [{bar!: int}, {foo!: int}, {baz!: int}])
		x: bar: 2
	}
	incomplete5: {
		x: matchN(>1 & <=3, [{bar!: int}, {foo!: int}, {baz!: int}])
		x: bar: 2
	}
	incomplete6: {
		x: matchN(2|3, [{bar!: int}, {foo!: int}, {baz!: int}])
		x: bar: 2
	}

	// incorrect type cannot be corrected
	err1: {
		x: matchN(1, [{bar!: string}])
		x: bar: 2
	}
	// additional incomplete matches should not be counted if they can otherwise
	// not satisfy the constraint.
	err2: {
		x: matchN(0, [{bar!: int}, {foo!: int}])
		x: bar: 2
	}
	// additional incomplete matches should not be counted if they can otherwise
	// not satisfy the constraint.
	err3: {
		x: matchN(2, [{bar!: string}, {foo!: string}])
		x: bar: 2
	}
	// one additional potential match cannot make up to satisfy the bound.
	err4: {
		x: matchN(>1, [{bar!: string}, {foo!: string}])
		x: bar: 2
	}
	err5: {
		x: matchN(<1, [{bar!: int}, {foo!: int}])
		x: bar: 2
	}
}
issue3389: {
	// only report schema errors that are of a lesser severity.
	x: bar: 2
	x: matchN(1, [{bar: 3}, {bar: 2, foo!: int}])
}
-- issue3694.cue --
issue3694: full: {
	#step: matchN(1, [{
		uses!: _
		...
	}, {
		run!: _
		...
	}])
	#step: close({
		uses?: string
		run?:  string
	})

	s: #step & {
		run: "echo hello world"
	}
}
issue3694: simple: {
	#step: matchN(1, [{
		uses!: _
	}])
	#step: close({
		uses?: string
	})
}
-- out/eval/stats --
Leaks:  19
Freed:  774
Reused: 767
Allocs: 26
Retain: 76

Unifications: 777
Conjuncts:    1292
Disjuncts:    851
-- out/eval --
Errors:
incomplete.err1.x.bar: conflicting values 2 and string (mismatched types int and string):
    ./incomplete.cue:34:24
    ./incomplete.cue:35:11
incomplete.err3.x.bar: conflicting values 2 and string (mismatched types int and string):
    ./incomplete.cue:46:24
    ./incomplete.cue:47:11
incomplete.err4.x.bar: conflicting values 2 and string (mismatched types int and string):
    ./incomplete.cue:51:25
    ./incomplete.cue:52:11
match.defaults.pickNested1Err.a: conflicting values 2 and 3:
    ./in.cue:36:23
    ./in.cue:36:38
    ./in.cue:39:23
match.incompleteErr.a: conflicting values string and int (mismatched types string and int):
    ./in.cue:4:5
    ./in.cue:12:21
    ./in.cue:12:32
    ./in.cue:14:20
match.singleErr.a: conflicting values "foo" and int (mismatched types string and int):
    ./in.cue:4:5
    ./in.cue:8:17
    ./in.cue:8:28
    ./in.cue:10:16
match.singleErr: invalid value {a:"foo"} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:8:17
    ./in.cue:8:24
    ./in.cue:10:13
match.incompleteErr: invalid value {a:string} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:12:21
    ./in.cue:12:28
    ./in.cue:14:17
match.defaults.pickNested1Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:36:23
    ./in.cue:36:30
    ./in.cue:39:19
match.defaults.pickNested2Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:41:23
    ./in.cue:41:30
    ./in.cue:44:19
match.defaults.pickNested2Err.a: invalid value 3 (out of bound <=2):
    ./in.cue:41:38
    ./in.cue:44:23
not.singleErr: invalid value {a:2} (does not satisfy matchN): 1 matched, expected 0:
    ./in.cue:74:17
    ./in.cue:74:24
    ./in.cue:76:13
not.doubleErr: invalid value {a:"foo"} (does not satisfy matchN): 1 matched, expected 0:
    ./in.cue:78:17
    ./in.cue:78:24
    ./in.cue:80:13
oneOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:84:20
    ./in.cue:84:27
    ./in.cue:86:17
oneOf.multiple1Err2: invalid value 15 (does not satisfy matchN): 2 matched, expected 1:
    ./in.cue:84:20
    ./in.cue:84:27
    ./in.cue:91:17
oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
    ./in.cue:84:31
    ./in.cue:84:20
    ./in.cue:84:47
    ./in.cue:86:17
oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
    ./in.cue:84:51
    ./in.cue:84:20
    ./in.cue:84:67
    ./in.cue:86:17
anyOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected >0:
    ./in.cue:95:20
    ./in.cue:95:27
    ./in.cue:97:17
anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
    ./in.cue:95:32
    ./in.cue:95:20
    ./in.cue:95:48
    ./in.cue:97:17
anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
    ./in.cue:95:52
    ./in.cue:95:20
    ./in.cue:95:68
    ./in.cue:97:17
allOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 2:
    ./in.cue:106:20
    ./in.cue:106:27
    ./in.cue:108:17
allOf.multiple1Err2: invalid value 3 (does not satisfy matchN): 1 matched, expected 2:
    ./in.cue:106:20
    ./in.cue:106:27
    ./in.cue:109:17
allOf.multiple1Err3: invalid value 5 (does not satisfy matchN): 1 matched, expected 2:
    ./in.cue:106:20
    ./in.cue:106:27
    ./in.cue:110:17
allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
    ./in.cue:106:31
    ./in.cue:106:20
    ./in.cue:106:47
    ./in.cue:108:17
allOf.multiple1Err3: invalid value 5 (does not satisfy math.MultipleOf(3)):
    ./in.cue:106:31
    ./in.cue:106:20
    ./in.cue:106:47
    ./in.cue:110:17
allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
    ./in.cue:106:51
    ./in.cue:106:20
    ./in.cue:106:67
    ./in.cue:108:17
allOf.multiple1Err2: invalid value 3 (does not satisfy math.MultipleOf(5)):
    ./in.cue:106:51
    ./in.cue:106:20
    ./in.cue:106:67
    ./in.cue:109:17
issue3575.test1.x: invalid value [{a:1}] (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:153:7
    ./in.cue:153:14
    ./in.cue:156:6
    ./in.cue:157:6
issue3575.test1.x.0.a: field not allowed:
    ./in.cue:153:7
    ./in.cue:154:4
    ./in.cue:154:5
    ./in.cue:156:6
    ./in.cue:157:8
incomplete.err1.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
    ./incomplete.cue:34:6
    ./incomplete.cue:34:13
    ./incomplete.cue:35:6
incomplete.err2.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected 0:
    ./incomplete.cue:40:6
    ./incomplete.cue:40:13
    ./incomplete.cue:41:6
incomplete.err3.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 2:
    ./incomplete.cue:46:6
    ./incomplete.cue:46:13
    ./incomplete.cue:47:6
incomplete.err4.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected >1:
    ./incomplete.cue:51:6
    ./incomplete.cue:51:13
    ./incomplete.cue:52:6
incomplete.err5.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected <1:
    ./incomplete.cue:55:6
    ./incomplete.cue:55:13
    ./incomplete.cue:56:6

Result:
(_|_){
  // [eval]
  #Foo: (#struct){
    a: (int){ int }
  }
  match: (_|_){
    // [eval]
    singleOK: (struct){
      a: (int){ 2 }
    }
    singleErr: (_|_){
      // [eval] match.singleErr.a: conflicting values "foo" and int (mismatched types string and int):
      //     ./in.cue:4:5
      //     ./in.cue:8:17
      //     ./in.cue:8:28
      //     ./in.cue:10:16
      // match.singleErr: invalid value {a:"foo"} (does not satisfy matchN): 0 matched, expected 1:
      //     ./in.cue:8:17
      //     ./in.cue:8:24
      //     ./in.cue:10:13
      a: (string){ "foo" }
    }
    incompleteOK: (struct){
      a: (int){ int }
    }
    incompleteErr: (_|_){
      // [eval] match.incompleteErr.a: conflicting values string and int (mismatched types string and int):
      //     ./in.cue:4:5
      //     ./in.cue:12:21
      //     ./in.cue:12:32
      //     ./in.cue:14:20
      // match.incompleteErr: invalid value {a:string} (does not satisfy matchN): 0 matched, expected 1:
      //     ./in.cue:12:21
      //     ./in.cue:12:28
      //     ./in.cue:14:17
      a: (string){ string }
    }
    #A: (#struct){
      a: (int){ int }
      b: (_){ _ }
    }
    defaults: (_|_){
      // [eval]
      pickTopOK1: (int){ |(*(int){ 2 }, (int){ &(matchN(1, (#list){
            0: (int){ 2 }
          }), int) }) }
      pickTopOK2: (int){ &(matchN(1, (#list){
          0: (_|_){// 2
          }
        }), int) }
      pickTopErr: (int){ &(matchN(1, (#list){
          0: (int){ 2 }
        }), int) }
      pickNested1OK1: (struct){
        a: (int){ |(*(int){ 2 }, (int){ int }) }
      }
      pickNested1OK2: (struct){
        a: (int){ int }
      }
      pickNested1Err: (_|_){
        // [eval] match.defaults.pickNested1Err.a: conflicting values 2 and 3:
        //     ./in.cue:36:23
        //     ./in.cue:36:38
        //     ./in.cue:39:23
        // match.defaults.pickNested1Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
        //     ./in.cue:36:23
        //     ./in.cue:36:30
        //     ./in.cue:39:19
        a: (int){ |(*(int){ 3 }, (int){ int }) }
      }
      pickNested2OK1: (struct){
        a: (int){ |(*(int){ 2 }, (int){ int }) }
      }
      pickNested2OK2: (struct){
        a: (int){ int }
      }
      pickNested2Err: (_|_){
        // [eval] match.defaults.pickNested2Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
        //     ./in.cue:41:23
        //     ./in.cue:41:30
        //     ./in.cue:44:19
        // match.defaults.pickNested2Err.a: invalid value 3 (out of bound <=2):
        //     ./in.cue:41:38
        //     ./in.cue:44:23
        a: (int){ |(*(int){ 3 }, (int){ int }) }
      }
    }
    nestedOK: (struct){
      a: (int){ 2 }
      b: (struct){
        a: (int){ 3 }
        b: (struct){
          a: (int){ 4 }
        }
        c: (struct){
          a: (int){ 5 }
        }
      }
      c: (struct){
        a: (int){ 3 }
        b: (struct){
          a: (int){ 4 }
        }
        c: (struct){
          a: (int){ 5 }
        }
      }
    }
  }
  not: (_|_){
    // [eval]
    singleOK: (struct){
      a: (string){ "foo" }
    }
    singleErr: (_|_){
      // [eval] not.singleErr: invalid value {a:2} (does not satisfy matchN): 1 matched, expected 0:
      //     ./in.cue:74:17
      //     ./in.cue:74:24
      //     ./in.cue:76:13
      a: (int){ 2 }
    }
    doubleOK: (struct){
      a: (int){ 2 }
    }
    doubleErr: (_|_){
      // [eval] not.doubleErr: invalid value {a:"foo"} (does not satisfy matchN): 1 matched, expected 0:
      //     ./in.cue:78:17
      //     ./in.cue:78:24
      //     ./in.cue:80:13
      a: (string){ "foo" }
    }
  }
  oneOf: (_|_){
    // [eval]
    multiple1Err1: (_|_){
      // [eval] oneOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 1:
      //     ./in.cue:84:20
      //     ./in.cue:84:27
      //     ./in.cue:86:17
      // oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:84:31
      //     ./in.cue:84:20
      //     ./in.cue:84:47
      //     ./in.cue:86:17
      // oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:84:51
      //     ./in.cue:84:20
      //     ./in.cue:84:67
      //     ./in.cue:86:17
    }
    multiple1OK1: (int){ 3 }
    multiple1OK2: (int){ 5 }
    multiple1Err2: (_|_){
      // [eval] oneOf.multiple1Err2: invalid value 15 (does not satisfy matchN): 2 matched, expected 1:
      //     ./in.cue:84:20
      //     ./in.cue:84:27
      //     ./in.cue:91:17
    }
  }
  anyOf: (_|_){
    // [eval]
    multiple1Err1: (_|_){
      // [eval] anyOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected >0:
      //     ./in.cue:95:20
      //     ./in.cue:95:27
      //     ./in.cue:97:17
      // anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:95:32
      //     ./in.cue:95:20
      //     ./in.cue:95:48
      //     ./in.cue:97:17
      // anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:95:52
      //     ./in.cue:95:20
      //     ./in.cue:95:68
      //     ./in.cue:97:17
    }
    multiple1OK1: (int){ 3 }
    multiple1OK2: (int){ 5 }
    multiple1OK3: (int){ 15 }
  }
  allOf: (_|_){
    // [eval]
    multiple1Err1: (_|_){
      // [eval] allOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 2:
      //     ./in.cue:106:20
      //     ./in.cue:106:27
      //     ./in.cue:108:17
      // allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:106:31
      //     ./in.cue:106:20
      //     ./in.cue:106:47
      //     ./in.cue:108:17
      // allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:106:51
      //     ./in.cue:106:20
      //     ./in.cue:106:67
      //     ./in.cue:108:17
    }
    multiple1Err2: (_|_){
      // [eval] allOf.multiple1Err2: invalid value 3 (does not satisfy matchN): 1 matched, expected 2:
      //     ./in.cue:106:20
      //     ./in.cue:106:27
      //     ./in.cue:109:17
      // allOf.multiple1Err2: invalid value 3 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:106:51
      //     ./in.cue:106:20
      //     ./in.cue:106:67
      //     ./in.cue:109:17
    }
    multiple1Err3: (_|_){
      // [eval] allOf.multiple1Err3: invalid value 5 (does not satisfy matchN): 1 matched, expected 2:
      //     ./in.cue:106:20
      //     ./in.cue:106:27
      //     ./in.cue:110:17
      // allOf.multiple1Err3: invalid value 5 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:106:31
      //     ./in.cue:106:20
      //     ./in.cue:106:47
      //     ./in.cue:110:17
    }
    multiple1OK1: (int){ 15 }
  }
  bare: (struct){
    embed: (struct){
      t1: (struct){
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
      t2: (struct){
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
    }
    direct: (struct){
      t1: (struct){
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
      t2: (struct){
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
    }
  }
  required: (struct){
    ok1: (struct){
      x: (struct){
        bar: (int){ 2 }
      }
    }
    ok2: (struct){
      x: (_){ matchN(0, (#list){
          0: (_|_){// {
            //   foo!: string
            // }
          }
        }) }
    }
    ok3: (struct){
      x: (struct){
        bar: (int){ 2 }
      }
    }
  }
  issue3575: (_|_){
    // [eval]
    test1: (_|_){
      // [eval]
      #x: (_){ matchN(1, (#list){
          0: (_|_){// [
            //   {},
            // ]
          }
        }) }
      x: (_|_){
        // [eval] issue3575.test1.x: invalid value [{a:1}] (does not satisfy matchN): 0 matched, expected 1:
        //     ./in.cue:153:7
        //     ./in.cue:153:14
        //     ./in.cue:156:6
        //     ./in.cue:157:6
        // issue3575.test1.x.0.a: field not allowed:
        //     ./in.cue:153:7
        //     ./in.cue:154:4
        //     ./in.cue:154:5
        //     ./in.cue:156:6
        //     ./in.cue:157:8
        0: (struct){
          a: (int){ 1 }
        }
      }
    }
    test2: (struct){
      #x: (_){ matchN(1, (#list){
          0: (_|_){// {}
          }
        }) }
      x: (struct){
        a: (int){ 1 }
      }
    }
  }
  incomplete: (_|_){
    // [eval]
    incomplete1: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete1.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
        //     ./incomplete.cue:7:6
        //     ./incomplete.cue:7:13
        //     ./incomplete.cue:8:6
        // incomplete.incomplete1.x.foo: field is required but not present:
        //     ./incomplete.cue:7:6
        //     ./incomplete.cue:7:18
        bar: (int){ 2 }
      }
    }
    incomplete2: (struct){
      x: (_){ matchN(1, (#list){
          0: (_|_){// {
            //   foo!: string
            // }
          }
        }) }
    }
    incomplete3: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete3.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected math.MultipleOf(2):
        //     ./incomplete.cue:16:6
        //     ./incomplete.cue:16:13
        //     ./incomplete.cue:17:6
        // incomplete.incomplete3.x.foo: field is required but not present:
        //     ./incomplete.cue:16:6
        //     ./incomplete.cue:16:48
        bar: (int){ 2 }
      }
    }
    incomplete4: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete4.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected math.MultipleOf(2):
        //     ./incomplete.cue:20:6
        //     ./incomplete.cue:20:13
        //     ./incomplete.cue:21:6
        // incomplete.incomplete4.x.baz: field is required but not present:
        //     ./incomplete.cue:20:6
        //     ./incomplete.cue:20:61
        // incomplete.incomplete4.x.foo: field is required but not present:
        //     ./incomplete.cue:20:6
        //     ./incomplete.cue:20:48
        bar: (int){ 2 }
      }
    }
    incomplete5: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete5.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected >1 & <=3:
        //     ./incomplete.cue:24:6
        //     ./incomplete.cue:24:13
        //     ./incomplete.cue:25:6
        // incomplete.incomplete5.x.baz: field is required but not present:
        //     ./incomplete.cue:24:6
        //     ./incomplete.cue:24:51
        // incomplete.incomplete5.x.foo: field is required but not present:
        //     ./incomplete.cue:24:6
        //     ./incomplete.cue:24:38
        bar: (int){ 2 }
      }
    }
    incomplete6: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete6.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected 2 | 3:
        //     ./incomplete.cue:28:6
        //     ./incomplete.cue:28:13
        //     ./incomplete.cue:29:6
        // incomplete.incomplete6.x.baz: field is required but not present:
        //     ./incomplete.cue:28:6
        //     ./incomplete.cue:28:46
        // incomplete.incomplete6.x.foo: field is required but not present:
        //     ./incomplete.cue:28:6
        //     ./incomplete.cue:28:33
        bar: (int){ 2 }
      }
    }
    err1: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err1.x.bar: conflicting values 2 and string (mismatched types int and string):
        //     ./incomplete.cue:34:24
        //     ./incomplete.cue:35:11
        // incomplete.err1.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
        //     ./incomplete.cue:34:6
        //     ./incomplete.cue:34:13
        //     ./incomplete.cue:35:6
        bar: (int){ 2 }
      }
    }
    err2: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err2.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected 0:
        //     ./incomplete.cue:40:6
        //     ./incomplete.cue:40:13
        //     ./incomplete.cue:41:6
        bar: (int){ 2 }
      }
    }
    err3: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err3.x.bar: conflicting values 2 and string (mismatched types int and string):
        //     ./incomplete.cue:46:24
        //     ./incomplete.cue:47:11
        // incomplete.err3.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 2:
        //     ./incomplete.cue:46:6
        //     ./incomplete.cue:46:13
        //     ./incomplete.cue:47:6
        bar: (int){ 2 }
      }
    }
    err4: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err4.x.bar: conflicting values 2 and string (mismatched types int and string):
        //     ./incomplete.cue:51:25
        //     ./incomplete.cue:52:11
        // incomplete.err4.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected >1:
        //     ./incomplete.cue:51:6
        //     ./incomplete.cue:51:13
        //     ./incomplete.cue:52:6
        bar: (int){ 2 }
      }
    }
    err5: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err5.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected <1:
        //     ./incomplete.cue:55:6
        //     ./incomplete.cue:55:13
        //     ./incomplete.cue:56:6
        bar: (int){ 2 }
      }
    }
  }
  issue3389: (struct){
    x: (_|_){
      // [incomplete] issue3389.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
      //     ./incomplete.cue:62:5
      //     ./incomplete.cue:61:5
      //     ./incomplete.cue:62:12
      // issue3389.x.foo: field is required but not present:
      //     ./incomplete.cue:62:5
      //     ./incomplete.cue:62:35
      bar: (int){ 2 }
    }
  }
  issue3694: (struct){
    full: (struct){
      #step: (_|_){
        // [incomplete] issue3694.full.#step: invalid value {uses?:string,run?:string} (does not satisfy matchN): 0 matched, expected 1:
        //     ./issue3694.cue:2:9
        //     ./issue3694.cue:2:16
        //     ./issue3694.cue:9:9
        // issue3694.full.#step.run: field is required but not present:
        //     ./issue3694.cue:2:9
        //     ./issue3694.cue:6:3
        // issue3694.full.#step.uses: field is required but not present:
        //     ./issue3694.cue:2:9
        //     ./issue3694.cue:3:3
        uses?: (string){ string }
        run?: (string){ string }
      }
      s: (#struct){
        uses?: (string){ string }
        run: (string){ "echo hello world" }
      }
    }
    simple: (struct){
      #step: (_|_){
        // [incomplete] issue3694.simple.#step: invalid value {uses?:string} (does not satisfy matchN): 0 matched, expected 1:
        //     ./issue3694.cue:19:9
        //     ./issue3694.cue:19:16
        //     ./issue3694.cue:22:9
        // issue3694.simple.#step.uses: field is required but not present:
        //     ./issue3694.cue:19:9
        //     ./issue3694.cue:20:3
        uses?: (string){ string }
      }
    }
  }
}
-- out/evalalpha --
Errors:
incomplete.err1.x.bar: conflicting values 2 and string (mismatched types int and string):
    ./incomplete.cue:34:24
    ./incomplete.cue:35:11
incomplete.err3.x.bar: conflicting values 2 and string (mismatched types int and string):
    ./incomplete.cue:46:24
    ./incomplete.cue:47:11
incomplete.err4.x.bar: conflicting values 2 and string (mismatched types int and string):
    ./incomplete.cue:51:25
    ./incomplete.cue:52:11
match.defaults.pickNested1Err.a: conflicting values 2 and 3:
    ./in.cue:36:38
    ./in.cue:39:23
match.incompleteErr.a: conflicting values string and int (mismatched types string and int):
    ./in.cue:4:5
    ./in.cue:14:20
match.singleErr.a: conflicting values "foo" and int (mismatched types string and int):
    ./in.cue:4:5
    ./in.cue:10:16
match.singleErr: invalid value {a:"foo"} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:8:17
    ./in.cue:8:24
    ./in.cue:10:13
match.incompleteErr: invalid value {a:string} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:12:21
    ./in.cue:12:28
    ./in.cue:14:17
match.defaults.pickNested1Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:36:23
    ./in.cue:36:30
    ./in.cue:39:19
match.defaults.pickNested2Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:41:23
    ./in.cue:41:30
    ./in.cue:44:19
match.defaults.pickNested2Err.a: invalid value 3 (out of bound <=2):
    ./in.cue:41:38
    ./in.cue:44:23
not.singleErr: invalid value {a:2} (does not satisfy matchN): 1 matched, expected 0:
    ./in.cue:74:17
    ./in.cue:74:24
    ./in.cue:76:13
not.doubleErr: invalid value {a:"foo"} (does not satisfy matchN): 1 matched, expected 0:
    ./in.cue:78:17
    ./in.cue:78:24
    ./in.cue:80:13
oneOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 1:
    ./in.cue:84:20
    ./in.cue:84:27
    ./in.cue:86:17
oneOf.multiple1Err2: invalid value 15 (does not satisfy matchN): 2 matched, expected 1:
    ./in.cue:84:20
    ./in.cue:84:27
    ./in.cue:91:17
oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
    ./in.cue:84:31
    ./in.cue:84:20
    ./in.cue:84:47
    ./in.cue:86:17
oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
    ./in.cue:84:51
    ./in.cue:84:20
    ./in.cue:84:67
    ./in.cue:86:17
anyOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected >0:
    ./in.cue:95:20
    ./in.cue:95:27
    ./in.cue:97:17
anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
    ./in.cue:95:32
    ./in.cue:95:20
    ./in.cue:95:48
    ./in.cue:97:17
anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
    ./in.cue:95:52
    ./in.cue:95:20
    ./in.cue:95:68
    ./in.cue:97:17
allOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 2:
    ./in.cue:106:20
    ./in.cue:106:27
    ./in.cue:108:17
allOf.multiple1Err2: invalid value 3 (does not satisfy matchN): 1 matched, expected 2:
    ./in.cue:106:20
    ./in.cue:106:27
    ./in.cue:109:17
allOf.multiple1Err3: invalid value 5 (does not satisfy matchN): 1 matched, expected 2:
    ./in.cue:106:20
    ./in.cue:106:27
    ./in.cue:110:17
allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
    ./in.cue:106:31
    ./in.cue:106:20
    ./in.cue:106:47
    ./in.cue:108:17
allOf.multiple1Err3: invalid value 5 (does not satisfy math.MultipleOf(3)):
    ./in.cue:106:31
    ./in.cue:106:20
    ./in.cue:106:47
    ./in.cue:110:17
allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
    ./in.cue:106:51
    ./in.cue:106:20
    ./in.cue:106:67
    ./in.cue:108:17
allOf.multiple1Err2: invalid value 3 (does not satisfy math.MultipleOf(5)):
    ./in.cue:106:51
    ./in.cue:106:20
    ./in.cue:106:67
    ./in.cue:109:17
incomplete.err1.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
    ./incomplete.cue:34:6
    ./incomplete.cue:34:13
    ./incomplete.cue:35:6
incomplete.err2.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected 0:
    ./incomplete.cue:40:6
    ./incomplete.cue:40:13
    ./incomplete.cue:41:6
incomplete.err3.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 2:
    ./incomplete.cue:46:6
    ./incomplete.cue:46:13
    ./incomplete.cue:47:6
incomplete.err4.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected >1:
    ./incomplete.cue:51:6
    ./incomplete.cue:51:13
    ./incomplete.cue:52:6
incomplete.err5.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected <1:
    ./incomplete.cue:55:6
    ./incomplete.cue:55:13
    ./incomplete.cue:56:6

Result:
(_|_){
  // [eval]
  #Foo: (#struct){
    a: (int){ int }
  }
  match: (_|_){
    // [eval]
    singleOK: (struct){
      a: (int){ 2 }
    }
    singleErr: (_|_){
      // [eval] match.singleErr.a: conflicting values "foo" and int (mismatched types string and int):
      //     ./in.cue:4:5
      //     ./in.cue:10:16
      // match.singleErr: invalid value {a:"foo"} (does not satisfy matchN): 0 matched, expected 1:
      //     ./in.cue:8:17
      //     ./in.cue:8:24
      //     ./in.cue:10:13
      a: (string){ "foo" }
    }
    incompleteOK: (struct){
      a: (int){ int }
    }
    incompleteErr: (_|_){
      // [eval] match.incompleteErr.a: conflicting values string and int (mismatched types string and int):
      //     ./in.cue:4:5
      //     ./in.cue:14:20
      // match.incompleteErr: invalid value {a:string} (does not satisfy matchN): 0 matched, expected 1:
      //     ./in.cue:12:21
      //     ./in.cue:12:28
      //     ./in.cue:14:17
      a: (string){ string }
    }
    #A: (#struct){
      a: (int){ int }
      b: (_){ _ }
    }
    defaults: (_|_){
      // [eval]
      pickTopOK1: (int){ |(*(int){ 2 }, (int){ &(matchN(1, (#list){
            0: (int){ 2 }
          }), int) }) }
      pickTopOK2: (int){ &(matchN(1, (#list){
          0: (_|_){// 2
          }
        }), int) }
      pickTopErr: (int){ &(matchN(1, (#list){
          0: (int){ 2 }
        }), int) }
      pickNested1OK1: (struct){
        a: (int){ |(*(int){ 2 }, (int){ int }) }
      }
      pickNested1OK2: (struct){
        a: (int){ int }
      }
      pickNested1Err: (_|_){
        // [eval] match.defaults.pickNested1Err.a: conflicting values 2 and 3:
        //     ./in.cue:36:38
        //     ./in.cue:39:23
        // match.defaults.pickNested1Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
        //     ./in.cue:36:23
        //     ./in.cue:36:30
        //     ./in.cue:39:19
        a: (int){ |(*(int){ 3 }, (int){ int }) }
      }
      pickNested2OK1: (struct){
        a: (int){ |(*(int){ 2 }, (int){ int }) }
      }
      pickNested2OK2: (struct){
        a: (int){ int }
      }
      pickNested2Err: (_|_){
        // [eval] match.defaults.pickNested2Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
        //     ./in.cue:41:23
        //     ./in.cue:41:30
        //     ./in.cue:44:19
        // match.defaults.pickNested2Err.a: invalid value 3 (out of bound <=2):
        //     ./in.cue:41:38
        //     ./in.cue:44:23
        a: (int){ |(*(int){ 3 }, (int){ int }) }
      }
    }
    nestedOK: (struct){
      a: (int){ 2 }
      b: (struct){
        a: (int){ 3 }
        b: (struct){
          a: (int){ 4 }
        }
        c: (struct){
          a: (int){ 5 }
        }
      }
      c: (struct){
        a: (int){ 3 }
        b: (struct){
          a: (int){ 4 }
        }
        c: (struct){
          a: (int){ 5 }
        }
      }
    }
  }
  not: (_|_){
    // [eval]
    singleOK: (struct){
      a: (string){ "foo" }
    }
    singleErr: (_|_){
      // [eval] not.singleErr: invalid value {a:2} (does not satisfy matchN): 1 matched, expected 0:
      //     ./in.cue:74:17
      //     ./in.cue:74:24
      //     ./in.cue:76:13
      a: (int){ 2 }
    }
    doubleOK: (struct){
      a: (int){ 2 }
    }
    doubleErr: (_|_){
      // [eval] not.doubleErr: invalid value {a:"foo"} (does not satisfy matchN): 1 matched, expected 0:
      //     ./in.cue:78:17
      //     ./in.cue:78:24
      //     ./in.cue:80:13
      a: (string){ "foo" }
    }
  }
  oneOf: (_|_){
    // [eval]
    multiple1Err1: (_|_){
      // [eval] oneOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 1:
      //     ./in.cue:84:20
      //     ./in.cue:84:27
      //     ./in.cue:86:17
      // oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:84:31
      //     ./in.cue:84:20
      //     ./in.cue:84:47
      //     ./in.cue:86:17
      // oneOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:84:51
      //     ./in.cue:84:20
      //     ./in.cue:84:67
      //     ./in.cue:86:17
    }
    multiple1OK1: (int){ 3 }
    multiple1OK2: (int){ 5 }
    multiple1Err2: (_|_){
      // [eval] oneOf.multiple1Err2: invalid value 15 (does not satisfy matchN): 2 matched, expected 1:
      //     ./in.cue:84:20
      //     ./in.cue:84:27
      //     ./in.cue:91:17
    }
  }
  anyOf: (_|_){
    // [eval]
    multiple1Err1: (_|_){
      // [eval] anyOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected >0:
      //     ./in.cue:95:20
      //     ./in.cue:95:27
      //     ./in.cue:97:17
      // anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:95:32
      //     ./in.cue:95:20
      //     ./in.cue:95:48
      //     ./in.cue:97:17
      // anyOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:95:52
      //     ./in.cue:95:20
      //     ./in.cue:95:68
      //     ./in.cue:97:17
    }
    multiple1OK1: (int){ 3 }
    multiple1OK2: (int){ 5 }
    multiple1OK3: (int){ 15 }
  }
  allOf: (_|_){
    // [eval]
    multiple1Err1: (_|_){
      // [eval] allOf.multiple1Err1: invalid value 1 (does not satisfy matchN): 0 matched, expected 2:
      //     ./in.cue:106:20
      //     ./in.cue:106:27
      //     ./in.cue:108:17
      // allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:106:31
      //     ./in.cue:106:20
      //     ./in.cue:106:47
      //     ./in.cue:108:17
      // allOf.multiple1Err1: invalid value 1 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:106:51
      //     ./in.cue:106:20
      //     ./in.cue:106:67
      //     ./in.cue:108:17
    }
    multiple1Err2: (_|_){
      // [eval] allOf.multiple1Err2: invalid value 3 (does not satisfy matchN): 1 matched, expected 2:
      //     ./in.cue:106:20
      //     ./in.cue:106:27
      //     ./in.cue:109:17
      // allOf.multiple1Err2: invalid value 3 (does not satisfy math.MultipleOf(5)):
      //     ./in.cue:106:51
      //     ./in.cue:106:20
      //     ./in.cue:106:67
      //     ./in.cue:109:17
    }
    multiple1Err3: (_|_){
      // [eval] allOf.multiple1Err3: invalid value 5 (does not satisfy matchN): 1 matched, expected 2:
      //     ./in.cue:106:20
      //     ./in.cue:106:27
      //     ./in.cue:110:17
      // allOf.multiple1Err3: invalid value 5 (does not satisfy math.MultipleOf(3)):
      //     ./in.cue:106:31
      //     ./in.cue:106:20
      //     ./in.cue:106:47
      //     ./in.cue:110:17
    }
    multiple1OK1: (int){ 15 }
  }
  bare: (struct){
    embed: (struct){
      t1: (struct){
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
      t2: (struct){
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
    }
    direct: (struct){
      t1: (struct){
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
      t2: (struct){
        b: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
        a: (_){ matchN(1, (#list){
            0: (_|_){// >10
            }
          }) }
      }
    }
  }
  required: (struct){
    ok1: (struct){
      x: (struct){
        bar: (int){ 2 }
      }
    }
    ok2: (struct){
      x: (_){ matchN(0, (#list){
          0: (_|_){// {
            //   foo!: string
            // }
          }
        }) }
    }
    ok3: (struct){
      x: (struct){
        bar: (int){ 2 }
      }
    }
  }
  issue3575: (struct){
    test1: (struct){
      #x: (_){ matchN(1, (#list){
          0: (_|_){// [
            //   {},
            // ]
          }
        }) }
      x: (#list){
        0: (#struct){
          a: (int){ 1 }
        }
      }
    }
    test2: (struct){
      #x: (_){ matchN(1, (#list){
          0: (_|_){// {}
          }
        }) }
      x: (#struct){
        a: (int){ 1 }
      }
    }
  }
  incomplete: (_|_){
    // [eval]
    incomplete1: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete1.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
        //     ./incomplete.cue:7:6
        //     ./incomplete.cue:7:13
        //     ./incomplete.cue:8:6
        // incomplete.incomplete1.x.foo: field is required but not present:
        //     ./incomplete.cue:7:6
        //     ./incomplete.cue:7:18
        bar: (int){ 2 }
      }
    }
    incomplete2: (struct){
      x: (_){ matchN(1, (#list){
          0: (_|_){// {
            //   foo!: string
            // }
          }
        }) }
    }
    incomplete3: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete3.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected math.MultipleOf(2):
        //     ./incomplete.cue:16:6
        //     ./incomplete.cue:16:13
        //     ./incomplete.cue:17:6
        // incomplete.incomplete3.x.foo: field is required but not present:
        //     ./incomplete.cue:16:6
        //     ./incomplete.cue:16:48
        bar: (int){ 2 }
      }
    }
    incomplete4: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete4.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected math.MultipleOf(2):
        //     ./incomplete.cue:20:6
        //     ./incomplete.cue:20:13
        //     ./incomplete.cue:21:6
        // incomplete.incomplete4.x.baz: field is required but not present:
        //     ./incomplete.cue:20:6
        //     ./incomplete.cue:20:61
        // incomplete.incomplete4.x.foo: field is required but not present:
        //     ./incomplete.cue:20:6
        //     ./incomplete.cue:20:48
        bar: (int){ 2 }
      }
    }
    incomplete5: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete5.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected >1 & <=3:
        //     ./incomplete.cue:24:6
        //     ./incomplete.cue:24:13
        //     ./incomplete.cue:25:6
        // incomplete.incomplete5.x.baz: field is required but not present:
        //     ./incomplete.cue:24:6
        //     ./incomplete.cue:24:51
        // incomplete.incomplete5.x.foo: field is required but not present:
        //     ./incomplete.cue:24:6
        //     ./incomplete.cue:24:38
        bar: (int){ 2 }
      }
    }
    incomplete6: (struct){
      x: (_|_){
        // [incomplete] incomplete.incomplete6.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected 2 | 3:
        //     ./incomplete.cue:28:6
        //     ./incomplete.cue:28:13
        //     ./incomplete.cue:29:6
        // incomplete.incomplete6.x.baz: field is required but not present:
        //     ./incomplete.cue:28:6
        //     ./incomplete.cue:28:46
        // incomplete.incomplete6.x.foo: field is required but not present:
        //     ./incomplete.cue:28:6
        //     ./incomplete.cue:28:33
        bar: (int){ 2 }
      }
    }
    err1: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err1.x.bar: conflicting values 2 and string (mismatched types int and string):
        //     ./incomplete.cue:34:24
        //     ./incomplete.cue:35:11
        // incomplete.err1.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
        //     ./incomplete.cue:34:6
        //     ./incomplete.cue:34:13
        //     ./incomplete.cue:35:6
        bar: (int){ 2 }
      }
    }
    err2: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err2.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected 0:
        //     ./incomplete.cue:40:6
        //     ./incomplete.cue:40:13
        //     ./incomplete.cue:41:6
        bar: (int){ 2 }
      }
    }
    err3: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err3.x.bar: conflicting values 2 and string (mismatched types int and string):
        //     ./incomplete.cue:46:24
        //     ./incomplete.cue:47:11
        // incomplete.err3.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 2:
        //     ./incomplete.cue:46:6
        //     ./incomplete.cue:46:13
        //     ./incomplete.cue:47:6
        bar: (int){ 2 }
      }
    }
    err4: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err4.x.bar: conflicting values 2 and string (mismatched types int and string):
        //     ./incomplete.cue:51:25
        //     ./incomplete.cue:52:11
        // incomplete.err4.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected >1:
        //     ./incomplete.cue:51:6
        //     ./incomplete.cue:51:13
        //     ./incomplete.cue:52:6
        bar: (int){ 2 }
      }
    }
    err5: (_|_){
      // [eval]
      x: (_|_){
        // [eval] incomplete.err5.x: invalid value {bar:2} (does not satisfy matchN): 1 matched, expected <1:
        //     ./incomplete.cue:55:6
        //     ./incomplete.cue:55:13
        //     ./incomplete.cue:56:6
        bar: (int){ 2 }
      }
    }
  }
  issue3389: (struct){
    x: (_|_){
      // [incomplete] issue3389.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
      //     ./incomplete.cue:62:5
      //     ./incomplete.cue:61:5
      //     ./incomplete.cue:62:12
      // issue3389.x.foo: field is required but not present:
      //     ./incomplete.cue:62:5
      //     ./incomplete.cue:62:35
      bar: (int){ 2 }
    }
  }
  issue3694: (struct){
    full: (struct){
      #step: (_|_){
        // [incomplete] issue3694.full.#step: invalid value {uses?:string,run?:string} (does not satisfy matchN): 0 matched, expected 1:
        //     ./issue3694.cue:2:9
        //     ./issue3694.cue:2:16
        //     ./issue3694.cue:9:9
        // issue3694.full.#step.run: field is required but not present:
        //     ./issue3694.cue:2:9
        //     ./issue3694.cue:6:3
        // issue3694.full.#step.uses: field is required but not present:
        //     ./issue3694.cue:2:9
        //     ./issue3694.cue:3:3
        uses?: (string){ string }
        run?: (string){ string }
      }
      s: (#struct){
        run: (string){ "echo hello world" }
        uses?: (string){ string }
      }
    }
    simple: (struct){
      #step: (_|_){
        // [incomplete] issue3694.simple.#step: invalid value {uses?:string} (does not satisfy matchN): 0 matched, expected 1:
        //     ./issue3694.cue:19:9
        //     ./issue3694.cue:19:16
        //     ./issue3694.cue:22:9
        // issue3694.simple.#step.uses: field is required but not present:
        //     ./issue3694.cue:19:9
        //     ./issue3694.cue:20:3
        uses?: (string){ string }
      }
    }
  }
}
-- diff/-out/evalalpha<==>+out/eval --
diff old new
--- old
+++ new
@@ -9,18 +9,13 @@
     ./incomplete.cue:51:25
     ./incomplete.cue:52:11
 match.defaults.pickNested1Err.a: conflicting values 2 and 3:
-    ./in.cue:36:23
     ./in.cue:36:38
     ./in.cue:39:23
 match.incompleteErr.a: conflicting values string and int (mismatched types string and int):
     ./in.cue:4:5
-    ./in.cue:12:21
-    ./in.cue:12:32
     ./in.cue:14:20
 match.singleErr.a: conflicting values "foo" and int (mismatched types string and int):
     ./in.cue:4:5
-    ./in.cue:8:17
-    ./in.cue:8:28
     ./in.cue:10:16
 match.singleErr: invalid value {a:"foo"} (does not satisfy matchN): 0 matched, expected 1:
     ./in.cue:8:17
@@ -113,17 +108,6 @@
     ./in.cue:106:20
     ./in.cue:106:67
     ./in.cue:109:17
-issue3575.test1.x: invalid value [{a:1}] (does not satisfy matchN): 0 matched, expected 1:
-    ./in.cue:153:7
-    ./in.cue:153:14
-    ./in.cue:156:6
-    ./in.cue:157:6
-issue3575.test1.x.0.a: field not allowed:
-    ./in.cue:153:7
-    ./in.cue:154:4
-    ./in.cue:154:5
-    ./in.cue:156:6
-    ./in.cue:157:8
 incomplete.err1.x: invalid value {bar:2} (does not satisfy matchN): 0 matched, expected 1:
     ./incomplete.cue:34:6
     ./incomplete.cue:34:13
@@ -159,8 +143,6 @@
     singleErr: (_|_){
       // [eval] match.singleErr.a: conflicting values "foo" and int (mismatched types string and int):
       //     ./in.cue:4:5
-      //     ./in.cue:8:17
-      //     ./in.cue:8:28
       //     ./in.cue:10:16
       // match.singleErr: invalid value {a:"foo"} (does not satisfy matchN): 0 matched, expected 1:
       //     ./in.cue:8:17
@@ -174,8 +156,6 @@
     incompleteErr: (_|_){
       // [eval] match.incompleteErr.a: conflicting values string and int (mismatched types string and int):
       //     ./in.cue:4:5
-      //     ./in.cue:12:21
-      //     ./in.cue:12:32
       //     ./in.cue:14:20
       // match.incompleteErr: invalid value {a:string} (does not satisfy matchN): 0 matched, expected 1:
       //     ./in.cue:12:21
@@ -207,7 +187,6 @@
       }
       pickNested1Err: (_|_){
         // [eval] match.defaults.pickNested1Err.a: conflicting values 2 and 3:
-        //     ./in.cue:36:23
         //     ./in.cue:36:38
         //     ./in.cue:39:23
         // match.defaults.pickNested1Err: invalid value {a:*3 | int} (does not satisfy matchN): 0 matched, expected 1:
@@ -435,10 +414,8 @@
       }
     }
   }
-  issue3575: (_|_){
-    // [eval]
-    test1: (_|_){
-      // [eval]
+  issue3575: (struct){
+    test1: (struct){
       #x: (_){ matchN(1, (#list){
           0: (_|_){// [
             //   {},
@@ -445,19 +422,8 @@
             // ]
           }
         }) }
-      x: (_|_){
-        // [eval] issue3575.test1.x: invalid value [{a:1}] (does not satisfy matchN): 0 matched, expected 1:
-        //     ./in.cue:153:7
-        //     ./in.cue:153:14
-        //     ./in.cue:156:6
-        //     ./in.cue:157:6
-        // issue3575.test1.x.0.a: field not allowed:
-        //     ./in.cue:153:7
-        //     ./in.cue:154:4
-        //     ./in.cue:154:5
-        //     ./in.cue:156:6
-        //     ./in.cue:157:8
-        0: (struct){
+      x: (#list){
+        0: (#struct){
           a: (int){ 1 }
         }
       }
@@ -467,7 +433,7 @@
           0: (_|_){// {}
           }
         }) }
-      x: (struct){
+      x: (#struct){
         a: (int){ 1 }
       }
     }
@@ -640,8 +606,8 @@
         run?: (string){ string }
       }
       s: (#struct){
-        uses?: (string){ string }
         run: (string){ "echo hello world" }
+        uses?: (string){ string }
       }
     }
     simple: (struct){
-- diff/explanation --
The old evaluator does not correctly handle ToDataAll if a node is
mid-evaluation. The new evaluator does.
issue3575: the old evaluator was incorrect in behaving differently when using structs inside lists
-- diff/todo/p3 --
Missing error positions.
-- out/compile --
--- in.cue
{
  #Foo: {
    a: int
  }
  match: {
    [=~"^single"]: matchN(1, [
      〈2;#Foo〉,
    ])
    singleOK: {
      a: 2
    }
    singleErr: {
      a: "foo"
    }
    [=~"^incomplete"]: matchN(1, [
      〈2;#Foo〉,
    ])
    incompleteOK: {
      a: int
    }
    incompleteErr: {
      a: string
    }
    #A: {
      a: int
      b: _
      ...
    }
    defaults: {
      [=~"^pickTop"]: matchN(1, [
        2,
      ])
      pickTopOK1: (*2|int)
      pickTopOK2: int
      pickTopErr: (*3|int)
      [=~"^pickNested1"]: matchN(1, [
        {
          a: 2
        },
      ])
      pickNested1OK1: {
        a: (*2|int)
      }
      pickNested1OK2: {
        a: int
      }
      pickNested1Err: {
        a: (*3|int)
      }
      [=~"^pickNested2"]: matchN(1, [
        {
          a: <=2
        },
      ])
      pickNested2OK1: {
        a: (*2|int)
      }
      pickNested2OK2: {
        a: int
      }
      pickNested2Err: {
        a: (*3|int)
      }
    }
    nestedOK: {
      matchN(4, [
        〈2;#A〉,
        〈2;#A〉,
        〈2;#A〉,
        〈2;#A〉,
      ])
      a: 2
      b: {
        matchN(4, [
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
        ])
        a: 3
        b: matchN(4, [
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
        ])
        b: {
          a: 4
        }
        c: matchN(4, [
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
        ])
        c: {
          a: 5
        }
      }
      c: {
        matchN(4, [
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
        ])
        a: 3
        b: matchN(4, [
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
        ])
        b: {
          a: 4
        }
        c: matchN(4, [
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
          〈3;#A〉,
        ])
        c: {
          a: 5
        }
      }
    }
  }
  not: {
    [=~"^single"]: matchN(0, [
      〈2;#Foo〉,
    ])
    singleOK: {
      a: "foo"
    }
    singleErr: {
      a: 2
    }
    [=~"^double"]: matchN(0, [
      matchN(0, [
        〈3;#Foo〉,
      ]),
    ])
    doubleOK: {
      a: 2
    }
    doubleErr: {
      a: "foo"
    }
  }
  oneOf: {
    [=~"^multiple1"]: matchN(1, [
      〈import;math〉.MultipleOf(3),
      〈import;math〉.MultipleOf(5),
    ])
    multiple1Err1: 1
    multiple1OK1: 3
    multiple1OK2: 5
    multiple1Err2: 15
  }
  anyOf: {
    [=~"^multiple1"]: matchN(>0, [
      〈import;math〉.MultipleOf(3),
      〈import;math〉.MultipleOf(5),
    ])
    multiple1Err1: 1
    multiple1OK1: 3
    multiple1OK2: 5
    multiple1OK3: 15
  }
  allOf: {
    [=~"^multiple1"]: matchN(2, [
      〈import;math〉.MultipleOf(3),
      〈import;math〉.MultipleOf(5),
    ])
    multiple1Err1: 1
    multiple1Err2: 3
    multiple1Err3: 5
    multiple1OK1: 15
  }
  bare: {
    embed: {
      t1: {
        a: {
          matchN(1, [
            >10,
          ])
        }
        b: {
          〈1;a〉
        }
      }
    }
    embed: {
      t2: {
        b: {
          〈1;a〉
        }
        a: {
          matchN(1, [
            >10,
          ])
        }
      }
    }
    direct: {
      t1: {
        a: matchN(1, [
          >10,
        ])
        b: 〈0;a〉
      }
    }
    direct: {
      t2: {
        b: 〈0;a〉
        a: matchN(1, [
          >10,
        ])
      }
    }
  }
  required: {
    ok1: {
      x: matchN(0, [
        {
          foo!: string
        },
      ])
      x: {
        bar: 2
      }
    }
    ok2: {
      x: matchN(0, [
        {
          foo!: string
        },
      ])
    }
    ok3: {
      x: matchN(0, [
        {
          bar!: string
        },
      ])
      x: {
        bar: 2
      }
    }
  }
  issue3575: {
    test1: {
      #x: matchN(1, [
        [
          {},
        ],
      ])
      x: 〈0;#x〉
      x: [
        {
          a: 1
        },
      ]
    }
    test2: {
      #x: matchN(1, [
        {},
      ])
      x: 〈0;#x〉
      x: {
        a: 1
      }
    }
  }
}
--- incomplete.cue
{
  incomplete: {
    incomplete1: {
      x: matchN(1, [
        {
          foo!: string
        },
      ])
      x: {
        bar: 2
      }
    }
    incomplete2: {
      x: matchN(1, [
        {
          foo!: string
        },
      ])
    }
    incomplete3: {
      x: matchN(〈import;math〉.MultipleOf(2), [
        {
          bar!: int
        },
        {
          foo!: int
        },
      ])
      x: {
        bar: 2
      }
    }
    incomplete4: {
      x: matchN(〈import;math〉.MultipleOf(2), [
        {
          bar!: int
        },
        {
          foo!: int
        },
        {
          baz!: int
        },
      ])
      x: {
        bar: 2
      }
    }
    incomplete5: {
      x: matchN((>1 & <=3), [
        {
          bar!: int
        },
        {
          foo!: int
        },
        {
          baz!: int
        },
      ])
      x: {
        bar: 2
      }
    }
    incomplete6: {
      x: matchN((2|3), [
        {
          bar!: int
        },
        {
          foo!: int
        },
        {
          baz!: int
        },
      ])
      x: {
        bar: 2
      }
    }
    err1: {
      x: matchN(1, [
        {
          bar!: string
        },
      ])
      x: {
        bar: 2
      }
    }
    err2: {
      x: matchN(0, [
        {
          bar!: int
        },
        {
          foo!: int
        },
      ])
      x: {
        bar: 2
      }
    }
    err3: {
      x: matchN(2, [
        {
          bar!: string
        },
        {
          foo!: string
        },
      ])
      x: {
        bar: 2
      }
    }
    err4: {
      x: matchN(>1, [
        {
          bar!: string
        },
        {
          foo!: string
        },
      ])
      x: {
        bar: 2
      }
    }
    err5: {
      x: matchN(<1, [
        {
          bar!: int
        },
        {
          foo!: int
        },
      ])
      x: {
        bar: 2
      }
    }
  }
  issue3389: {
    x: {
      bar: 2
    }
    x: matchN(1, [
      {
        bar: 3
      },
      {
        bar: 2
        foo!: int
      },
    ])
  }
}
--- issue3694.cue
{
  issue3694: {
    full: {
      #step: matchN(1, [
        {
          uses!: _
          ...
        },
        {
          run!: _
          ...
        },
      ])
      #step: close({
        uses?: string
        run?: string
      })
      s: (〈0;#step〉 & {
        run: "echo hello world"
      })
    }
  }
  issue3694: {
    simple: {
      #step: matchN(1, [
        {
          uses!: _
        },
      ])
      #step: close({
        uses?: string
      })
    }
  }
}
