-- in.cue --
a: {
	let X = Y
	let Y = c

	b: X
	c: 5
}

b: {
	let X = Y
	let Y = X

	b: X
	c: 5
}

fieldOffset: {
	a: {
		p1: {
			let X = {value: Y}
			let Y = 2
			x: X
		}
		p2: {
			x: X
			let Y = 2
			let X = {value: Y}
		}
	}
	b: {
		p1: {
			let X = {x: y: Y}
			let Y = 2
			x: X
		}
		p2: {
			x: X
			let Y = 2
			let X = {x: y: Y}
		}
	}
}

issue767: {
	#Foo: {
		let _#bar = {
			value: ""
		}
		let _#volmnts = {
			x: _#baz.value
		}
		let _#baz = {
			_#bar
		}
		out: _#volmnts
	}
}
-- out/compile --
b.let[]: cyclic references in let clause or alias:
    ./in.cue:10:10
--- in.cue
{
  a: {
    let X#6 = 〈0;let Y#7〉
    let Y#7 = 〈0;c〉
    b: 〈0;let X#6〉
    c: 5
  }
  b: {
    let X#8 = 〈0;let Y#9〉
    let Y#9 = 〈0;let X#8〉
    b: 〈0;let X#8〉
    c: 5
  }
  fieldOffset: {
    a: {
      p1: {
        let X#A = {
          value: 〈1;let Y#B〉
        }
        let Y#B = 2
        x: 〈0;let X#A〉
      }
      p2: {
        x: 〈0;let X#D〉
        let Y#C = 2
        let X#D = {
          value: 〈1;let Y#C〉
        }
      }
    }
    b: {
      p1: {
        let X#E = {
          x: {
            y: 〈2;let Y#F〉
          }
        }
        let Y#F = 2
        x: 〈0;let X#E〉
      }
      p2: {
        x: 〈0;let X#11〉
        let Y#10 = 2
        let X#11 = {
          x: {
            y: 〈2;let Y#10〉
          }
        }
      }
    }
  }
  issue767: {
    #Foo: {
      let _#bar#12 = {
        value: ""
      }
      let _#volmnts#13 = {
        x: 〈1;let _#baz#14〉.value
      }
      let _#baz#14 = {
        〈1;let _#bar#12〉
      }
      out: 〈0;let _#volmnts#13〉
    }
  }
}
-- out/eval --
b.let[]: cyclic references in let clause or alias:
    ./in.cue:10:10
