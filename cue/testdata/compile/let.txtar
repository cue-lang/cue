#expandLetExpr: true

-- in.cue --
a: {
	let X = Y
	let Y = c

	b: X
	c: 5
}

b: {
	let X = Y
	let Y = X

	b: X
	c: 5
}

fieldOffset: {
	a: {
		p1: {
			let X = {value: Y}
			let Y = 2
			x: X
		}
		p2: {
			x: X
			let Y = 2
			let X = {value: Y}
		}
	}
	b: {
		p1: {
			let X = {x: y: Y}
			let Y = 2
			x: X
		}
		p2: {
			x: X
			let Y = 2
			let X = {x: y: Y}
		}
	}
}

issue767: {
	#Foo: {
		let _#bar = {
			value: ""
		}
		let _#volmnts = {
			x: _#baz.value
		}
		let _#baz = {
			_#bar
		}
		out: _#volmnts
	}
}
-- alignstack.cue --
issue4051: full: {
	#app: name: "foo"

	let N = #app.name

	out: (N): [{f1: f2: N}]
}
issue4051: reduced: {
	(N): [{ f1: f2: N }]
	let N = x
	x: "s"
}
-- out/compile --
b.let[]: cyclic references in let clause or alias:
    ./in.cue:10:10
--- alignstack.cue
{
  issue4051: {
    full: {
      #app: {
        name: "foo"
      }
      let N#1 = 〈0;#app〉.name
      out: {
        〈1;let N#1〉=>〈0;#app〉.name: [
          {
            f1: {
              f2: 〈4;let N#1〉=>〈0;#app〉.name
            }
          },
        ]
      }
    }
  }
  issue4051: {
    reduced: {
      〈0;let N#2〉=>〈0;x〉: [
        {
          f1: {
            f2: 〈3;let N#2〉=>〈0;x〉
          }
        },
      ]
      let N#2 = 〈0;x〉
      x: "s"
    }
  }
}
--- in.cue
{
  a: {
    let X#3 = 〈0;let Y#4〉=>〈0;c〉
    let Y#4 = 〈0;c〉
    b: 〈0;let X#3〉=>〈0;let Y#4〉=>〈0;c〉
    c: 5
  }
  b: {
    let X#5 = 〈0;let Y#6〉=>〈0;let X#5〉=>〈0;let Y#6〉=>_|_(cyclic references in let clause or alias)
    let Y#6 = 〈0;let X#5〉=>〈0;let Y#6〉=>_|_(cyclic references in let clause or alias)
    b: 〈0;let X#5〉=>〈0;let Y#6〉=>_|_(cyclic references in let clause or alias)
    c: 5
  }
  fieldOffset: {
    a: {
      p1: {
        let X#7 = {
          value: 〈1;let Y#8〉=>2
        }
        let Y#8 = 2
        x: 〈0;let X#7〉=>{
          value: 〈1;let Y#8〉=>2
        }
      }
      p2: {
        x: 〈0;let X#A〉=>{
          value: 〈1;let Y#9〉=>2
        }
        let Y#9 = 2
        let X#A = {
          value: 〈1;let Y#9〉=>2
        }
      }
    }
    b: {
      p1: {
        let X#B = {
          x: {
            y: 〈2;let Y#C〉=>2
          }
        }
        let Y#C = 2
        x: 〈0;let X#B〉=>{
          x: {
            y: 〈2;let Y#C〉=>2
          }
        }
      }
      p2: {
        x: 〈0;let X#E〉=>{
          x: {
            y: 〈2;let Y#D〉=>2
          }
        }
        let Y#D = 2
        let X#E = {
          x: {
            y: 〈2;let Y#D〉=>2
          }
        }
      }
    }
  }
  issue767: {
    #Foo: {
      let _#bar#F = {
        value: ""
      }
      let _#volmnts#10 = {
        x: 〈1;let _#baz#11〉=>{
          〈1;let _#bar#F〉=>{
            value: ""
          }
        }.value
      }
      let _#baz#11 = {
        〈1;let _#bar#F〉=>{
          value: ""
        }
      }
      out: 〈0;let _#volmnts#10〉=>{
        x: 〈1;let _#baz#11〉=>{
          〈1;let _#bar#F〉=>{
            value: ""
          }
        }.value
      }
    }
  }
}
-- out/eval --
b.let[]: cyclic references in let clause or alias:
    ./in.cue:10:10
