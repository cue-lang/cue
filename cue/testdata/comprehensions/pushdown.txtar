# Working set of tests that unit test specifics of the aspect of the
# comprehension algorithm that pushes down evaluation to the arcs.

-- in.cue --
linkChildren: {
	w: 1
	v: {
		x: 1
		if true {
			y: 1
			if true {
				z: 1

				rw: w
				rx: x
				ry: y
				rz: z

				n1a: na: [w, x, y, z]
				n2a: n1a: na: [w, x, y, z]
				n2z: n1z: nz: z
			}
		}
	}
}

fail: {
	a: {
        // Condition of comprehensions must hold after evaluation is done.
		if a.b == _|_ {
			b: 1
		}
	}
}

embed: {
	t: #C
	#C: {
		if false {
			p: _
		}
	}
	t: p: "foo"


	t2: #C2
	#C2: {
		if true {
			p: _
		}
	}
	t2: p: "foo"
}

// Mix of both dynamic and static fields.
mixedFields: {
  a: {
    for _, s in ["foo"] {
      "\(s)": 1
      X: 1
    }
  }

  b: #Def: {
    for _, s in ["foo"] {
      "\(s)": 1
      X: 1
    }
  }
  b: x: b.#Def
  b: x: X: _
  b: x: foo: _

  c: #Def: {
    X:   int
    foo: int
  }
  c: x: c.#Def
  c: x: {
    for _, s in ["foo"] {
      "\(s)": 1
      X: 1
    }
  }
}

fieldMismatch: {
  a: {
    2
    if true {
      x: 3
    }
  }
}

// // More trigger happy on stack overflows.
b12a: {
	#list: {
		tail: #list

		if tail != null {
			sum: tail.sum
		}
	}

    list: {
        tail: list

        if tail != null {
            sum: tail.sum
        }
    }
}


xx: {
	#a: {
		if b {
			c: 4
		}
		b: bool
	}
	x: (#a & {b: true}) & {c: 4}
	y: x
}

// c should be allowed
#a: {
	if b {
		c: 4
	}
	b: true
}

#c: {}
a: {
	if b {
		c: d: 4
	}
	b: true
	c: #c
}


scopes: {
	x: 1
	a: {
		y: 2
		if true {
			b: x
			c: d: x
			e: y
			f: g: y
		}
	}
}

drop: {
	x: 1
	a: {
		y: 2
		if false {
			b: x
			c: d: x
			e: y
			f: g: y
		}
	}
}

cyclicError: {
	a: {
		x: bool
		y: bool
		if a.x  {
			y: true
		}
		if a.y {
			x: true
		}
		b: {}
	}
	c: a.b
}

midwayReferences: {
	a: {
		for i, j in {a: 1, b: 2} {
			x: y: z: (i): j
		}
		x: y: {}
	}
	b: a.x
	c: a.x.y
	d: a.x.y.z
}



emptyComprehension: {
    a: {}
    b: {
        // b should be an incomplete error
        if a.b {
        }
    }
}

// Eliminate the top value even if there is an error (especially incomplete
// errors).
topElimination: {
	_
	if true {
		x: a+1
	}
}


// Do not include x in s.
t: {
	#ok: *true | bool
	if #ok {
		x: int
	}
}
s: t & {
	#ok: false
}

// // should be error
// issue #465
explicitDefaultError: {
    a: string | *_|_

    if a != "" {
    }
}

-- reflect.cue --
import "encoding/json"


unifyDynamicReflect: {
  for _, s in ["foo"] {
    X: {...}
    "\(s)": {
      X: {...} // cannot be _
      Y: json.Marshal(X) // cannot be yaml, X cannot be literal
    }
  }

  [string]: X: {
    if true {// must be there
      x: y: {} // at least 2 nestings needed to expose problem
    }
  }
}

-- out/eval --
Errors:
a.c.d: field not allowed: d:
    ./in.cue:131:5
    ./in.cue:133:2
    ./in.cue:137:5
embed.t.p: field not allowed: p:
    ./in.cue:33:5
    ./in.cue:34:6
    ./in.cue:35:3
    ./in.cue:35:12
    ./in.cue:39:5
fieldMismatch.a: cannot combine regular field "x" with 2:
    ./in.cue:87:10
    ./in.cue:85:5
b12a.#list.tail: structural cycle:
    ./in.cue:97:6
b12a.list.tail: structural cycle:
    ./in.cue:105:12

Result:
(_|_){
  // [eval]
  linkChildren: (struct){
    w: (int){ 1 }
    v: (struct){
      y: (int){ 1 }
      x: (int){ 1 }
      z: (int){ 1 }
      rw: (int){ 1 }
      rx: (int){ 1 }
      ry: (int){ 1 }
      rz: (int){ 1 }
      n1a: (struct){
        na: (#list){
          0: (int){ 1 }
          1: (int){ 1 }
          2: (int){ 1 }
          3: (int){ 1 }
        }
      }
      n2a: (struct){
        n1a: (struct){
          na: (#list){
            0: (int){ 1 }
            1: (int){ 1 }
            2: (int){ 1 }
            3: (int){ 1 }
          }
        }
      }
      n2z: (struct){
        n1z: (struct){
          nz: (int){ 1 }
        }
      }
    }
  }
  fail: (struct){
    a: (_|_){
      // [cycle] cycle error
      b: (_|_){
        // [cycle] cycle error
      }
    }
  }
  embed: (_|_){
    // [eval]
    t: (_|_){
      // [eval]
      p: (_|_){
        // [eval] embed.t.p: field not allowed: p:
        //     ./in.cue:33:5
        //     ./in.cue:34:6
        //     ./in.cue:35:3
        //     ./in.cue:35:12
        //     ./in.cue:39:5
      }
    }
    #C: (#struct){
    }
    t2: (#struct){
      p: (string){ "foo" }
    }
    #C2: (#struct){
      p: (_){ _ }
    }
  }
  mixedFields: (struct){
    a: (struct){
      X: (int){ 1 }
      foo: (int){ 1 }
    }
    b: (struct){
      #Def: (#struct){
        X: (int){ 1 }
        foo: (int){ 1 }
      }
      x: (#struct){
        X: (int){ 1 }
        foo: (int){ 1 }
      }
    }
    c: (struct){
      #Def: (#struct){
        X: (int){ int }
        foo: (int){ int }
      }
      x: (#struct){
        X: (int){ 1 }
        foo: (int){ 1 }
      }
    }
  }
  fieldMismatch: (_|_){
    // [eval]
    a: (_|_){
      // [eval] fieldMismatch.a: cannot combine regular field "x" with 2:
      //     ./in.cue:87:10
      //     ./in.cue:85:5
      x: (int){ 3 }
    }
  }
  b12a: (_|_){
    // [structural cycle]
    #list: (_|_){
      // [structural cycle]
      sum: (_|_){
        // [structural cycle] b12a.#list.tail: structural cycle:
        //     ./in.cue:97:6
      }
      tail: (_|_){
        // [structural cycle] b12a.#list.tail: structural cycle:
        //     ./in.cue:97:6
      }
    }
    list: (_|_){
      // [structural cycle]
      sum: (_|_){
        // [structural cycle] b12a.list.tail: structural cycle:
        //     ./in.cue:105:12
      }
      tail: (_|_){
        // [structural cycle] b12a.list.tail: structural cycle:
        //     ./in.cue:105:12
      }
    }
  }
  xx: (struct){
    #a: (_|_){
      // [incomplete] xx.#a.c: incomplete bool: bool
      c: (_|_){
        // [incomplete] xx.#a.c: incomplete bool: bool
      }
      b: (bool){ bool }
    }
    x: (#struct){
      c: (int){ 4 }
      b: (bool){ true }
    }
    y: (#struct){
      c: (int){ 4 }
      b: (bool){ true }
    }
  }
  #a: (#struct){
    c: (int){ 4 }
    b: (bool){ true }
  }
  #c: (#struct){
  }
  a: (_|_){
    // [eval]
    c: (_|_){
      // [eval]
      d: (_|_){
        // [eval] a.c.d: field not allowed: d:
        //     ./in.cue:131:5
        //     ./in.cue:133:2
        //     ./in.cue:137:5
      }
    }
    b: (bool){ true }
  }
  scopes: (struct){
    x: (int){ 1 }
    a: (struct){
      b: (int){ 1 }
      c: (struct){
        d: (int){ 1 }
      }
      e: (int){ 2 }
      f: (struct){
        g: (int){ 2 }
      }
      y: (int){ 2 }
    }
  }
  drop: (struct){
    x: (int){ 1 }
    a: (struct){
      y: (int){ 2 }
    }
  }
  cyclicError: (struct){
    a: (_|_){
      // [cycle] cycle error
      y: (_|_){
        // [cycle] cycle error
      }
      x: (_|_){
        // [cycle] cycle error
      }
      b: (struct){
      }
    }
    c: (struct){
    }
  }
  midwayReferences: (struct){
    a: (struct){
      x: (struct){
        y: (struct){
          z: (struct){
            a: (int){ 1 }
            b: (int){ 2 }
          }
        }
      }
    }
    b: (struct){
      y: (struct){
        z: (struct){
          a: (int){ 1 }
          b: (int){ 2 }
        }
      }
    }
    c: (struct){
      z: (struct){
        a: (int){ 1 }
        b: (int){ 2 }
      }
    }
    d: (struct){
      a: (int){ 1 }
      b: (int){ 2 }
    }
  }
  emptyComprehension: (struct){
    a: (struct){
    }
    b: (_|_){
      // [incomplete] emptyComprehension.b: undefined field: b:
      //     ./in.cue:200:14
    }
  }
  topElimination: (_|_){
    // [eval]
    x: (_|_){
      // [eval]
    }
  }
  t: (struct){
    x: (int){ int }
    #ok: (bool){ |(*(bool){ true }, (bool){ bool }) }
  }
  s: (struct){
    #ok: (bool){ false }
  }
  explicitDefaultError: (_|_){
    // [incomplete] explicitDefaultError: non-concrete value string in operand to !=:
    //     ./in.cue:231:8
    //     ./in.cue:229:5
    a: (string){ string }
  }
  unifyDynamicReflect: (struct){
    X: (struct){
      X: (struct){
        x: (struct){
          y: (struct){
          }
        }
      }
    }
    foo: (struct){
      X: (struct){
        x: (struct){
          y: (struct){
          }
        }
      }
      Y: (string){ "{\"x\":{\"y\":{}}}" }
    }
  }
}
-- out/compile --
--- in.cue
{
  linkChildren: {
    w: 1
    v: {
      x: 1
      if true {
        y: 1
        if true {
          z: 1
          rw: 〈3;w〉
          rx: 〈2;x〉
          ry: 〈1;y〉
          rz: 〈0;z〉
          n1a: {
            na: [
              〈5;w〉,
              〈4;x〉,
              〈3;y〉,
              〈2;z〉,
            ]
          }
          n2a: {
            n1a: {
              na: [
                〈6;w〉,
                〈5;x〉,
                〈4;y〉,
                〈3;z〉,
              ]
            }
          }
          n2z: {
            n1z: {
              nz: 〈2;z〉
            }
          }
        }
      }
    }
  }
  fail: {
    a: {
      if (〈1;a〉.b == _|_(explicit error (_|_ literal) in source)) {
        b: 1
      }
    }
  }
  embed: {
    t: 〈0;#C〉
    #C: {
      if false {
        p: _
      }
    }
    t: {
      p: "foo"
    }
    t2: 〈0;#C2〉
    #C2: {
      if true {
        p: _
      }
    }
    t2: {
      p: "foo"
    }
  }
  mixedFields: {
    a: {
      for _, s in [
        "foo",
      ] {
        "\(〈1;s〉)": 1
        X: 1
      }
    }
    b: {
      #Def: {
        for _, s in [
          "foo",
        ] {
          "\(〈1;s〉)": 1
          X: 1
        }
      }
    }
    b: {
      x: 〈1;b〉.#Def
    }
    b: {
      x: {
        X: _
      }
    }
    b: {
      x: {
        foo: _
      }
    }
    c: {
      #Def: {
        X: int
        foo: int
      }
    }
    c: {
      x: 〈1;c〉.#Def
    }
    c: {
      x: {
        for _, s in [
          "foo",
        ] {
          "\(〈1;s〉)": 1
          X: 1
        }
      }
    }
  }
  fieldMismatch: {
    a: {
      2
      if true {
        x: 3
      }
    }
  }
  b12a: {
    #list: {
      tail: 〈1;#list〉
      if (〈0;tail〉 != null) {
        sum: 〈1;tail〉.sum
      }
    }
    list: {
      tail: 〈1;list〉
      if (〈0;tail〉 != null) {
        sum: 〈1;tail〉.sum
      }
    }
  }
  xx: {
    #a: {
      if 〈0;b〉 {
        c: 4
      }
      b: bool
    }
    x: ((〈0;#a〉 & {
      b: true
    }) & {
      c: 4
    })
    y: 〈0;x〉
  }
  #a: {
    if 〈0;b〉 {
      c: 4
    }
    b: true
  }
  #c: {}
  a: {
    if 〈0;b〉 {
      c: {
        d: 4
      }
    }
    b: true
    c: 〈1;#c〉
  }
  scopes: {
    x: 1
    a: {
      y: 2
      if true {
        b: 〈2;x〉
        c: {
          d: 〈3;x〉
        }
        e: 〈1;y〉
        f: {
          g: 〈2;y〉
        }
      }
    }
  }
  drop: {
    x: 1
    a: {
      y: 2
      if false {
        b: 〈2;x〉
        c: {
          d: 〈3;x〉
        }
        e: 〈1;y〉
        f: {
          g: 〈2;y〉
        }
      }
    }
  }
  cyclicError: {
    a: {
      x: bool
      y: bool
      if 〈1;a〉.x {
        y: true
      }
      if 〈1;a〉.y {
        x: true
      }
      b: {}
    }
    c: 〈0;a〉.b
  }
  midwayReferences: {
    a: {
      for i, j in {
        a: 1
        b: 2
      } {
        x: {
          y: {
            z: {
              〈4;i〉: 〈4;j〉
            }
          }
        }
      }
      x: {
        y: {}
      }
    }
    b: 〈0;a〉.x
    c: 〈0;a〉.x.y
    d: 〈0;a〉.x.y.z
  }
  emptyComprehension: {
    a: {}
    b: {
      if 〈1;a〉.b {}
    }
  }
  topElimination: {
    _
    if true {
      x: (〈2;a〉 + 1)
    }
  }
  t: {
    #ok: (*true|bool)
    if 〈0;#ok〉 {
      x: int
    }
  }
  s: (〈0;t〉 & {
    #ok: false
  })
  explicitDefaultError: {
    a: (string|*_|_(explicit error (_|_ literal) in source))
    if (〈0;a〉 != "") {}
  }
}
--- reflect.cue
{
  unifyDynamicReflect: {
    for _, s in [
      "foo",
    ] {
      X: {
        ...
      }
      "\(〈1;s〉)": {
        X: {
          ...
        }
        Y: 〈import;"encoding/json"〉.Marshal(〈0;X〉)
      }
    }
    [string]: {
      X: {
        if true {
          x: {
            y: {}
          }
        }
      }
    }
  }
}
