// Issues: #667, #695, #622
-- in.cue --
import (
	"strconv"
	"regexp"
)

// In these test, it is impossible to determine the existence of some arcs due
// to mutual dependence on becoming concrete.
//
// This tests shows the essences of when an existence check cannot be resolved.
minimal: {
    // TODO: missing path indications on errors.
    a: {
        if b.port == _|_ {
            port: ""
        }
    }

    b: {
        if a.port == _|_ {
            port: ""
        }
    }
}

small: {
    #userHostPort: 	#"^(:(?P<port>\d+))?$"#

    p1: {
		#Y: regexp.FindNamedSubmatch(#userHostPort, #X.port)

        #X: {
            if #Y.port == _|_ {
                port: ""
            }
            if #Y.port != _|_ {
                port: ":" + strconv.FormatInt(#Y.port, 10)
            }
        }
	}

    p2: {
        #X: {
            if #Y.port == _|_ {
                port: ""
            }
            if #Y.port != _|_ {
                port: ":" + strconv.FormatInt(#Y.port, 10)
            }
        }

		#Y: regexp.FindNamedSubmatch(#userHostPort, #X.port)
	}
}

medium: {
    #userHostPort: 	#"^(:(?P<port>\d+))?$"#

    p1: {
        #Y: regexp.FindNamedSubmatch(#userHostPort, #X.port)

        Y: {
            if #Y.port != _|_ {
                port: strconv.Atoi(#Y.port)
            }
        }

        #X: {
            // Can never determine whether Y.port exists as its resolution
            // depends on #Y becoming finalized, which, in turn, depends on #X
            // becoming finalized.
            if Y.port == _|_ {
                port: ""
            }
            if Y.port != _|_ {
                port: ":" + strconv.FormatInt(Y.port, 10)
            }
        }
    }

    p2: {
        #Y: regexp.FindNamedSubmatch(#userHostPort, #X.port)

        #X: {
            // Can never determine whether Y.port exists as its resolution
            // depends on #Y becoming finalized, which, in turn, depends on #X
            // becoming finalized.
            if Y.port == _|_ {
                port: ""
            }
            if Y.port != _|_ {
                port: ":" + strconv.FormatInt(Y.port, 10)
            }
        }

        Y: {
            if #Y.port != _|_ {
              port: strconv.Atoi(#Y.port)
            }
        }
	}

    p3: {
         Y: {
            if #Y.port != _|_ {
                port: strconv.Atoi(#Y.port)
            }
        }

        #Y: regexp.FindNamedSubmatch(#userHostPort, #X.port)

        #X: {
            // Can never determine whether Y.port exists as its resolution
            // depends on #Y becoming finalized, which, in turn, depends on #X
            // becoming finalized.
            if Y.port == _|_ {
                port: ""
            }
            if Y.port != _|_ {
                port: ":" + strconv.FormatInt(Y.port, 10)
            }
        }
    }

    p4: {
        Y: {
            if #Y.port != _|_ {
                port: strconv.Atoi(#Y.port)
            }
        }

        #X: {
            // Can never determine whether Y.port exists as its resolution
            // depends on #Y becoming finalized, which, in turn, depends on #X
            // becoming finalized.
            if Y.port == _|_ {
                port: ""
            }
            if Y.port != _|_ {
                port: ":" + strconv.FormatInt(Y.port, 10)
            }
        }

        #Y: regexp.FindNamedSubmatch(#userHostPort, #X.port)
    }

    // TODO: missing path indications on errors.
    p5: {
        #X: {
            // Can never determine whether Y.port exists as its resolution
            // depends on #Y becoming finalized, which, in turn, depends on #X
            // becoming finalized.
            if Y.port == _|_ {
                port: ""
            }
            if Y.port != _|_ {
                port: ":" + strconv.FormatInt(Y.port, 10)
            }
        }

        #Y: regexp.FindNamedSubmatch(#userHostPort, #X.port)

        Y: {
            if #Y.port != _|_ {
                port: strconv.Atoi(#Y.port)
            }
        }
    }

    p6: {
        #X: {
            // Can never determine whether Y.port exists as its resolution
            // depends on #Y becoming finalized, which, in turn, depends on #X
            // becoming finalized.
            if Y.port == _|_ {
                port: ""
            }
            if Y.port != _|_ {
                port: ":" + strconv.FormatInt(Y.port, 10)
            }
        }

        Y: {
            if #Y.port != _|_ {
                port: strconv.Atoi(#Y.port)
            }
        }

        #Y: regexp.FindNamedSubmatch(#userHostPort, #X.port)
    }
}


large: {
    #userHostPort: 	#"^((?P<userinfo>[[:alnum:]]*)@)?(?P<host>[[:alnum:].]+)(:(?P<port>\d+))?$"#

    p1: {
        Y: {
            userinfo: "user"
            host:     "example.com"
        }

        X: #X.userinfo + #X.host + #X.port

        #X: {
            if Y.userinfo == _|_ {
                userinfo: ""
            }
            if Y.userinfo != _|_ {
                userinfo: Y.userinfo + "@"
            }

            host: Y.host

            if Y.port == _|_ {
                port: ""
            }
            if Y.port != _|_ {
                port: ":" + strconv.FormatInt(Y.port, 10)
            }
        }

        Y: {
            if #Y.userinfo != _|_ {
                userinfo: #Y.userinfo
            }
            
            host: #Y.host

            if #Y.port != _|_ {
                port: strconv.Atoi(#Y.port)
            }
        }

        #Y: regexp.FindNamedSubmatch(#userHostPort, X)
    }

    p2: {
        X: #X.userinfo + #X.host + #X.port

        Y: {
            userinfo: "user"
            host:     "example.com"
        }

        #X: {
            if Y.userinfo == _|_ {
                userinfo: ""
            }
            if Y.userinfo != _|_ {
                userinfo: Y.userinfo + "@"
            }

            host: Y.host

            if Y.port == _|_ {
                port: ""
            }
            if Y.port != _|_ {
                port: ":" + strconv.FormatInt(Y.port, 10)
            }
        }

        Y: {
            if #Y.userinfo != _|_ {
                userinfo: #Y.userinfo
            }
            
            host: #Y.host

            if #Y.port != _|_ {
                port: strconv.Atoi(#Y.port)
            }
        }

        #Y: regexp.FindNamedSubmatch(#userHostPort, X)
    }

    p3: {
        X: #X.userinfo + #X.host + #X.port

        #X: {
            if Y.userinfo == _|_ {
                userinfo: ""
            }
            if Y.userinfo != _|_ {
                userinfo: Y.userinfo + "@"
            }

            host: Y.host

            if Y.port == _|_ {
                port: ""
            }
            if Y.port != _|_ {
                port: ":" + strconv.FormatInt(Y.port, 10)
            }
        }

        Y: {
            userinfo: "user"
            host:     "example.com"
        }

        Y: {
            if #Y.userinfo != _|_ {
                userinfo: #Y.userinfo
            }
            
            host: #Y.host

            if #Y.port != _|_ {
                port: strconv.Atoi(#Y.port)
            }
        }

        #Y: regexp.FindNamedSubmatch(#userHostPort, X)
    }

    p4: {
        X: #X.userinfo + #X.host + #X.port

        #X: {
            if Y.userinfo == _|_ {
                userinfo: ""
            }
            if Y.userinfo != _|_ {
                userinfo: Y.userinfo + "@"
            }

            host: Y.host

            if Y.port == _|_ {
                port: ""
            }
            if Y.port != _|_ {
                port: ":" + strconv.FormatInt(Y.port, 10)
            }
        }

        #Y: regexp.FindNamedSubmatch(#userHostPort, X)

        Y: {
            userinfo: "user"
            host:     "example.com"
        }

        Y: {
            if #Y.userinfo != _|_ {
                userinfo: #Y.userinfo
            }

            host: #Y.host

            if #Y.port != _|_ {
                port: strconv.Atoi(#Y.port)
            }
        }
    }
}
-- out/eval --
(struct){
  minimal: (struct){
    a: (_|_){
      // [cycle] cycle error
      port: (_|_){
        // [cycle] cycle error
      }
    }
    b: (_|_){
      // [cycle] cycle error
      port: (_|_){
        // [cycle] cycle error
      }
    }
  }
  small: (struct){
    #userHostPort: (string){ "^(:(?P<port>\\d+))?$" }
    p1: (struct){
      #Y: (#struct){
        port: (string){ "" }
      }
      #X: (_|_){
        // [cycle] small.p1.#X: circular dependency in evaluation of conditionals: #Y.port changed after evaluation:
        //     ./in.cue:32:16
        // small.p1.#X: circular dependency in evaluation of conditionals: #Y.port changed after evaluation:
        //     ./in.cue:35:16
        port: (string){ "" }
      }
    }
    p2: (struct){
      #X: (_|_){
        // [cycle] small.p2.#X.port: undefined field: port:
        //     ./in.cue:43:19
        // small.p2.#X.port: undefined field: port:
        //     ./in.cue:46:19
        port: (_|_){
          // [cycle] small.p2.#X.port: undefined field: port:
          //     ./in.cue:43:19
          // small.p2.#X.port: undefined field: port:
          //     ./in.cue:46:19
        }
      }
      #Y: (_|_){
        // [cycle] small.p2.#X.port: undefined field: port:
        //     ./in.cue:43:19
        // small.p2.#X.port: undefined field: port:
        //     ./in.cue:46:19
      }
    }
  }
  medium: (struct){
    #userHostPort: (string){ "^(:(?P<port>\\d+))?$" }
    p1: (struct){
      #Y: (#struct){
        port: (string){ "" }
      }
      Y: (_|_){
        // [cycle] medium.p1.Y: circular dependency in evaluation of conditionals: #Y.port changed after evaluation:
        //     ./in.cue:62:16
      }
      #X: (_|_){
        // [cycle] medium.p1.#X: circular dependency in evaluation of conditionals: Y.port changed after evaluation:
        //     ./in.cue:71:16
        // medium.p1.#X: circular dependency in evaluation of conditionals: Y.port changed after evaluation:
        //     ./in.cue:74:16
        port: (string){ "" }
      }
    }
    p2: (struct){
      #Y: (#struct){
        port: (string){ "" }
      }
      #X: (#struct){
        port: (string){ "" }
      }
      Y: (_|_){
        // [cycle] medium.p2.Y: circular dependency in evaluation of conditionals: #Y.port changed after evaluation:
        //     ./in.cue:96:16
      }
    }
    p3: (struct){
      Y: (_|_){
        // [cycle] medium.p3.Y.port: undefined field: port:
        //     ./in.cue:104:19
        port: (_|_){
          // [cycle] medium.p3.Y.port: undefined field: port:
          //     ./in.cue:104:19
        }
      }
      #Y: (_|_){
        // [cycle] cycle error
      }
      #X: (_|_){
        // [cycle] medium.p3.Y.port: undefined field: port:
        //     ./in.cue:104:19
        port: (_|_){
          // [cycle] medium.p3.Y.port: undefined field: port:
          //     ./in.cue:104:19
        }
      }
    }
    p4: (struct){
      Y: (_|_){
        // [cycle] medium.p4.Y.port: undefined field: port:
        //     ./in.cue:126:19
        port: (_|_){
          // [cycle] medium.p4.Y.port: undefined field: port:
          //     ./in.cue:126:19
        }
      }
      #X: (_|_){
        // [cycle] medium.p4.Y.port: undefined field: port:
        //     ./in.cue:126:19
        port: (_|_){
          // [cycle] medium.p4.Y.port: undefined field: port:
          //     ./in.cue:126:19
        }
      }
      #Y: (_|_){
        // [cycle] medium.p4.Y.port: undefined field: port:
        //     ./in.cue:126:19
      }
    }
    p5: (struct){
      #X: (_|_){
        // [cycle] cycle error
        port: (_|_){
          // [cycle] cycle error
        }
      }
      #Y: (_|_){
        // [cycle] cycle error
      }
      Y: (struct){
      }
    }
    p6: (struct){
      #X: (_|_){
        // [cycle] cycle error
        port: (_|_){
          // [cycle] cycle error
        }
      }
      Y: (_|_){
        // [cycle] medium.p6.Y.port: undefined field: port:
        //     ./in.cue:183:19
        port: (_|_){
          // [cycle] medium.p6.Y.port: undefined field: port:
          //     ./in.cue:183:19
        }
      }
      #Y: (_|_){
        // [cycle] cycle error
      }
    }
  }
  large: (struct){
    #userHostPort: (string){ "^((?P<userinfo>[[:alnum:]]*)@)?(?P<host>[[:alnum:].]+)(:(?P<port>\\d+))?$" }
    p1: (struct){
      Y: (_|_){
        // [cycle] large.p1.Y: circular dependency in evaluation of conditionals: #Y.port changed after evaluation:
        //     ./in.cue:229:16
        userinfo: (string){ "user" }
        host: (string){ "example.com" }
      }
      X: (string){ "user@example.com" }
      #X: (_|_){
        // [cycle] large.p1.#X: circular dependency in evaluation of conditionals: Y.userinfo changed after evaluation:
        //     ./in.cue:205:16
        // large.p1.#X: circular dependency in evaluation of conditionals: Y.userinfo changed after evaluation:
        //     ./in.cue:208:16
        // large.p1.#X: circular dependency in evaluation of conditionals: Y.port changed after evaluation:
        //     ./in.cue:214:16
        // large.p1.#X: circular dependency in evaluation of conditionals: Y.port changed after evaluation:
        //     ./in.cue:217:16
        userinfo: (string){ "user@" }
        port: (string){ "" }
        host: (string){ "example.com" }
      }
      #Y: (#struct){
        host: (string){ "example.com" }
        port: (string){ "" }
        userinfo: (string){ "user" }
      }
    }
    p2: (struct){
      X: (_|_){
        // [cycle] cycle error:
        //     ./in.cue:238:12
      }
      Y: (struct){
        userinfo: (string){ "user" }
        host: (_|_){
          // [incomplete] large.p2.Y.host: undefined field: host:
          //     ./in.cue:268:22
        }
      }
      #X: (#struct){
        userinfo: (string){ "user@" }
        port: (string){ "" }
        host: (_|_){
          // [incomplete] large.p2.#X.host: undefined field: host:
          //     ./in.cue:268:22
        }
      }
      #Y: (_|_){
        // [cycle] cycle error:
        //     ./in.cue:238:12
      }
    }
    p3: (struct){
      X: (_|_){
        // [cycle] cycle error:
        //     ./in.cue:279:12
      }
      #X: (#struct){
        userinfo: (string){ "user@" }
        port: (string){ "" }
        host: (_|_){
          // [incomplete] large.p3.#X.host: undefined field: host:
          //     ./in.cue:309:22
        }
      }
      Y: (struct){
        userinfo: (string){ "user" }
        host: (_|_){
          // [incomplete] large.p3.Y.host: undefined field: host:
          //     ./in.cue:309:22
        }
      }
      #Y: (_|_){
        // [cycle] cycle error:
        //     ./in.cue:279:12
      }
    }
    p4: (struct){
      X: (_|_){
        // [cycle] cycle error:
        //     ./in.cue:320:12
      }
      #X: (#struct){
        userinfo: (string){ "user@" }
        port: (string){ "" }
        host: (_|_){
          // [incomplete] large.p4.#X.host: undefined field: host:
          //     ./in.cue:352:22
        }
      }
      #Y: (_|_){
        // [cycle] cycle error:
        //     ./in.cue:320:12
      }
      Y: (_|_){
        // [cycle] cycle error:
        //     ./in.cue:320:12
        userinfo: (_|_){
          // [cycle] cycle error:
          //     ./in.cue:320:12
        }
        host: (_|_){
          // [cycle] cycle error:
          //     ./in.cue:320:12
        }
      }
    }
  }
}
-- out/compile --
--- in.cue
{
  minimal: {
    a: {
      if (〈1;b〉.port == _|_(explicit error (_|_ literal) in source)) {
        port: ""
      }
    }
    b: {
      if (〈1;a〉.port == _|_(explicit error (_|_ literal) in source)) {
        port: ""
      }
    }
  }
  small: {
    #userHostPort: "^(:(?P<port>\\d+))?$"
    p1: {
      #Y: 〈import;regexp〉.FindNamedSubmatch(〈1;#userHostPort〉, 〈0;#X〉.port)
      #X: {
        if (〈1;#Y〉.port == _|_(explicit error (_|_ literal) in source)) {
          port: ""
        }
        if (〈1;#Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: (":" + 〈import;strconv〉.FormatInt(〈2;#Y〉.port, 10))
        }
      }
    }
    p2: {
      #X: {
        if (〈1;#Y〉.port == _|_(explicit error (_|_ literal) in source)) {
          port: ""
        }
        if (〈1;#Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: (":" + 〈import;strconv〉.FormatInt(〈2;#Y〉.port, 10))
        }
      }
      #Y: 〈import;regexp〉.FindNamedSubmatch(〈1;#userHostPort〉, 〈0;#X〉.port)
    }
  }
  medium: {
    #userHostPort: "^(:(?P<port>\\d+))?$"
    p1: {
      #Y: 〈import;regexp〉.FindNamedSubmatch(〈1;#userHostPort〉, 〈0;#X〉.port)
      Y: {
        if (〈1;#Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: 〈import;strconv〉.Atoi(〈2;#Y〉.port)
        }
      }
      #X: {
        if (〈1;Y〉.port == _|_(explicit error (_|_ literal) in source)) {
          port: ""
        }
        if (〈1;Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: (":" + 〈import;strconv〉.FormatInt(〈2;Y〉.port, 10))
        }
      }
    }
    p2: {
      #Y: 〈import;regexp〉.FindNamedSubmatch(〈1;#userHostPort〉, 〈0;#X〉.port)
      #X: {
        if (〈1;Y〉.port == _|_(explicit error (_|_ literal) in source)) {
          port: ""
        }
        if (〈1;Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: (":" + 〈import;strconv〉.FormatInt(〈2;Y〉.port, 10))
        }
      }
      Y: {
        if (〈1;#Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: 〈import;strconv〉.Atoi(〈2;#Y〉.port)
        }
      }
    }
    p3: {
      Y: {
        if (〈1;#Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: 〈import;strconv〉.Atoi(〈2;#Y〉.port)
        }
      }
      #Y: 〈import;regexp〉.FindNamedSubmatch(〈1;#userHostPort〉, 〈0;#X〉.port)
      #X: {
        if (〈1;Y〉.port == _|_(explicit error (_|_ literal) in source)) {
          port: ""
        }
        if (〈1;Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: (":" + 〈import;strconv〉.FormatInt(〈2;Y〉.port, 10))
        }
      }
    }
    p4: {
      Y: {
        if (〈1;#Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: 〈import;strconv〉.Atoi(〈2;#Y〉.port)
        }
      }
      #X: {
        if (〈1;Y〉.port == _|_(explicit error (_|_ literal) in source)) {
          port: ""
        }
        if (〈1;Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: (":" + 〈import;strconv〉.FormatInt(〈2;Y〉.port, 10))
        }
      }
      #Y: 〈import;regexp〉.FindNamedSubmatch(〈1;#userHostPort〉, 〈0;#X〉.port)
    }
    p5: {
      #X: {
        if (〈1;Y〉.port == _|_(explicit error (_|_ literal) in source)) {
          port: ""
        }
        if (〈1;Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: (":" + 〈import;strconv〉.FormatInt(〈2;Y〉.port, 10))
        }
      }
      #Y: 〈import;regexp〉.FindNamedSubmatch(〈1;#userHostPort〉, 〈0;#X〉.port)
      Y: {
        if (〈1;#Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: 〈import;strconv〉.Atoi(〈2;#Y〉.port)
        }
      }
    }
    p6: {
      #X: {
        if (〈1;Y〉.port == _|_(explicit error (_|_ literal) in source)) {
          port: ""
        }
        if (〈1;Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: (":" + 〈import;strconv〉.FormatInt(〈2;Y〉.port, 10))
        }
      }
      Y: {
        if (〈1;#Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: 〈import;strconv〉.Atoi(〈2;#Y〉.port)
        }
      }
      #Y: 〈import;regexp〉.FindNamedSubmatch(〈1;#userHostPort〉, 〈0;#X〉.port)
    }
  }
  large: {
    #userHostPort: "^((?P<userinfo>[[:alnum:]]*)@)?(?P<host>[[:alnum:].]+)(:(?P<port>\\d+))?$"
    p1: {
      Y: {
        userinfo: "user"
        host: "example.com"
      }
      X: ((〈0;#X〉.userinfo + 〈0;#X〉.host) + 〈0;#X〉.port)
      #X: {
        if (〈1;Y〉.userinfo == _|_(explicit error (_|_ literal) in source)) {
          userinfo: ""
        }
        if (〈1;Y〉.userinfo != _|_(explicit error (_|_ literal) in source)) {
          userinfo: (〈2;Y〉.userinfo + "@")
        }
        host: 〈1;Y〉.host
        if (〈1;Y〉.port == _|_(explicit error (_|_ literal) in source)) {
          port: ""
        }
        if (〈1;Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: (":" + 〈import;strconv〉.FormatInt(〈2;Y〉.port, 10))
        }
      }
      Y: {
        if (〈1;#Y〉.userinfo != _|_(explicit error (_|_ literal) in source)) {
          userinfo: 〈2;#Y〉.userinfo
        }
        host: 〈1;#Y〉.host
        if (〈1;#Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: 〈import;strconv〉.Atoi(〈2;#Y〉.port)
        }
      }
      #Y: 〈import;regexp〉.FindNamedSubmatch(〈1;#userHostPort〉, 〈0;X〉)
    }
    p2: {
      X: ((〈0;#X〉.userinfo + 〈0;#X〉.host) + 〈0;#X〉.port)
      Y: {
        userinfo: "user"
        host: "example.com"
      }
      #X: {
        if (〈1;Y〉.userinfo == _|_(explicit error (_|_ literal) in source)) {
          userinfo: ""
        }
        if (〈1;Y〉.userinfo != _|_(explicit error (_|_ literal) in source)) {
          userinfo: (〈2;Y〉.userinfo + "@")
        }
        host: 〈1;Y〉.host
        if (〈1;Y〉.port == _|_(explicit error (_|_ literal) in source)) {
          port: ""
        }
        if (〈1;Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: (":" + 〈import;strconv〉.FormatInt(〈2;Y〉.port, 10))
        }
      }
      Y: {
        if (〈1;#Y〉.userinfo != _|_(explicit error (_|_ literal) in source)) {
          userinfo: 〈2;#Y〉.userinfo
        }
        host: 〈1;#Y〉.host
        if (〈1;#Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: 〈import;strconv〉.Atoi(〈2;#Y〉.port)
        }
      }
      #Y: 〈import;regexp〉.FindNamedSubmatch(〈1;#userHostPort〉, 〈0;X〉)
    }
    p3: {
      X: ((〈0;#X〉.userinfo + 〈0;#X〉.host) + 〈0;#X〉.port)
      #X: {
        if (〈1;Y〉.userinfo == _|_(explicit error (_|_ literal) in source)) {
          userinfo: ""
        }
        if (〈1;Y〉.userinfo != _|_(explicit error (_|_ literal) in source)) {
          userinfo: (〈2;Y〉.userinfo + "@")
        }
        host: 〈1;Y〉.host
        if (〈1;Y〉.port == _|_(explicit error (_|_ literal) in source)) {
          port: ""
        }
        if (〈1;Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: (":" + 〈import;strconv〉.FormatInt(〈2;Y〉.port, 10))
        }
      }
      Y: {
        userinfo: "user"
        host: "example.com"
      }
      Y: {
        if (〈1;#Y〉.userinfo != _|_(explicit error (_|_ literal) in source)) {
          userinfo: 〈2;#Y〉.userinfo
        }
        host: 〈1;#Y〉.host
        if (〈1;#Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: 〈import;strconv〉.Atoi(〈2;#Y〉.port)
        }
      }
      #Y: 〈import;regexp〉.FindNamedSubmatch(〈1;#userHostPort〉, 〈0;X〉)
    }
    p4: {
      X: ((〈0;#X〉.userinfo + 〈0;#X〉.host) + 〈0;#X〉.port)
      #X: {
        if (〈1;Y〉.userinfo == _|_(explicit error (_|_ literal) in source)) {
          userinfo: ""
        }
        if (〈1;Y〉.userinfo != _|_(explicit error (_|_ literal) in source)) {
          userinfo: (〈2;Y〉.userinfo + "@")
        }
        host: 〈1;Y〉.host
        if (〈1;Y〉.port == _|_(explicit error (_|_ literal) in source)) {
          port: ""
        }
        if (〈1;Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: (":" + 〈import;strconv〉.FormatInt(〈2;Y〉.port, 10))
        }
      }
      #Y: 〈import;regexp〉.FindNamedSubmatch(〈1;#userHostPort〉, 〈0;X〉)
      Y: {
        userinfo: "user"
        host: "example.com"
      }
      Y: {
        if (〈1;#Y〉.userinfo != _|_(explicit error (_|_ literal) in source)) {
          userinfo: 〈2;#Y〉.userinfo
        }
        host: 〈1;#Y〉.host
        if (〈1;#Y〉.port != _|_(explicit error (_|_ literal) in source)) {
          port: 〈import;strconv〉.Atoi(〈2;#Y〉.port)
        }
      }
    }
  }
}
