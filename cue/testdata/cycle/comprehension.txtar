-- in.cue --
import (
	"list"
	"strings"
)

// Allow lookup in partially evaluated struct as long as the end result is
// concrete.
A: {
	a: {
		parent: ""
		children: [for k, v in A if v.parent == k {k}]
	}
	b: {
		parent: "a"
		children: [for k, v in A if v.parent == k {k}]
	}
}

// This should result in an incomplete error (a reference cycle error classifies
// as incomplete).
B: {
	a: {
		parent: ""
		children: [for k, v in B for _, w in v.children {k}]
	}
}

// Issue #486
Issue486: {
	A: {
		a: {
			parent: ""
			children: [...string]
		}
		b: {
			parent: "a"
			children: [...string]
		}
		c: {
			parent: "b"
			children: [...string]
		}
	}

	A: [Name=string]: {
		children: [
			for k, v in A
			if v.parent == Name {
				k
			},
		]
	}
}

// Issue #1666
issue1666: {
	#E: {
		f1: [string]: #E | [...#E]
		f2: [string]: t: #E
	}

	_e: #E
	_e: f2: a: _

	e: _e & {
		f1: {
			for fk, s in _e.f2 {
				(fk): s.t
			}
		}
	}
}

// Issue #779: bidirectional projection
// Should be allowed as long as the set of fields is not modified as a result
// of a comprehension.
issue779: {
	X: Y.message
	STATE: {
		for k, v in Y {
			if k != "message" {
				"\(k)": v
			}
		}
	}
	Y: STATE & { message: X }
	X: "test"
	STATE: { code: 101 }
}

// Comprehension ends up inserting in the same arcs over which it
// is iterating. This is fine as long as the set is not altered.
// Issue #1934
selfReferential: T1: {
	S: d: "bar"

	T: e: S: a: "foo"

	for s, v in S for t, _ in T {
		T: (t): S: (s): v
	}
}

// selfReferential comprehenion for list.
// Issue #1934
selfReferential: list: {
	panels: [
		for i, _ in panels {
			id: i
		}
	]
	panels: [{}, {}, {}]
}

selfReferential: insertionError: {
	A: {
		foo: 1
		for x in A {
			// May not insert foo3. Use dynamic references to force the
			// comprehension to be evaluated in the struct in which it is
			// defined.
			("foo3"): 1
		}
	}
}

// A comprehension should not recursively evaluated arcs, so that a
// structural cycle can be avoided when unnecessary.
selfReferential: acrossOr: t1: p1: {
	o: #Output & { retry: reject: "ok" }

	#AllOutputs: {
		reject:   string
		resource: string
		retry: #Output
	}

	#Output: or([for name, config in #AllOutputs {
		(name): config
	}])
}

selfReferential: acrossOr: t1: p2: {
	#Output: or([for name, config in #AllOutputs {
		(name): config
	}])

	o: #Output & { retry: reject: "ok" }

	#AllOutputs: {
		reject:   string
		resource: string
		retry: #Output
	}
}

selfReferential: acrossOr: t1: p3: {
	#Output: or([for name, config in #AllOutputs {
		(name): config
	}])

	#AllOutputs: {
		reject:   string
		resource: string
		retry: #Output
	}

	o: #Output & { retry: reject: "ok" }
}

selfReferential: acrossOr: t2: p1: {
	d: or([for x, y in #A { y }])
	o: d & { b: 2 }
	#A: {
		d1: int
		d2: string
		d3: b: d
	}
}

selfReferential: acrossOr: t2: p2: {
	o: d & { b: 2 }
	d: or([for x, y in #A { y }])
	#A: {
		d1: int
		d2: string
		d3: b: d
	}
}

selfReferential: acrossOr: t2: p3: {
	o: d & { b: 2 }
	#A: {
		d1: int
		d2: string
		d3: b: d
	}
	d: or([for x, y in #A { y }])
}

issue1881: p1: {
	o: #Output & { retry: output: reject: "ok" }

	#AllOutputs: {
		reject:   string
		resource: string
		retry: output: #Output
	}

	#Output: or([for name, config in #AllOutputs {
		(name): config
	}])
}

issue1881: p2: {
	#AllOutputs: {
		reject:   string
		resource: string
		retry: output: #Output
	}

	o: #Output & { retry: output: reject: "ok" }

	#Output: or([for name, config in #AllOutputs {
		(name): config
	}])
}

issue1881: p3: {
	#AllOutputs: {
		reject:   string
		resource: string
		retry: output: #Output
	}

	#Output: or([for name, config in #AllOutputs {
		(name): config
	}])

	o: #Output & { retry: output: reject: "ok" }
}

siblingInsertion: t1: p1: {
	D: "logging": _
	deployment: _

	for k, v in deployment
	for k1, v2 in v.env2 {
		deployment: (k): env: (k1): v2
	}

	for id, v in D {
		deployment: (id): env2: ENV: "True"
	}
}

siblingInsertion: t1: p2: {
	D: "logging": _
	deployment: _

	for id, v in D {
		deployment: (id): env2: ENV: "True"
	}

	for k, v in deployment
	for k1, v2 in v.env2 {
		deployment: (k): env: (k1): v2
	}
}

siblingInsertion: t2: p1: {
	D: "logging": _
	deployment: _

	for k, v in deployment {
		for k1, v2 in v.env2 {
			deployment: (k): env: (k1): v2
		}
	}

	for id, v in D {
		deployment: (id): env2: ENV: "True"
	}
}

siblingInsertion: t2: p2: {
	D: "logging": _
	deployment: _

	for k, v in deployment {
		for k1, v2 in v.env2 {
			deployment: (k): env: (k1): v2
		}
	}

	for id, v in D {
		deployment: (id): env2: ENV: "True"
	}
}

// Issue #1407
// Ensure there is a useful error message.
selfReferential: fail: {
	a: {}
	b: a.x != ""
	if b {
	}
}

// avoid infinite recursion
issue2367: {
	a: _
	for x in [a] {a: x}
}

// evalv2 incorrectly reported structural cycles here.
issue2310: original: {
	#s: {#_1: string, #_2: string, #_3: string, strings.Replace(#_1, #_2, #_3, -1)}

	#sub: {
		#a: string

		// We can't use X=[#a, ...] yet because that is still disallowed
		_#X: [#a, for i in list.Range(0, len(#subs), 1) {#subs[i] & {#_1: _#X[i], _}}]

		// Embedding would not be necessary if the X=[] form was allowed
		_#X[len(_#X)-1]
	}

	res: #sub & {#a: "aaa", _}

	// subs is a series of string substitutions we want to apply
	#subs: [
		#s & {#_2: "a", #_3: "b", _},
		#s & {#_2: "c", #_3: "d", _},
		#s & {#_2: "e", #_3: "f", _},
	]
}
issue2310: reduced: {
	res: {
		#X[3] // Must be at least 3 to cause structural cycle.

		// expanding comprehension eliminates cycle.
		#X: ["X", for i, _ in #subs {#s, #str: #X[i]}]
	}

	#s: {#str: string, #str + "a"}
	#subs: [0, 1, 2]
}
-- issue3903.cue --
issue3903: reduced: {
	s1: #Schema
	s1: _deps: [#Schema]
	#Schema: {
		_deps: [...]

		objs: [
			for dep in _deps
			for obj in (dep & {}).objs {
				obj
			}
		]
	}
}
issue3903: full: {
	s1: #Schema & {
		_deps: [s2]
		_local: ["s1 local"]
	}
	s2: #Schema & {
		_local: ["s2 local"]
	}

	#Schema: {
		_local: [...string]
		_deps: [...]

		objs: [
			for obj in _local { obj },

			for dep in _deps
			for obj in (dep & {}).objs {
				obj
			},
		]
	}
}
-- issue3941.cue --
issue3941: full: {
	#Metadata: name: string
	#Resource: metadata: #Metadata

	out: {
		_metadata: name: "foo"
		resource: [string]: [string]: #Resource

		_names: [_metadata.name]

		for name in _names {
			resource: level1: (name): {
				metadata: _metadata
			}
		}
	}
}
-- out/evalalpha/stats --
Leaks:  2
Freed:  900
Reused: 849
Allocs: 53
Retain: 0

Unifications: 551
Conjuncts:    1605
Disjuncts:    182
Notifications: 14

NumCloseIDs: 703

ConjunctInfos:       1114
MaxConjunctInfos:    10
MaxReqSets:          12
MaxRedirect:         1
-- out/evalalpha --
Errors:
selfReferential.insertionError.A: adding field foo3 not allowed as field set was already referenced:
    ./in.cue:122:14

Result:
(_|_){
  // [eval]
  A: (struct){
    a: (struct){
      parent: (string){ "" }
      children: (#list){
      }
    }
    b: (struct){
      parent: (string){ "a" }
      children: (#list){
      }
    }
  }
  B: (struct){
    a: (struct){
      parent: (string){ "" }
      children: (_|_){
        // [incomplete] B.a.children: cannot range over v.children (incomplete type list):
        //     ./in.cue:24:40
      }
    }
  }
  Issue486: (struct){
    A: (struct){
      a: (struct){
        parent: (string){ "" }
        children: (#list){
          0: (string){ "b" }
        }
      }
      b: (struct){
        parent: (string){ "a" }
        children: (#list){
          0: (string){ "c" }
        }
      }
      c: (struct){
        parent: (string){ "b" }
        children: (#list){
        }
      }
    }
  }
  issue1666: (struct){
    #E: (#struct){
      f1: (#struct){
      }
      f2: (#struct){
      }
    }
    _e: (#struct){
      f2: (#struct){
        a: (#struct){
          t: ~(issue1666.#E)
        }
      }
      f1: (#struct){
      }
    }
    e: (#struct){
      f1: (#struct){
        a: (#struct){
          f1: (#struct){
          }
          f2: (#struct){
          }
        }
      }
      f2: (#struct){
        a: (#struct){
          t: ~(issue1666.#E)
        }
      }
    }
  }
  issue779: (struct){
    X: (string){ "test" }
    STATE: (struct){
      code: (int){ 101 }
    }
    Y: (struct){
      message: (string){ "test" }
      code: (int){ 101 }
    }
  }
  selfReferential: (_|_){
    // [eval]
    T1: (struct){
      S: (struct){
        d: (string){ "bar" }
      }
      T: (struct){
        e: (struct){
          S: (struct){
            a: (string){ "foo" }
            d: (string){ "bar" }
          }
        }
      }
    }
    list: (struct){
      panels: (#list){
        0: (struct){
          id: (int){ 0 }
        }
        1: (struct){
          id: (int){ 1 }
        }
        2: (struct){
          id: (int){ 2 }
        }
      }
    }
    insertionError: (_|_){
      // [eval]
      A: (_|_){
        // [eval] selfReferential.insertionError.A: adding field foo3 not allowed as field set was already referenced:
        //     ./in.cue:122:14
        foo: (int){ 1 }
      }
    }
    acrossOr: (struct){
      t1: (struct){
        p1: (struct){
          o: (#struct){
            retry: (#struct){
              reject: (string){ "ok" }
            }
          }
          #AllOutputs: (#struct){
            reject: (string){ string }
            resource: (string){ string }
            retry: (#struct){ |((#struct){
                reject: (string){ string }
              }, (#struct){
                resource: (string){ string }
              }) }
          }
          #Output: (#struct){ |((#struct){
              reject: (string){ string }
            }, (#struct){
              resource: (string){ string }
            }) }
        }
        p2: (struct){
          #Output: (#struct){ |((#struct){
              reject: (string){ string }
            }, (#struct){
              resource: (string){ string }
            }) }
          o: (#struct){
            retry: (#struct){
              reject: (string){ "ok" }
            }
          }
          #AllOutputs: (#struct){
            reject: (string){ string }
            resource: (string){ string }
            retry: (#struct){ |((#struct){
                reject: (string){ string }
              }, (#struct){
                resource: (string){ string }
              }) }
          }
        }
        p3: (struct){
          #Output: (#struct){ |((#struct){
              reject: (string){ string }
            }, (#struct){
              resource: (string){ string }
            }) }
          #AllOutputs: (#struct){
            reject: (string){ string }
            resource: (string){ string }
            retry: (#struct){ |((#struct){
                reject: (string){ string }
              }, (#struct){
                resource: (string){ string }
              }) }
          }
          o: (#struct){
            retry: (#struct){
              reject: (string){ "ok" }
            }
          }
        }
      }
      t2: (struct){
        p1: (struct){
          d: ((int|string)){ |((int){ int }, (string){ string }) }
          o: (struct){
            b: (int){ 2 }
          }
          #A: (#struct){
            d1: (int){ int }
            d2: (string){ string }
            d3: (#struct){
              b: ((int|string)){ |((int){ int }, (string){ string }) }
            }
          }
        }
        p2: (struct){
          o: (struct){
            b: (int){ 2 }
          }
          d: ((int|string)){ |((int){ int }, (string){ string }) }
          #A: (#struct){
            d1: (int){ int }
            d2: (string){ string }
            d3: (#struct){
              b: ((int|string)){ |((int){ int }, (string){ string }) }
            }
          }
        }
        p3: (struct){
          o: (struct){
            b: (int){ 2 }
          }
          #A: (#struct){
            d1: (int){ int }
            d2: (string){ string }
            d3: (#struct){
              b: ((int|string)){ |((int){ int }, (string){ string }) }
            }
          }
          d: ((int|string)){ |((int){ int }, (string){ string }) }
        }
      }
    }
    fail: (_|_){
      // [incomplete] selfReferential.fail.b: undefined field: x:
      //     ./in.cue:305:7
      a: (struct){
      }
      b: (_|_){
        // [incomplete] selfReferential.fail.b: undefined field: x:
        //     ./in.cue:305:7
      }
    }
  }
  issue1881: (struct){
    p1: (struct){
      o: (#struct){
        retry: (#struct){
          output: (#struct){
            reject: (string){ "ok" }
          }
        }
      }
      #AllOutputs: (#struct){
        reject: (string){ string }
        resource: (string){ string }
        retry: (#struct){
          output: (#struct){ |((#struct){
              reject: (string){ string }
            }, (#struct){
              resource: (string){ string }
            }) }
        }
      }
      #Output: (#struct){ |((#struct){
          reject: (string){ string }
        }, (#struct){
          resource: (string){ string }
        }) }
    }
    p2: (struct){
      #AllOutputs: (#struct){
        reject: (string){ string }
        resource: (string){ string }
        retry: (#struct){
          output: (#struct){ |((#struct){
              reject: (string){ string }
            }, (#struct){
              resource: (string){ string }
            }) }
        }
      }
      o: (#struct){
        retry: (#struct){
          output: (#struct){
            reject: (string){ "ok" }
          }
        }
      }
      #Output: (#struct){ |((#struct){
          reject: (string){ string }
        }, (#struct){
          resource: (string){ string }
        }) }
    }
    p3: (struct){
      #AllOutputs: (#struct){
        reject: (string){ string }
        resource: (string){ string }
        retry: (#struct){
          output: (#struct){ |((#struct){
              reject: (string){ string }
            }, (#struct){
              resource: (string){ string }
            }) }
        }
      }
      #Output: (#struct){ |((#struct){
          reject: (string){ string }
        }, (#struct){
          resource: (string){ string }
        }) }
      o: (#struct){
        retry: (#struct){
          output: (#struct){
            reject: (string){ "ok" }
          }
        }
      }
    }
  }
  siblingInsertion: (struct){
    t1: (struct){
      p1: (struct){
        D: (struct){
          logging: (_){ _ }
        }
        deployment: (struct){
          logging: (struct){
            env2: (struct){
              ENV: (string){ "True" }
            }
            env: (struct){
              ENV: (string){ "True" }
            }
          }
        }
      }
      p2: (struct){
        D: (struct){
          logging: (_){ _ }
        }
        deployment: (struct){
          logging: (struct){
            env2: (struct){
              ENV: (string){ "True" }
            }
            env: (struct){
              ENV: (string){ "True" }
            }
          }
        }
      }
    }
    t2: (struct){
      p1: (struct){
        D: (struct){
          logging: (_){ _ }
        }
        deployment: (struct){
          logging: (struct){
            env2: (struct){
              ENV: (string){ "True" }
            }
            env: (struct){
              ENV: (string){ "True" }
            }
          }
        }
      }
      p2: (struct){
        D: (struct){
          logging: (_){ _ }
        }
        deployment: (struct){
          logging: (struct){
            env2: (struct){
              ENV: (string){ "True" }
            }
            env: (struct){
              ENV: (string){ "True" }
            }
          }
        }
      }
    }
  }
  issue2367: (struct){
    a: (_){ _ }
  }
  issue2310: (struct){
    original: (struct){
      #s: (_|_){
        // [incomplete] issue2310.original.#s: error in call to strings.Replace: non-concrete value string:
        //     ./in.cue:318:46
        //     ./in.cue:318:38
        #_1: (string){ string }
        #_2: (string){ string }
        #_3: (string){ string }
      }
      #sub: (_|_){
        // [incomplete] issue2310.original.#sub.#_1.#_1: error in call to strings.Replace: non-concrete value string:
        //     ./in.cue:318:46
        //     ./in.cue:318:12
        #a: (string){ string }
        _#X: (#list){
          0: (string){ string }
          1: (_|_){
            // [incomplete] issue2310.original.#sub._#X.1: error in call to strings.Replace: non-concrete value string:
            //     ./in.cue:318:46
            //     ./in.cue:318:12
            #_1: (string){ string }
            #_2: (string){ "a" }
            #_3: (string){ "b" }
          }
          2: (_|_){
            // [incomplete] issue2310.original.#sub._#X.2.#_1: error in call to strings.Replace: non-concrete value string:
            //     ./in.cue:318:46
            //     ./in.cue:318:12
            #_1: (_|_){
              // [incomplete] issue2310.original.#sub._#X.2.#_1: error in call to strings.Replace: non-concrete value string:
              //     ./in.cue:318:46
              //     ./in.cue:318:12
              #_1: (string){ string }
              #_2: (string){ "a" }
              #_3: (string){ "b" }
            }
            #_2: (string){ "c" }
            #_3: (string){ "d" }
          }
          3: (_|_){
            // [incomplete] issue2310.original.#sub._#X.3.#_1.#_1: error in call to strings.Replace: non-concrete value string:
            //     ./in.cue:318:46
            //     ./in.cue:318:12
            #_1: (_|_){
              // [incomplete] issue2310.original.#sub._#X.3.#_1.#_1: error in call to strings.Replace: non-concrete value string:
              //     ./in.cue:318:46
              //     ./in.cue:318:12
              #_1: (_|_){
                // [incomplete] issue2310.original.#sub._#X.3.#_1.#_1: error in call to strings.Replace: non-concrete value string:
                //     ./in.cue:318:46
                //     ./in.cue:318:12
                #_1: (string){ string }
                #_2: (string){ "a" }
                #_3: (string){ "b" }
              }
              #_2: (string){ "c" }
              #_3: (string){ "d" }
            }
            #_2: (string){ "e" }
            #_3: (string){ "f" }
          }
        }
        #_1: (_|_){
          // [incomplete] issue2310.original.#sub.#_1.#_1: error in call to strings.Replace: non-concrete value string:
          //     ./in.cue:318:46
          //     ./in.cue:318:12
          #_1: (_|_){
            // [incomplete] issue2310.original.#sub.#_1.#_1: error in call to strings.Replace: non-concrete value string:
            //     ./in.cue:318:46
            //     ./in.cue:318:12
            #_1: (string){ string }
            #_2: (string){ "a" }
            #_3: (string){ "b" }
          }
          #_2: (string){ "c" }
          #_3: (string){ "d" }
        }
        #_2: (string){ "e" }
        #_3: (string){ "f" }
      }
      res: (string){
        "bbb"
        #a: (string){ "aaa" }
        _#X: (#list){
          0: (string){ "aaa" }
          1: (string){
            "bbb"
            #_1: (string){ "aaa" }
            #_2: (string){ "a" }
            #_3: (string){ "b" }
          }
          2: (string){
            "bbb"
            #_1: (string){
              "bbb"
              #_1: (string){ "aaa" }
              #_2: (string){ "a" }
              #_3: (string){ "b" }
            }
            #_2: (string){ "c" }
            #_3: (string){ "d" }
          }
          3: (string){
            "bbb"
            #_1: (string){
              "bbb"
              #_1: (string){
                "bbb"
                #_1: (string){ "aaa" }
                #_2: (string){ "a" }
                #_3: (string){ "b" }
              }
              #_2: (string){ "c" }
              #_3: (string){ "d" }
            }
            #_2: (string){ "e" }
            #_3: (string){ "f" }
          }
        }
        #_1: (string){
          "bbb"
          #_1: (string){
            "bbb"
            #_1: (string){ "aaa" }
            #_2: (string){ "a" }
            #_3: (string){ "b" }
          }
          #_2: (string){ "c" }
          #_3: (string){ "d" }
        }
        #_2: (string){ "e" }
        #_3: (string){ "f" }
      }
      #subs: (#list){
        0: (_|_){
          // [incomplete] issue2310.original.#subs.0: error in call to strings.Replace: non-concrete value string:
          //     ./in.cue:318:46
          //     ./in.cue:318:12
          #_2: (string){ "a" }
          #_3: (string){ "b" }
          #_1: (string){ string }
        }
        1: (_|_){
          // [incomplete] issue2310.original.#subs.1: error in call to strings.Replace: non-concrete value string:
          //     ./in.cue:318:46
          //     ./in.cue:318:12
          #_2: (string){ "c" }
          #_3: (string){ "d" }
          #_1: (string){ string }
        }
        2: (_|_){
          // [incomplete] issue2310.original.#subs.2: error in call to strings.Replace: non-concrete value string:
          //     ./in.cue:318:46
          //     ./in.cue:318:12
          #_2: (string){ "e" }
          #_3: (string){ "f" }
          #_1: (string){ string }
        }
      }
    }
    reduced: (struct){
      res: (string){
        "Xaaa"
        #X: (#list){
          0: (string){ "X" }
          1: (string){
            "Xa"
            #str: (string){ "X" }
          }
          2: (string){
            "Xaa"
            #str: (string){
              "Xa"
              #str: (string){ "X" }
            }
          }
          3: (string){
            "Xaaa"
            #str: (string){
              "Xaa"
              #str: (string){
                "Xa"
                #str: (string){ "X" }
              }
            }
          }
        }
        #str: (string){
          "Xaa"
          #str: (string){
            "Xa"
            #str: (string){ "X" }
          }
        }
      }
      #s: (_|_){
        // [incomplete] issue2310.reduced.#s: non-concrete value string in operand to +:
        //     ./in.cue:347:21
        //     ./in.cue:347:13
        #str: (string){ string }
      }
      #subs: (#list){
        0: (int){ 0 }
        1: (int){ 1 }
        2: (int){ 2 }
      }
    }
  }
  issue3903: (struct){
    reduced: (struct){
      s1: (#struct){
        _deps: (#list){
          0: (#struct){
            _deps: (list){
            }
            objs: (#list){
            }
          }
        }
        objs: (#list){
        }
      }
      #Schema: (#struct){
        _deps: (list){
        }
        objs: (#list){
        }
      }
    }
    full: (struct){
      s1: (#struct){
        _deps: (#list){
          0: (#struct){
            _local: (#list){
              0: (string){ "s2 local" }
            }
            _deps: (list){
            }
            objs: (#list){
              0: (string){ "s2 local" }
            }
          }
        }
        _local: (#list){
          0: (string){ "s1 local" }
        }
        objs: (#list){
          0: (string){ "s1 local" }
          1: (string){ "s2 local" }
        }
      }
      s2: (#struct){
        _local: (#list){
          0: (string){ "s2 local" }
        }
        _deps: (list){
        }
        objs: (#list){
          0: (string){ "s2 local" }
        }
      }
      #Schema: (#struct){
        _local: (list){
        }
        _deps: (list){
        }
        objs: (#list){
        }
      }
    }
  }
  issue3941: (struct){
    full: (struct){
      #Metadata: (#struct){
        name: (string){ string }
      }
      #Resource: (#struct){
        metadata: ~(issue3941.full.#Metadata)
      }
      out: (struct){
        _metadata: (struct){
          name: (string){ "foo" }
        }
        resource: (struct){
          level1: (struct){
            foo: (#struct){
              metadata: (#struct){
                name: (string){ "foo" }
              }
            }
          }
        }
        _names: (#list){
          0: (string){ "foo" }
        }
      }
    }
  }
}
-- diff/-out/evalalpha<==>+out/eval --
diff old new
--- old
+++ new
@@ -1,13 +1,6 @@
 Errors:
-selfReferential.insertionError.A: field foo3 not allowed by earlier comprehension or reference cycle
-issue2310.original.#sub.#_1.#_1.#_1: structural cycle:
-    ./in.cue:318:62
-issue2310.original.#sub._#X.3.#_1.#_1.#_1: structural cycle:
-    ./in.cue:318:62
-issue2310.reduced.res.#X.3.#str.#str.#str: structural cycle:
-    ./in.cue:347:21
-issue2310.reduced.res.#str.#str.#str: structural cycle:
-    ./in.cue:347:21
+selfReferential.insertionError.A: adding field foo3 not allowed as field set was already referenced:
+    ./in.cue:122:14
 
 Result:
 (_|_){
@@ -27,7 +20,9 @@
   B: (struct){
     a: (struct){
       parent: (string){ "" }
-      children: (#list){
+      children: (_|_){
+        // [incomplete] B.a.children: cannot range over v.children (incomplete type list):
+        //     ./in.cue:24:40
       }
     }
   }
@@ -60,17 +55,12 @@
       }
     }
     _e: (#struct){
-      f1: (#struct){
-      }
-      f2: (#struct){
-        a: (#struct){
-          t: (#struct){
-            f1: (#struct){
-            }
-            f2: (#struct){
-            }
-          }
-        }
+      f2: (#struct){
+        a: (#struct){
+          t: ~(issue1666.#E)
+        }
+      }
+      f1: (#struct){
       }
     }
     e: (#struct){
@@ -84,12 +74,7 @@
       }
       f2: (#struct){
         a: (#struct){
-          t: (#struct){
-            f1: (#struct){
-            }
-            f2: (#struct){
-            }
-          }
+          t: ~(issue1666.#E)
         }
       }
     }
@@ -135,9 +120,9 @@
     insertionError: (_|_){
       // [eval]
       A: (_|_){
-        // [eval] selfReferential.insertionError.A: field foo3 not allowed by earlier comprehension or reference cycle
+        // [eval] selfReferential.insertionError.A: adding field foo3 not allowed as field set was already referenced:
+        //     ./in.cue:122:14
         foo: (int){ 1 }
-        foo3: (int){ 1 }
       }
     }
     acrossOr: (struct){
@@ -405,10 +390,8 @@
   issue2367: (struct){
     a: (_){ _ }
   }
-  issue2310: (_|_){
-    // [structural cycle]
-    original: (_|_){
-      // [structural cycle]
+  issue2310: (struct){
+    original: (struct){
       #s: (_|_){
         // [incomplete] issue2310.original.#s: error in call to strings.Replace: non-concrete value string:
         //     ./in.cue:318:46
@@ -418,14 +401,128 @@
         #_3: (string){ string }
       }
       #sub: (_|_){
-        // [structural cycle] issue2310.original.#sub.#_1.#_1.#_1: structural cycle:
-        //     ./in.cue:318:62
-      }
-      res: (_|_){
-        // [structural cycle] issue2310.original.#sub.#_1.#_1.#_1: structural cycle:
-        //     ./in.cue:318:62
-        // issue2310.original.#sub._#X.3.#_1.#_1.#_1: structural cycle:
-        //     ./in.cue:318:62
+        // [incomplete] issue2310.original.#sub.#_1.#_1: error in call to strings.Replace: non-concrete value string:
+        //     ./in.cue:318:46
+        //     ./in.cue:318:12
+        #a: (string){ string }
+        _#X: (#list){
+          0: (string){ string }
+          1: (_|_){
+            // [incomplete] issue2310.original.#sub._#X.1: error in call to strings.Replace: non-concrete value string:
+            //     ./in.cue:318:46
+            //     ./in.cue:318:12
+            #_1: (string){ string }
+            #_2: (string){ "a" }
+            #_3: (string){ "b" }
+          }
+          2: (_|_){
+            // [incomplete] issue2310.original.#sub._#X.2.#_1: error in call to strings.Replace: non-concrete value string:
+            //     ./in.cue:318:46
+            //     ./in.cue:318:12
+            #_1: (_|_){
+              // [incomplete] issue2310.original.#sub._#X.2.#_1: error in call to strings.Replace: non-concrete value string:
+              //     ./in.cue:318:46
+              //     ./in.cue:318:12
+              #_1: (string){ string }
+              #_2: (string){ "a" }
+              #_3: (string){ "b" }
+            }
+            #_2: (string){ "c" }
+            #_3: (string){ "d" }
+          }
+          3: (_|_){
+            // [incomplete] issue2310.original.#sub._#X.3.#_1.#_1: error in call to strings.Replace: non-concrete value string:
+            //     ./in.cue:318:46
+            //     ./in.cue:318:12
+            #_1: (_|_){
+              // [incomplete] issue2310.original.#sub._#X.3.#_1.#_1: error in call to strings.Replace: non-concrete value string:
+              //     ./in.cue:318:46
+              //     ./in.cue:318:12
+              #_1: (_|_){
+                // [incomplete] issue2310.original.#sub._#X.3.#_1.#_1: error in call to strings.Replace: non-concrete value string:
+                //     ./in.cue:318:46
+                //     ./in.cue:318:12
+                #_1: (string){ string }
+                #_2: (string){ "a" }
+                #_3: (string){ "b" }
+              }
+              #_2: (string){ "c" }
+              #_3: (string){ "d" }
+            }
+            #_2: (string){ "e" }
+            #_3: (string){ "f" }
+          }
+        }
+        #_1: (_|_){
+          // [incomplete] issue2310.original.#sub.#_1.#_1: error in call to strings.Replace: non-concrete value string:
+          //     ./in.cue:318:46
+          //     ./in.cue:318:12
+          #_1: (_|_){
+            // [incomplete] issue2310.original.#sub.#_1.#_1: error in call to strings.Replace: non-concrete value string:
+            //     ./in.cue:318:46
+            //     ./in.cue:318:12
+            #_1: (string){ string }
+            #_2: (string){ "a" }
+            #_3: (string){ "b" }
+          }
+          #_2: (string){ "c" }
+          #_3: (string){ "d" }
+        }
+        #_2: (string){ "e" }
+        #_3: (string){ "f" }
+      }
+      res: (string){
+        "bbb"
+        #a: (string){ "aaa" }
+        _#X: (#list){
+          0: (string){ "aaa" }
+          1: (string){
+            "bbb"
+            #_1: (string){ "aaa" }
+            #_2: (string){ "a" }
+            #_3: (string){ "b" }
+          }
+          2: (string){
+            "bbb"
+            #_1: (string){
+              "bbb"
+              #_1: (string){ "aaa" }
+              #_2: (string){ "a" }
+              #_3: (string){ "b" }
+            }
+            #_2: (string){ "c" }
+            #_3: (string){ "d" }
+          }
+          3: (string){
+            "bbb"
+            #_1: (string){
+              "bbb"
+              #_1: (string){
+                "bbb"
+                #_1: (string){ "aaa" }
+                #_2: (string){ "a" }
+                #_3: (string){ "b" }
+              }
+              #_2: (string){ "c" }
+              #_3: (string){ "d" }
+            }
+            #_2: (string){ "e" }
+            #_3: (string){ "f" }
+          }
+        }
+        #_1: (string){
+          "bbb"
+          #_1: (string){
+            "bbb"
+            #_1: (string){ "aaa" }
+            #_2: (string){ "a" }
+            #_3: (string){ "b" }
+          }
+          #_2: (string){ "c" }
+          #_3: (string){ "d" }
+        }
+        #_2: (string){ "e" }
+        #_3: (string){ "f" }
       }
       #subs: (#list){
         0: (_|_){
@@ -432,33 +529,62 @@
           // [incomplete] issue2310.original.#subs.0: error in call to strings.Replace: non-concrete value string:
           //     ./in.cue:318:46
           //     ./in.cue:318:12
-          #_1: (string){ string }
           #_2: (string){ "a" }
           #_3: (string){ "b" }
+          #_1: (string){ string }
         }
         1: (_|_){
           // [incomplete] issue2310.original.#subs.1: error in call to strings.Replace: non-concrete value string:
           //     ./in.cue:318:46
           //     ./in.cue:318:12
-          #_1: (string){ string }
-          #_2: (string){ "c" }
-          #_3: (string){ "d" }
+          #_2: (string){ "c" }
+          #_3: (string){ "d" }
+          #_1: (string){ string }
         }
         2: (_|_){
           // [incomplete] issue2310.original.#subs.2: error in call to strings.Replace: non-concrete value string:
           //     ./in.cue:318:46
           //     ./in.cue:318:12
-          #_1: (string){ string }
           #_2: (string){ "e" }
           #_3: (string){ "f" }
-        }
-      }
-    }
-    reduced: (_|_){
-      // [structural cycle]
-      res: (_|_){
-        // [structural cycle] issue2310.reduced.res.#str.#str.#str: structural cycle:
-        //     ./in.cue:347:21
+          #_1: (string){ string }
+        }
+      }
+    }
+    reduced: (struct){
+      res: (string){
+        "Xaaa"
+        #X: (#list){
+          0: (string){ "X" }
+          1: (string){
+            "Xa"
+            #str: (string){ "X" }
+          }
+          2: (string){
+            "Xaa"
+            #str: (string){
+              "Xa"
+              #str: (string){ "X" }
+            }
+          }
+          3: (string){
+            "Xaaa"
+            #str: (string){
+              "Xaa"
+              #str: (string){
+                "Xa"
+                #str: (string){ "X" }
+              }
+            }
+          }
+        }
+        #str: (string){
+          "Xaa"
+          #str: (string){
+            "Xa"
+            #str: (string){ "X" }
+          }
+        }
       }
       #s: (_|_){
         // [incomplete] issue2310.reduced.#s: non-concrete value string in operand to +:
@@ -496,9 +622,6 @@
     }
     full: (struct){
       s1: (#struct){
-        _local: (#list){
-          0: (string){ "s1 local" }
-        }
         _deps: (#list){
           0: (#struct){
             _local: (#list){
@@ -511,6 +634,9 @@
             }
           }
         }
+        _local: (#list){
+          0: (string){ "s1 local" }
+        }
         objs: (#list){
           0: (string){ "s1 local" }
           1: (string){ "s2 local" }
@@ -542,9 +668,7 @@
         name: (string){ string }
       }
       #Resource: (#struct){
-        metadata: (#struct){
-          name: (string){ string }
-        }
+        metadata: ~(issue3941.full.#Metadata)
       }
       out: (struct){
         _metadata: (struct){
-- diff/-out/evalalpha/stats<==>+out/eval/stats --
diff old new
--- old
+++ new
@@ -1,13 +1,17 @@
-Leaks:  82
-Freed:  1376
-Reused: 1358
-Allocs: 100
-Retain: 492
-
-Unifications: 970
-Conjuncts:    2971
-Disjuncts:    1707
-
-MisalignedConjunct: 268
-
-NumCloseIDs: 16
+Leaks:  2
+Freed:  900
+Reused: 849
+Allocs: 53
+Retain: 0
+
+Unifications: 551
+Conjuncts:    1605
+Disjuncts:    182
+Notifications: 14
+
+NumCloseIDs: 703
+
+ConjunctInfos:       1114
+MaxConjunctInfos:    10
+MaxReqSets:          12
+MaxRedirect:         1
-- out/eval/stats --
Leaks:  82
Freed:  1376
Reused: 1358
Allocs: 100
Retain: 492

Unifications: 970
Conjuncts:    2971
Disjuncts:    1707

MisalignedConjunct: 268

NumCloseIDs: 16
-- diff/explanation --
B.a.children: now correctly marked as incomplete
-- out/eval --
Errors:
selfReferential.insertionError.A: field foo3 not allowed by earlier comprehension or reference cycle
issue2310.original.#sub.#_1.#_1.#_1: structural cycle:
    ./in.cue:318:62
issue2310.original.#sub._#X.3.#_1.#_1.#_1: structural cycle:
    ./in.cue:318:62
issue2310.reduced.res.#X.3.#str.#str.#str: structural cycle:
    ./in.cue:347:21
issue2310.reduced.res.#str.#str.#str: structural cycle:
    ./in.cue:347:21

Result:
(_|_){
  // [eval]
  A: (struct){
    a: (struct){
      parent: (string){ "" }
      children: (#list){
      }
    }
    b: (struct){
      parent: (string){ "a" }
      children: (#list){
      }
    }
  }
  B: (struct){
    a: (struct){
      parent: (string){ "" }
      children: (#list){
      }
    }
  }
  Issue486: (struct){
    A: (struct){
      a: (struct){
        parent: (string){ "" }
        children: (#list){
          0: (string){ "b" }
        }
      }
      b: (struct){
        parent: (string){ "a" }
        children: (#list){
          0: (string){ "c" }
        }
      }
      c: (struct){
        parent: (string){ "b" }
        children: (#list){
        }
      }
    }
  }
  issue1666: (struct){
    #E: (#struct){
      f1: (#struct){
      }
      f2: (#struct){
      }
    }
    _e: (#struct){
      f1: (#struct){
      }
      f2: (#struct){
        a: (#struct){
          t: (#struct){
            f1: (#struct){
            }
            f2: (#struct){
            }
          }
        }
      }
    }
    e: (#struct){
      f1: (#struct){
        a: (#struct){
          f1: (#struct){
          }
          f2: (#struct){
          }
        }
      }
      f2: (#struct){
        a: (#struct){
          t: (#struct){
            f1: (#struct){
            }
            f2: (#struct){
            }
          }
        }
      }
    }
  }
  issue779: (struct){
    X: (string){ "test" }
    STATE: (struct){
      code: (int){ 101 }
    }
    Y: (struct){
      message: (string){ "test" }
      code: (int){ 101 }
    }
  }
  selfReferential: (_|_){
    // [eval]
    T1: (struct){
      S: (struct){
        d: (string){ "bar" }
      }
      T: (struct){
        e: (struct){
          S: (struct){
            a: (string){ "foo" }
            d: (string){ "bar" }
          }
        }
      }
    }
    list: (struct){
      panels: (#list){
        0: (struct){
          id: (int){ 0 }
        }
        1: (struct){
          id: (int){ 1 }
        }
        2: (struct){
          id: (int){ 2 }
        }
      }
    }
    insertionError: (_|_){
      // [eval]
      A: (_|_){
        // [eval] selfReferential.insertionError.A: field foo3 not allowed by earlier comprehension or reference cycle
        foo: (int){ 1 }
        foo3: (int){ 1 }
      }
    }
    acrossOr: (struct){
      t1: (struct){
        p1: (struct){
          o: (#struct){
            retry: (#struct){
              reject: (string){ "ok" }
            }
          }
          #AllOutputs: (#struct){
            reject: (string){ string }
            resource: (string){ string }
            retry: (#struct){ |((#struct){
                reject: (string){ string }
              }, (#struct){
                resource: (string){ string }
              }) }
          }
          #Output: (#struct){ |((#struct){
              reject: (string){ string }
            }, (#struct){
              resource: (string){ string }
            }) }
        }
        p2: (struct){
          #Output: (#struct){ |((#struct){
              reject: (string){ string }
            }, (#struct){
              resource: (string){ string }
            }) }
          o: (#struct){
            retry: (#struct){
              reject: (string){ "ok" }
            }
          }
          #AllOutputs: (#struct){
            reject: (string){ string }
            resource: (string){ string }
            retry: (#struct){ |((#struct){
                reject: (string){ string }
              }, (#struct){
                resource: (string){ string }
              }) }
          }
        }
        p3: (struct){
          #Output: (#struct){ |((#struct){
              reject: (string){ string }
            }, (#struct){
              resource: (string){ string }
            }) }
          #AllOutputs: (#struct){
            reject: (string){ string }
            resource: (string){ string }
            retry: (#struct){ |((#struct){
                reject: (string){ string }
              }, (#struct){
                resource: (string){ string }
              }) }
          }
          o: (#struct){
            retry: (#struct){
              reject: (string){ "ok" }
            }
          }
        }
      }
      t2: (struct){
        p1: (struct){
          d: ((int|string)){ |((int){ int }, (string){ string }) }
          o: (struct){
            b: (int){ 2 }
          }
          #A: (#struct){
            d1: (int){ int }
            d2: (string){ string }
            d3: (#struct){
              b: ((int|string)){ |((int){ int }, (string){ string }) }
            }
          }
        }
        p2: (struct){
          o: (struct){
            b: (int){ 2 }
          }
          d: ((int|string)){ |((int){ int }, (string){ string }) }
          #A: (#struct){
            d1: (int){ int }
            d2: (string){ string }
            d3: (#struct){
              b: ((int|string)){ |((int){ int }, (string){ string }) }
            }
          }
        }
        p3: (struct){
          o: (struct){
            b: (int){ 2 }
          }
          #A: (#struct){
            d1: (int){ int }
            d2: (string){ string }
            d3: (#struct){
              b: ((int|string)){ |((int){ int }, (string){ string }) }
            }
          }
          d: ((int|string)){ |((int){ int }, (string){ string }) }
        }
      }
    }
    fail: (_|_){
      // [incomplete] selfReferential.fail.b: undefined field: x:
      //     ./in.cue:305:7
      a: (struct){
      }
      b: (_|_){
        // [incomplete] selfReferential.fail.b: undefined field: x:
        //     ./in.cue:305:7
      }
    }
  }
  issue1881: (struct){
    p1: (struct){
      o: (#struct){
        retry: (#struct){
          output: (#struct){
            reject: (string){ "ok" }
          }
        }
      }
      #AllOutputs: (#struct){
        reject: (string){ string }
        resource: (string){ string }
        retry: (#struct){
          output: (#struct){ |((#struct){
              reject: (string){ string }
            }, (#struct){
              resource: (string){ string }
            }) }
        }
      }
      #Output: (#struct){ |((#struct){
          reject: (string){ string }
        }, (#struct){
          resource: (string){ string }
        }) }
    }
    p2: (struct){
      #AllOutputs: (#struct){
        reject: (string){ string }
        resource: (string){ string }
        retry: (#struct){
          output: (#struct){ |((#struct){
              reject: (string){ string }
            }, (#struct){
              resource: (string){ string }
            }) }
        }
      }
      o: (#struct){
        retry: (#struct){
          output: (#struct){
            reject: (string){ "ok" }
          }
        }
      }
      #Output: (#struct){ |((#struct){
          reject: (string){ string }
        }, (#struct){
          resource: (string){ string }
        }) }
    }
    p3: (struct){
      #AllOutputs: (#struct){
        reject: (string){ string }
        resource: (string){ string }
        retry: (#struct){
          output: (#struct){ |((#struct){
              reject: (string){ string }
            }, (#struct){
              resource: (string){ string }
            }) }
        }
      }
      #Output: (#struct){ |((#struct){
          reject: (string){ string }
        }, (#struct){
          resource: (string){ string }
        }) }
      o: (#struct){
        retry: (#struct){
          output: (#struct){
            reject: (string){ "ok" }
          }
        }
      }
    }
  }
  siblingInsertion: (struct){
    t1: (struct){
      p1: (struct){
        D: (struct){
          logging: (_){ _ }
        }
        deployment: (struct){
          logging: (struct){
            env2: (struct){
              ENV: (string){ "True" }
            }
            env: (struct){
              ENV: (string){ "True" }
            }
          }
        }
      }
      p2: (struct){
        D: (struct){
          logging: (_){ _ }
        }
        deployment: (struct){
          logging: (struct){
            env2: (struct){
              ENV: (string){ "True" }
            }
            env: (struct){
              ENV: (string){ "True" }
            }
          }
        }
      }
    }
    t2: (struct){
      p1: (struct){
        D: (struct){
          logging: (_){ _ }
        }
        deployment: (struct){
          logging: (struct){
            env2: (struct){
              ENV: (string){ "True" }
            }
            env: (struct){
              ENV: (string){ "True" }
            }
          }
        }
      }
      p2: (struct){
        D: (struct){
          logging: (_){ _ }
        }
        deployment: (struct){
          logging: (struct){
            env2: (struct){
              ENV: (string){ "True" }
            }
            env: (struct){
              ENV: (string){ "True" }
            }
          }
        }
      }
    }
  }
  issue2367: (struct){
    a: (_){ _ }
  }
  issue2310: (_|_){
    // [structural cycle]
    original: (_|_){
      // [structural cycle]
      #s: (_|_){
        // [incomplete] issue2310.original.#s: error in call to strings.Replace: non-concrete value string:
        //     ./in.cue:318:46
        //     ./in.cue:318:38
        #_1: (string){ string }
        #_2: (string){ string }
        #_3: (string){ string }
      }
      #sub: (_|_){
        // [structural cycle] issue2310.original.#sub.#_1.#_1.#_1: structural cycle:
        //     ./in.cue:318:62
      }
      res: (_|_){
        // [structural cycle] issue2310.original.#sub.#_1.#_1.#_1: structural cycle:
        //     ./in.cue:318:62
        // issue2310.original.#sub._#X.3.#_1.#_1.#_1: structural cycle:
        //     ./in.cue:318:62
      }
      #subs: (#list){
        0: (_|_){
          // [incomplete] issue2310.original.#subs.0: error in call to strings.Replace: non-concrete value string:
          //     ./in.cue:318:46
          //     ./in.cue:318:12
          #_1: (string){ string }
          #_2: (string){ "a" }
          #_3: (string){ "b" }
        }
        1: (_|_){
          // [incomplete] issue2310.original.#subs.1: error in call to strings.Replace: non-concrete value string:
          //     ./in.cue:318:46
          //     ./in.cue:318:12
          #_1: (string){ string }
          #_2: (string){ "c" }
          #_3: (string){ "d" }
        }
        2: (_|_){
          // [incomplete] issue2310.original.#subs.2: error in call to strings.Replace: non-concrete value string:
          //     ./in.cue:318:46
          //     ./in.cue:318:12
          #_1: (string){ string }
          #_2: (string){ "e" }
          #_3: (string){ "f" }
        }
      }
    }
    reduced: (_|_){
      // [structural cycle]
      res: (_|_){
        // [structural cycle] issue2310.reduced.res.#str.#str.#str: structural cycle:
        //     ./in.cue:347:21
      }
      #s: (_|_){
        // [incomplete] issue2310.reduced.#s: non-concrete value string in operand to +:
        //     ./in.cue:347:21
        //     ./in.cue:347:13
        #str: (string){ string }
      }
      #subs: (#list){
        0: (int){ 0 }
        1: (int){ 1 }
        2: (int){ 2 }
      }
    }
  }
  issue3903: (struct){
    reduced: (struct){
      s1: (#struct){
        _deps: (#list){
          0: (#struct){
            _deps: (list){
            }
            objs: (#list){
            }
          }
        }
        objs: (#list){
        }
      }
      #Schema: (#struct){
        _deps: (list){
        }
        objs: (#list){
        }
      }
    }
    full: (struct){
      s1: (#struct){
        _local: (#list){
          0: (string){ "s1 local" }
        }
        _deps: (#list){
          0: (#struct){
            _local: (#list){
              0: (string){ "s2 local" }
            }
            _deps: (list){
            }
            objs: (#list){
              0: (string){ "s2 local" }
            }
          }
        }
        objs: (#list){
          0: (string){ "s1 local" }
          1: (string){ "s2 local" }
        }
      }
      s2: (#struct){
        _local: (#list){
          0: (string){ "s2 local" }
        }
        _deps: (list){
        }
        objs: (#list){
          0: (string){ "s2 local" }
        }
      }
      #Schema: (#struct){
        _local: (list){
        }
        _deps: (list){
        }
        objs: (#list){
        }
      }
    }
  }
  issue3941: (struct){
    full: (struct){
      #Metadata: (#struct){
        name: (string){ string }
      }
      #Resource: (#struct){
        metadata: (#struct){
          name: (string){ string }
        }
      }
      out: (struct){
        _metadata: (struct){
          name: (string){ "foo" }
        }
        resource: (struct){
          level1: (struct){
            foo: (#struct){
              metadata: (#struct){
                name: (string){ "foo" }
              }
            }
          }
        }
        _names: (#list){
          0: (string){ "foo" }
        }
      }
    }
  }
}
-- out/compile --
--- in.cue
{
  A: {
    a: {
      parent: ""
      children: [
        for k, v in 〈3;A〉 if (〈0;v〉.parent == 〈0;k〉) {
          〈1;k〉
        },
      ]
    }
    b: {
      parent: "a"
      children: [
        for k, v in 〈3;A〉 if (〈0;v〉.parent == 〈0;k〉) {
          〈1;k〉
        },
      ]
    }
  }
  B: {
    a: {
      parent: ""
      children: [
        for k, v in 〈3;B〉 for _, w in 〈0;v〉.children {
          〈2;k〉
        },
      ]
    }
  }
  Issue486: {
    A: {
      a: {
        parent: ""
        children: [
          ...string,
        ]
      }
      b: {
        parent: "a"
        children: [
          ...string,
        ]
      }
      c: {
        parent: "b"
        children: [
          ...string,
        ]
      }
    }
    A: {
      [string]: {
        children: [
          for k, v in 〈3;A〉 if (〈0;v〉.parent == 〈3;-〉) {
            〈1;k〉
          },
        ]
      }
    }
  }
  issue1666: {
    #E: {
      f1: {
        [string]: (〈2;#E〉|[
          ...〈3;#E〉,
        ])
      }
      f2: {
        [string]: {
          t: 〈3;#E〉
        }
      }
    }
    _e: 〈0;#E〉
    _e: {
      f2: {
        a: _
      }
    }
    e: (〈0;_e〉 & {
      f1: {
        for fk, s in 〈2;_e〉.f2 {
          〈1;fk〉: 〈1;s〉.t
        }
      }
    })
  }
  issue779: {
    X: 〈0;Y〉.message
    STATE: {
      for k, v in 〈1;Y〉 {
        if (〈1;k〉 != "message") {
          "\(〈2;k〉)": 〈2;v〉
        }
      }
    }
    Y: (〈0;STATE〉 & {
      message: 〈1;X〉
    })
    X: "test"
    STATE: {
      code: 101
    }
  }
  selfReferential: {
    T1: {
      S: {
        d: "bar"
      }
      T: {
        e: {
          S: {
            a: "foo"
          }
        }
      }
      for s, v in 〈0;S〉 for t, _ in 〈1;T〉 {
        T: {
          〈2;t〉: {
            S: {
              〈5;s〉: 〈5;v〉
            }
          }
        }
      }
    }
  }
  selfReferential: {
    list: {
      panels: [
        for i, _ in 〈1;panels〉 {
          id: 〈1;i〉
        },
      ]
      panels: [
        {},
        {},
        {},
      ]
    }
  }
  selfReferential: {
    insertionError: {
      A: {
        foo: 1
        for _, x in 〈1;A〉 {
          "foo3": 1
        }
      }
    }
  }
  selfReferential: {
    acrossOr: {
      t1: {
        p1: {
          o: (〈0;#Output〉 & {
            retry: {
              reject: "ok"
            }
          })
          #AllOutputs: {
            reject: string
            resource: string
            retry: 〈1;#Output〉
          }
          #Output: or([
            for name, config in 〈1;#AllOutputs〉 {
              〈1;name〉: 〈1;config〉
            },
          ])
        }
      }
    }
  }
  selfReferential: {
    acrossOr: {
      t1: {
        p2: {
          #Output: or([
            for name, config in 〈1;#AllOutputs〉 {
              〈1;name〉: 〈1;config〉
            },
          ])
          o: (〈0;#Output〉 & {
            retry: {
              reject: "ok"
            }
          })
          #AllOutputs: {
            reject: string
            resource: string
            retry: 〈1;#Output〉
          }
        }
      }
    }
  }
  selfReferential: {
    acrossOr: {
      t1: {
        p3: {
          #Output: or([
            for name, config in 〈1;#AllOutputs〉 {
              〈1;name〉: 〈1;config〉
            },
          ])
          #AllOutputs: {
            reject: string
            resource: string
            retry: 〈1;#Output〉
          }
          o: (〈0;#Output〉 & {
            retry: {
              reject: "ok"
            }
          })
        }
      }
    }
  }
  selfReferential: {
    acrossOr: {
      t2: {
        p1: {
          d: or([
            for x, y in 〈1;#A〉 {
              〈1;y〉
            },
          ])
          o: (〈0;d〉 & {
            b: 2
          })
          #A: {
            d1: int
            d2: string
            d3: {
              b: 〈2;d〉
            }
          }
        }
      }
    }
  }
  selfReferential: {
    acrossOr: {
      t2: {
        p2: {
          o: (〈0;d〉 & {
            b: 2
          })
          d: or([
            for x, y in 〈1;#A〉 {
              〈1;y〉
            },
          ])
          #A: {
            d1: int
            d2: string
            d3: {
              b: 〈2;d〉
            }
          }
        }
      }
    }
  }
  selfReferential: {
    acrossOr: {
      t2: {
        p3: {
          o: (〈0;d〉 & {
            b: 2
          })
          #A: {
            d1: int
            d2: string
            d3: {
              b: 〈2;d〉
            }
          }
          d: or([
            for x, y in 〈1;#A〉 {
              〈1;y〉
            },
          ])
        }
      }
    }
  }
  issue1881: {
    p1: {
      o: (〈0;#Output〉 & {
        retry: {
          output: {
            reject: "ok"
          }
        }
      })
      #AllOutputs: {
        reject: string
        resource: string
        retry: {
          output: 〈2;#Output〉
        }
      }
      #Output: or([
        for name, config in 〈1;#AllOutputs〉 {
          〈1;name〉: 〈1;config〉
        },
      ])
    }
  }
  issue1881: {
    p2: {
      #AllOutputs: {
        reject: string
        resource: string
        retry: {
          output: 〈2;#Output〉
        }
      }
      o: (〈0;#Output〉 & {
        retry: {
          output: {
            reject: "ok"
          }
        }
      })
      #Output: or([
        for name, config in 〈1;#AllOutputs〉 {
          〈1;name〉: 〈1;config〉
        },
      ])
    }
  }
  issue1881: {
    p3: {
      #AllOutputs: {
        reject: string
        resource: string
        retry: {
          output: 〈2;#Output〉
        }
      }
      #Output: or([
        for name, config in 〈1;#AllOutputs〉 {
          〈1;name〉: 〈1;config〉
        },
      ])
      o: (〈0;#Output〉 & {
        retry: {
          output: {
            reject: "ok"
          }
        }
      })
    }
  }
  siblingInsertion: {
    t1: {
      p1: {
        D: {
          logging: _
        }
        deployment: _
        for k, v in 〈0;deployment〉 for k1, v2 in 〈0;v〉.env2 {
          deployment: {
            〈3;k〉: {
              env: {
                〈4;k1〉: 〈4;v2〉
              }
            }
          }
        }
        for id, v in 〈0;D〉 {
          deployment: {
            〈2;id〉: {
              env2: {
                ENV: "True"
              }
            }
          }
        }
      }
    }
  }
  siblingInsertion: {
    t1: {
      p2: {
        D: {
          logging: _
        }
        deployment: _
        for id, v in 〈0;D〉 {
          deployment: {
            〈2;id〉: {
              env2: {
                ENV: "True"
              }
            }
          }
        }
        for k, v in 〈0;deployment〉 for k1, v2 in 〈0;v〉.env2 {
          deployment: {
            〈3;k〉: {
              env: {
                〈4;k1〉: 〈4;v2〉
              }
            }
          }
        }
      }
    }
  }
  siblingInsertion: {
    t2: {
      p1: {
        D: {
          logging: _
        }
        deployment: _
        for k, v in 〈0;deployment〉 {
          for k1, v2 in 〈1;v〉.env2 {
            deployment: {
              〈4;k〉: {
                env: {
                  〈4;k1〉: 〈4;v2〉
                }
              }
            }
          }
        }
        for id, v in 〈0;D〉 {
          deployment: {
            〈2;id〉: {
              env2: {
                ENV: "True"
              }
            }
          }
        }
      }
    }
  }
  siblingInsertion: {
    t2: {
      p2: {
        D: {
          logging: _
        }
        deployment: _
        for k, v in 〈0;deployment〉 {
          for k1, v2 in 〈1;v〉.env2 {
            deployment: {
              〈4;k〉: {
                env: {
                  〈4;k1〉: 〈4;v2〉
                }
              }
            }
          }
        }
        for id, v in 〈0;D〉 {
          deployment: {
            〈2;id〉: {
              env2: {
                ENV: "True"
              }
            }
          }
        }
      }
    }
  }
  selfReferential: {
    fail: {
      a: {}
      b: (〈0;a〉.x != "")
      if 〈0;b〉 {}
    }
  }
  issue2367: {
    a: _
    for _, x in [
      〈1;a〉,
    ] {
      a: 〈1;x〉
    }
  }
  issue2310: {
    original: {
      #s: {
        #_1: string
        #_2: string
        #_3: string
        〈import;strings〉.Replace(〈0;#_1〉, 〈0;#_2〉, 〈0;#_3〉, -1)
      }
      #sub: {
        #a: string
        _#X: [
          〈1;#a〉,
          for _, i in 〈import;list〉.Range(0, len(〈2;#subs〉), 1) {
            (〈4;#subs〉[〈1;i〉] & {
              #_1: 〈4;_#X〉[〈2;i〉]
              _
            })
          },
        ]
        〈0;_#X〉[(len(〈0;_#X〉) - 1)]
      }
      res: (〈0;#sub〉 & {
        #a: "aaa"
        _
      })
      #subs: [
        (〈1;#s〉 & {
          #_2: "a"
          #_3: "b"
          _
        }),
        (〈1;#s〉 & {
          #_2: "c"
          #_3: "d"
          _
        }),
        (〈1;#s〉 & {
          #_2: "e"
          #_3: "f"
          _
        }),
      ]
    }
  }
  issue2310: {
    reduced: {
      res: {
        〈0;#X〉[3]
        #X: [
          "X",
          for i, _ in 〈2;#subs〉 {
            〈4;#s〉
            #str: 〈3;#X〉[〈1;i〉]
          },
        ]
      }
      #s: {
        #str: string
        (〈0;#str〉 + "a")
      }
      #subs: [
        0,
        1,
        2,
      ]
    }
  }
}
--- issue3903.cue
{
  issue3903: {
    reduced: {
      s1: 〈0;#Schema〉
      s1: {
        _deps: [
          〈2;#Schema〉,
        ]
      }
      #Schema: {
        _deps: [
          ...,
        ]
        objs: [
          for _, dep in 〈1;_deps〉 for _, obj in (〈0;dep〉 & {}).objs {
            〈1;obj〉
          },
        ]
      }
    }
  }
  issue3903: {
    full: {
      s1: (〈0;#Schema〉 & {
        _deps: [
          〈2;s2〉,
        ]
        _local: [
          "s1 local",
        ]
      })
      s2: (〈0;#Schema〉 & {
        _local: [
          "s2 local",
        ]
      })
      #Schema: {
        _local: [
          ...string,
        ]
        _deps: [
          ...,
        ]
        objs: [
          for _, obj in 〈1;_local〉 {
            〈1;obj〉
          },
          for _, dep in 〈1;_deps〉 for _, obj in (〈0;dep〉 & {}).objs {
            〈1;obj〉
          },
        ]
      }
    }
  }
}
--- issue3941.cue
{
  issue3941: {
    full: {
      #Metadata: {
        name: string
      }
      #Resource: {
        metadata: 〈1;#Metadata〉
      }
      out: {
        _metadata: {
          name: "foo"
        }
        resource: {
          [string]: {
            [string]: 〈3;#Resource〉
          }
        }
        _names: [
          〈1;_metadata〉.name,
        ]
        for _, name in 〈0;_names〉 {
          resource: {
            level1: {
              〈3;name〉: {
                metadata: 〈5;_metadata〉
              }
            }
          }
        }
      }
    }
  }
}
