-- in.cue --
import "strings"

#schema: {
	let splits = strings.Split(id, "_never_")
	let prefix = splits[0]

	#ID:    =~"^\(prefix)$"
	#SubID: =~"^\(prefix):sub$"

	id:    #ID
	subid: #SubID
}

case1: #schema & {
	id:    "foo"
	subid: "foo:sub"
}

case2: #schema & {
	subid: "foo:sub"
	id:    "foo"
}
-- out/evalalpha --
Errors:
case2.subid: invalid value "foo:sub" (out of bound =~"^:sub$"):
    ./in.cue:8:10
    ./in.cue:11:9
    ./in.cue:20:9

Result:
(_|_){
  // [eval]
  #schema: (#struct){
    let splits#1 = (_|_){
      // [cycle] #schema.#ID: invalid interpolation: cycle with field: prefix:
      //     ./in.cue:7:12
      //     ./in.cue:7:16
    }
    let prefix#2 = (_|_){
      // [incomplete] #schema.prefix: index out of range [0] with length 1:
      //     ./in.cue:5:22
    }
    #ID: (_|_){
      // [cycle] #schema.#ID: invalid interpolation: cycle with field: prefix:
      //     ./in.cue:7:12
      //     ./in.cue:7:16
    }
    #SubID: (_|_){
      // [cycle] #schema.#ID: invalid interpolation: cycle with field: prefix:
      //     ./in.cue:8:12
      //     ./in.cue:7:16
    }
    id: (_|_){
      // [cycle] #schema.#ID: invalid interpolation: cycle with field: prefix:
      //     ./in.cue:7:12
      //     ./in.cue:7:16
    }
    subid: (_|_){
      // [cycle] #schema.#ID: invalid interpolation: cycle with field: prefix:
      //     ./in.cue:8:12
      //     ./in.cue:7:16
    }
  }
  case1: (#struct){
    id: (string){ "foo" }
    subid: (string){ "foo:sub" }
    let splits#1 = (#list){
      0: (string){ "foo" }
    }
    let prefix#2 = (string){ "foo" }
    #ID: (string){ =~"^foo$" }
    #SubID: (string){ =~"^foo:sub$" }
  }
  case2: (_|_){
    // [eval]
    subid: (_|_){
      // [eval] case2.subid: invalid value "foo:sub" (out of bound =~"^:sub$"):
      //     ./in.cue:8:10
      //     ./in.cue:11:9
      //     ./in.cue:20:9
    }
    id: (_|_){
      // [cycle] case2.id: invalid interpolation: cycle with field: prefix:
      //     ./in.cue:7:12
      //     ./in.cue:7:16
    }
    let splits#1 = (_|_){
      // [cycle] case2.id: invalid interpolation: cycle with field: prefix:
      //     ./in.cue:7:12
      //     ./in.cue:7:16
    }
    let prefix#2 = (_|_){
      // [cycle] case2.id: cycle with field: prefix:
      //     ./in.cue:7:16
    }
    #ID: (string){ =~"^$" }
    #SubID: (string){ =~"^:sub$" }
  }
}
-- out/compile --
--- in.cue
{
  #schema: {
    let splits#1 = 〈import;strings〉.Split(〈0;id〉, "_never_")
    let prefix#2 = 〈0;let splits#1〉[0]
    #ID: =~"^\(〈0;let prefix#2〉)$"
    #SubID: =~"^\(〈0;let prefix#2〉):sub$"
    id: 〈0;#ID〉
    subid: 〈0;#SubID〉
  }
  case1: (〈0;#schema〉 & {
    id: "foo"
    subid: "foo:sub"
  })
  case2: (〈0;#schema〉 & {
    subid: "foo:sub"
    id: "foo"
  })
}
