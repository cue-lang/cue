-- in.cue --
import "strings"

#schema: {
	let splits = strings.Split(id, "_never_")
	let prefix = splits[0]

	#ID:    =~"^\(prefix)$"
	#SubID: =~"^\(prefix):sub$"

	id:    #ID
	subid: #SubID
}

case1: #schema & {
	id:    "foo"
	subid: "foo:sub"
}

case2: #schema & {
	subid: "foo:sub"
	id:    "foo"
}
-- out/evalalpha --
(struct){
  #schema: (#struct){
    let splits#1 = (_|_){
      // [incomplete] #schema.prefix: invalid interpolation: index out of range [0] with length 1:
      //     ./in.cue:7:12
      //     ./in.cue:5:22
    }
    let prefix#2 = (_|_){
      // [incomplete] #schema.prefix: index out of range [0] with length 1:
      //     ./in.cue:5:22
    }
    #ID: (_|_){
      // [incomplete] #schema.prefix: invalid interpolation: index out of range [0] with length 1:
      //     ./in.cue:7:12
      //     ./in.cue:5:22
    }
    #SubID: (_|_){
      // [incomplete] #schema.prefix: invalid interpolation: index out of range [0] with length 1:
      //     ./in.cue:8:12
      //     ./in.cue:5:22
    }
    id: (_|_){
      // [incomplete] #schema.prefix: invalid interpolation: index out of range [0] with length 1:
      //     ./in.cue:7:12
      //     ./in.cue:5:22
    }
    subid: (_|_){
      // [incomplete] #schema.prefix: invalid interpolation: index out of range [0] with length 1:
      //     ./in.cue:8:12
      //     ./in.cue:5:22
    }
  }
  case1: (#struct){
    id: (string){ "foo" }
    subid: (string){ "foo:sub" }
    let splits#1 = (#list){
      0: (string){ "foo" }
    }
    let prefix#2 = (string){ "foo" }
    #ID: (string){ =~"^foo$" }
    #SubID: (string){ =~"^foo:sub$" }
  }
  case2: (#struct){
    subid: (string){ "foo:sub" }
    id: (string){ "foo" }
    let splits#1 = (#list){
      0: (string){ "foo" }
    }
    let prefix#2 = (string){ "foo" }
    #ID: (string){ =~"^foo$" }
    #SubID: (string){ =~"^foo:sub$" }
  }
}
