-- in.cue --
import "list"

a1: {
	f: [f]
}

a2: {
	f: f
}

a3: {
	f: {g: f}
}

a4: {
	a: [a | int]
}

a5: {
	a: b: a | int
}

a6: {
	a: a | int
}

a7: {
	a: c.x
	b: {
		x: c
		y: "foo"
	}
	c: {
		x: b.y
		y: 3
	}
}

b1: {
	b: a & [1]
	a: [a | int]
}

b2: {
	a: [a | int]
	b: a & [1]
}

b3: {
	x: a: [a | int]
	b: x & {a: [1]}
}

b4: {
	b: x.y & [1]
	x: y: [y]
}

// Ensure that the cycle error is not blindly copied to a referring field,
// as the cycle may not persist.
b4: cond1: {
	b: x.y & { _z: false, [1] }
	x: y: {
		_z: *true | bool
		if _z {
			[y]
		}
	}
}

// This reports a structural cycle at b4.cond2.b, because the value it refers
// has a structural cycle. Technically, this is incorrect, as the cycle
// really only occurs in b4.cond2.x.y. But since structural cycles are
// permanent, the entire configuration is invalidated, so the spurious
// additional cycle is merely cosmetic. By most logical standards, one can prove
// any fact from a contradiction. So assuming that, this is not incorrect.
// TODO: fix this cosmetic blemish.
b4: cond2: {
	x: y: {
		_z: *true | bool
		if _z {
			[y]
		}
	}
	b: x.y & { _z: false, [1] }
}

b5: {
	b: x.y & {a: [1]}
	x: y: a: [a | int]
}

b6: {
	b: x & {a: [1]}
	x: a: [a]
}

b7: {
	b: a & [[1]]
	a: [a]
}

// Issue #555
b8: {
	x: a
	a: f: b
	b: a | string
}

// Issue #555
b9: {
	#a: string | #b | #ref
	#b: {
		c: [#a, #a, #a]
	}
	#ref: ref: string
	x: #b | #ref
}

// Issue #534
// TODO: the resolution here is arguably incorrect: c should be
// 		d: string | { b: string }
// However, this is not the end of the world, as the disjunction is preserved
// under the hood and still unifies with extended structure.
b10: {
	a: close({
		b: string | a | c
	})
	c: close({
		d: string | a
	})

	d: d: b: string
}

// Issue #509 -- with comprehension
b11: {
	#list: {
		tail: #list | *null
		if tail != null {
		}
	}
}

// Issue #509 -- with comprehension
b12: {
	#list: {
		V=value: int
		T=tail:  #list | *null
		if T != null {
			sum: V + T.sum
		}
		if T == null {
			sum: V
		}
	}

	list1: #list
	list1: {
		value: 1
		tail: {
			value: 2
			tail: {
				value: 3
				tail: {
					value: 4
				}
			}
		}
	}
}

// More trigger happy on stack overflows.
b12b: {
	#list: {
		tail: #list

		if tail != null {
			sum: tail.sum
		}
	}

	list1: #list
	list1: {
		tail: {
			tail: {
			}
		}
	}
}

// Issue #587
b13: root: a: [for x in root {x}]

// Issue #587
// TODO: this should probably be okay if we allow shallow evaluation of
// comprehension sources. See #1881.
b14: {
	root: {
		a: [...int]

		for x in a {
			"\(x)": {}
		}

		b: [for x in root {x}]
	}
}

// This is okay
// Issue #587
b15: root: a: {for x in root {x}}

// Issue #502 -- unused bulk constraints are not cyclic
p1: {
	#T: {
		a: [string]: link: #T
	}

	a: #T & {
		a: one: link: a: two: {}
	}
}

// Issue #502 -- but they are if it is invoked within the struct.
p2: {
	#T: {
		a: [string]: link: #T
		a: b: {}
	}

	a: #T & {
		a: one: link: a: two: {}
	}
}

// Issue #502 -- or added later.
p3: {
	#S: #T: {
		a: [string]: link: #T
	}

	#U: {
		#S
		#T: a: b: {}
	}

	a: #U.#T & {
		a: one: link: a: two: {}
	}
}

// Issue #502 -- unused bulk constraints are not cyclic
p4: {
	#T: {
		a: [...{link: #T}]
	}

	a: #T & {
		a: [{link: a: [{}]}]
	}
}

// Issue #502 -- but they are if it is invoked within the struct.
p5: {
	#T: {
		a: [...{link: #T}]
		a: [{}]
	}

	a: #T & {
		a: [{link: a: [{}]}]
	}
}

// Issue #502 -- or added later.
p6: {
	#S: #T: {
		a: [...{link: #T}]
	}

	#U: {
		#S
		#T: a: [{}]
	}

	a: #U.#T & {
		a: [{link: a: [{}]}]
	}
}

c1: {
	a: {
		b: {}
		c: a & b
	}
}

// indirection
d1: {
	a: b: c: d: {h: int, t: r}
	r: a.b

	x: a.b.c
}

d2: {
	x: a.b.c

	r: a.b
	a: b: c: d: {h: int, t: r}
}

d3: {
	config: {
		a: b: c: indirect
		indirect: [a.b, null][i]
		i:        int | *1
	}
	x: config & {i: 0}
}

// Ensure that the cycles here fail early.
// TODO: they can still be shorter.
shortPathFail: _

shortPathFail: doubleRef: {
	// Avoid this: the first #List reference is different from the second, so
	// the second #List reference counts as a first occurrence, causing the
	// result to be longer than perhaps expected.
	a: #List
	#List: Next: #List | *null
}

shortPathFail: elipsis: {
	// Avoid this: the elipsis causes `_` to be mixed in with the #Foo
	// reference, causing the first cycle to be discounted.
	t1: {
		#Foo: ref:  null | #Foo
		#Foo: { ... }
	}
	t2: {
		Foo: ref:  Foo
		Foo: {...}
	}
}

patternFail: issue2374: {
	r=[string]: {b: r}
	a: {r: 0}
}

shortPathFail: comprehension: {
	#list: {
		tail: #list | *null
		if tail != null {
		}
	}
}

withLetFail: {
	schema: next:  _schema_1
	let _schema_1 = schema
}

fieldsSumInfinite: issue3310: {
	cheeseburger: 3.00
	fries:        2.00
	sprite:       1.00

	total: list.Sum([for _, v in issue3310 {v}])
}

listOptOK: {
	list: {
		head: int
		tail?: list
	}
	a: list & {head: 3, tail: head: 2}
}

// combining structural with reference cycles
e1: {
	a: a
	a: c: a

	b: c: b
	b: b
}

e2: {
	a: {a}
	a: c: a

	b: c: b
	b: {b}
}

e3: {
	a: [a]
	a: c: a

	b: [b]
	b: c: b
}

e4: {
	a: [a | {}]
	a: [[{c: 1}]]

	b: [[{c: 1}]]
	b: [b | {}]
}

e5: {
	a: c: a | int
	a: a | int

	b: b | int
	b: c: b | int
}

// validating values
nestedList: {
	v1e: {
		x: [x | int, 1]
		y: x & [[[2], 1], 1]
	}

	v2e: {
		y: x & [[[2], 1], 1]
		x: [x | int, 1]
	}

	v1: {
		x: [x | int, 1]
		y: x & [[[2, 1], 1], 1]
	}

	v2: {
		y: x & [[[2, 1], 1], 1]
		x: [x | int, 1]
	}
}

v3: {
	list: {
		head: int
		tail: list | null
	}

	myList: list
	myList: {
		head: 2
		tail: {
			head: 3
			tail: {
				head: 4
			}
		}
	}
}

v4: {
	list: {
		head: int
		tail: list | 1
	}

	myList: list
	myList: {
		head: 2
		tail: head: 3
	}
}

v5: {
	list: {
		head: int
		tail: list | {}
	}

	myList: list
	myList: {
		head: 2
		tail: head: 3
	}
}

// Example from "The Logic of Type Feature Structures" (Bob Carpenter)/
z1: {
	y: {
		f: h: g
		g: _
	}
	x: {
		f: _
		g: f
	}
	z: x & y
}

// Cross references. Here there is no cycle, but the repeated instantiations
// of T will cause, in turn, cause repeated resolution of `x`. The algorithm
// should not identify these as cyclic references. Instead, it should be
// noted that the reference is each time referring to new content.
// Issue #754
crossRefNoCycle: t1: {
	T: {
		x: _
		y: x
	}
	C: { x: T } & T
}

crossRefNoCycle: t2: {
	T: {
		x: _
		y: x
	}
	C: T & { x: T }
}

crossRefNoCycle: t3: {
	T: {
		x: _
		y: x
		z: y
	}
	C: T & { x: T }
}

crossRefNoCycle: t4: {
	T: {
		x: _
		y: x
		z: y
	}
	C: T & { x: T & { x: T } }
}

// Ensure these are NOT treated as structural errors.

n1: a: b: int
n2: n1 & {a: n1}
n3: n1 & {n1}
n4: n1 & {x: n1 & {y: n1 & {z: int}}}
-- out/evalalpha/stats --
Leaks:  1780
Freed:  431
Reused: 431
Allocs: 1780
Retain: 0

Unifications: 1126
Conjuncts:    5997
Disjuncts:    1041
-- diff/-out/evalalpha/stats<==>+out/eval/stats --
diff old new
--- old
+++ new
@@ -1,9 +1,9 @@
-Leaks:  15
-Freed:  821
-Reused: 809
-Allocs: 27
-Retain: 63
+Leaks:  1780
+Freed:  431
+Reused: 431
+Allocs: 1780
+Retain: 0
 
-Unifications: 650
-Conjuncts:    1268
-Disjuncts:    871
+Unifications: 1126
+Conjuncts:    5997
+Disjuncts:    1041
-- out/eval/stats --
Leaks:  15
Freed:  821
Reused: 809
Allocs: 27
Retain: 63

Unifications: 650
Conjuncts:    1268
Disjuncts:    871
-- out/evalalpha --
Errors:
a1.f.0: structural cycle
a3.f.g: structural cycle
b12b.#list.tail: structural cycle
b13.root.a.0.0: structural cycle
b14.root.b.1.1: structural cycle
b4.b.0: conflicting values 1 and [y] (mismatched types int and list):
    ./in.cue:55:12
    ./in.cue:56:8
b4.b.0.0: structural cycle
b4.cond1.x.y.0: structural cycle
b4.cond2.x.y.0: structural cycle
b4.x.y.0: structural cycle
b6.b.a.0: conflicting values 1 and [1] (mismatched types int and list):
    ./in.cue:94:13
    ./in.cue:94:14
b6.b.a.0.0: structural cycle
b6.x.a.0: structural cycle
b7.a.0: structural cycle
b7.b.0.0: conflicting values 1 and [a] (mismatched types int and list):
    ./in.cue:99:11
    ./in.cue:100:5
b7.b.0.0.0: structural cycle
c1.a.c: structural cycle
d1.r: structural cycle
e1.a.c: structural cycle
e1.b.c: structural cycle
e2.a.c: structural cycle
e2.b.c: structural cycle
e3.a: conflicting values [a] and {c:a} (mismatched types list and struct):
    ./in.cue:400:5
    ./in.cue:401:5
e3.a.c: structural cycle
e3.b: conflicting values [b] and {c:b} (mismatched types list and struct):
    ./in.cue:403:5
    ./in.cue:404:5
e3.b.c: structural cycle
e4.a.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:408:10
    ./in.cue:409:6
e4.a.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
    ./in.cue:409:6
    ./in.cue:409:7
e4.a.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:408:10
    ./in.cue:409:6
e4.a.0.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
    ./in.cue:409:6
    ./in.cue:409:7
e4.a.0.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:408:10
    ./in.cue:409:6
e4.a.0.0.0: structural cycle
e4.b.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:411:6
    ./in.cue:412:10
e4.b.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
    ./in.cue:411:6
    ./in.cue:411:7
e4.b.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:411:6
    ./in.cue:412:10
e4.b.0.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
    ./in.cue:411:6
    ./in.cue:411:7
e4.b.0.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:411:6
    ./in.cue:412:10
e4.b.0.0.0: structural cycle
nestedList.v1e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
    ./in.cue:426:11
    ./in.cue:427:11
nestedList.v1e.y.0.0: conflicting values int and [2] (mismatched types int and list):
    ./in.cue:426:11
    ./in.cue:427:12
nestedList.v2e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
    ./in.cue:431:11
    ./in.cue:432:11
nestedList.v2e.y.0.0: conflicting values int and [2] (mismatched types int and list):
    ./in.cue:431:12
    ./in.cue:432:11
p2.#T.a.b.link: structural cycle
p3.#U.#T.a.b.link: structural cycle
p5.#T.a.0.link: structural cycle
p6.#U.#T.a.0.link: structural cycle
patternFail.issue2374.a.b: structural cycle
shortPathFail.elipsis.t2.Foo.ref: structural cycle
withLetFail._schema_1: structural cycle
z1.z.g.h: structural cycle
d3.config.0: structural cycle:
    ./in.cue:317:13
fieldsSumInfinite.issue3310.3: structural cycle:
    ./in.cue:371:18
e4.a.0.0: cannot combine regular field "c" with [1,{c:1} & (a|{}) & [{c:1}]]:
    ./in.cue:409:11
e4.a.0.0.0: cannot combine regular field "c" with [1,{c:1}]:
    ./in.cue:409:11
e4.b.0.0: cannot combine regular field "c" with [1,{c:1} & [{c:1}] & (b|{})]:
    ./in.cue:411:11
e4.b.0.0.0: cannot combine regular field "c" with [1,{c:1}]:
    ./in.cue:411:11
nestedList.v1e.y.0.0: incompatible list lengths (1 and 2):
    ./in.cue:426:6
nestedList.v2e.y.0.0: incompatible list lengths (1 and 2):
    ./in.cue:432:6

Result:
(_|_){
  // [eval]
  a1: (_|_){
    // [structural cycle]
    f: (_|_){
      // [structural cycle]
      0: (_|_){
        // [structural cycle] a1.f.0: structural cycle
      }
    }
  }
  a2: (struct){
    f: (_){ _ }
  }
  a3: (_|_){
    // [structural cycle]
    f: (_|_){
      // [structural cycle]
      g: (_|_){
        // [structural cycle] a3.f.g: structural cycle
      }
    }
  }
  a4: (struct){
    a: (#list){
      0: (int){ int }
    }
  }
  a5: (struct){
    a: (struct){
      b: (int){ int }
    }
  }
  a6: (struct){
    a: (_){ |((_){ _ }, (int){ int }) }
  }
  a7: (struct){
    a: (string){ "foo" }
    b: (struct){
      x: ~(a7.c)
      y: (string){ "foo" }
    }
    c: (struct){
      x: (string){ "foo" }
      y: (int){ 3 }
    }
  }
  b1: (struct){
    b: (#list){
      0: (int){ 1 }
    }
    a: (#list){
      0: (int){ int }
    }
  }
  b2: (struct){
    a: (#list){
      0: (int){ int }
    }
    b: (#list){
      0: (int){ 1 }
    }
  }
  b3: (struct){
    x: (struct){
      a: (#list){
        0: (int){ int }
      }
    }
    b: (struct){
      a: (#list){
        0: (int){ 1 }
      }
    }
  }
  b4: (_|_){
    // [eval]
    b: (_|_){
      // [eval]
      0: (_|_){
        // [eval] b4.b.0: conflicting values 1 and [y] (mismatched types int and list):
        //     ./in.cue:55:12
        //     ./in.cue:56:8
        // b4.b.0.0: structural cycle
        0: (_|_){
          // [structural cycle] b4.b.0.0: structural cycle
        }
      }
    }
    x: (_|_){
      // [structural cycle]
      y: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle] b4.x.y.0: structural cycle
        }
      }
    }
    cond1: (_|_){
      // [structural cycle]
      b: (#list){
        _z: (bool){ false }
        0: (int){ 1 }
      }
      x: (_|_){
        // [structural cycle]
        y: (_|_){
          // [structural cycle]
          _z: (bool){ |(*(bool){ true }, (bool){ bool }) }
          0: (_|_){
            // [structural cycle] b4.cond1.x.y.0: structural cycle
          }
        }
      }
    }
    cond2: (_|_){
      // [structural cycle]
      x: (_|_){
        // [structural cycle]
        y: (_|_){
          // [structural cycle]
          _z: (bool){ |(*(bool){ true }, (bool){ bool }) }
          0: (_|_){
            // [structural cycle] b4.cond2.x.y.0: structural cycle
          }
        }
      }
      b: (_|_){
        // [structural cycle] b4.cond2.x.y.0: structural cycle
      }
    }
  }
  b5: (struct){
    b: (struct){
      a: (#list){
        0: (int){ 1 }
      }
    }
    x: (struct){
      y: (struct){
        a: (#list){
          0: (int){ int }
        }
      }
    }
  }
  b6: (_|_){
    // [eval]
    b: (_|_){
      // [eval]
      a: (_|_){
        // [eval]
        0: (_|_){
          // [eval] b6.b.a.0: conflicting values 1 and [1] (mismatched types int and list):
          //     ./in.cue:94:13
          //     ./in.cue:94:14
          // b6.b.a.0.0: structural cycle
          0: (_|_){
            // [structural cycle] b6.b.a.0.0: structural cycle
          }
        }
      }
    }
    x: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle] b6.x.a.0: structural cycle
        }
      }
    }
  }
  b7: (_|_){
    // [eval]
    b: (_|_){
      // [eval]
      0: (_|_){
        // [eval]
        0: (_|_){
          // [eval] b7.b.0.0: conflicting values 1 and [a] (mismatched types int and list):
          //     ./in.cue:99:11
          //     ./in.cue:100:5
          // b7.b.0.0.0: structural cycle
          0: (_|_){
            // [structural cycle] b7.b.0.0.0: structural cycle
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle]
      0: (_|_){
        // [structural cycle] b7.a.0: structural cycle
      }
    }
  }
  b8: (struct){
    x: ~(b8.a)
    a: (struct){
      f: (string){ string }
    }
    b: (string){ string }
  }
  b9: (struct){
    #a: ((string|struct)){ |((string){ string }, (#struct){
        ref: (string){ string }
      }) }
    #b: (#struct){
      c: (#list){
        0: ((string|struct)){ |((string){ string }, (#struct){
            ref: (string){ string }
          }) }
        1: ((string|struct)){ |((string){ string }, (#struct){
            ref: (string){ string }
          }) }
        2: ((string|struct)){ |((string){ string }, (#struct){
            ref: (string){ string }
          }) }
      }
    }
    #ref: (#struct){
      ref: (string){ string }
    }
    x: (struct){ |((#struct){
        c: (#list){
          0: ((string|struct)){ |((string){ string }, (#struct){
              ref: (string){ string }
            }) }
          1: ((string|struct)){ |((string){ string }, (#struct){
              ref: (string){ string }
            }) }
          2: ((string|struct)){ |((string){ string }, (#struct){
              ref: (string){ string }
            }) }
        }
      }, (#struct){
        ref: (string){ string }
      }) }
  }
  b10: (struct){
    a: (#struct){
      b: ((string|struct)){ |((string){ string }, (#struct){
          d: (string){ string }
        }) }
    }
    c: (#struct){
      d: ((string|struct)){ |((string){ string }, (#struct){
          b: ((string|struct)){ |((string){ string }, (#struct){
              b: ((string|struct)){ |((string){ string }, (#struct){
                  b: (string){ string }
                }) }
            }) }
        }) }
    }
    d: (struct){
      d: (struct){
        b: (string){ string }
      }
    }
  }
  b11: (struct){
    #list: (#struct){
      tail: (null){ null }
    }
  }
  b12: (struct){
    #list: (#struct){
      value: (int){ int }
      tail: (null){ null }
      sum: (int){ int }
    }
    list1: (#struct){
      value: (int){ 1 }
      tail: (#struct){
        value: (int){ 2 }
        tail: (#struct){
          value: (int){ 3 }
          tail: (#struct){
            value: (int){ 4 }
            tail: ((null|struct)){ |(*(null){ null }, (#struct){
                value: (int){ int }
                tail: (null){ null }
                sum: (int){ int }
              }) }
            sum: (int){ 4 }
          }
          sum: (int){ 7 }
        }
        sum: (int){ 9 }
      }
      sum: (int){ 10 }
    }
  }
  b12b: (_|_){
    // [structural cycle]
    #list: (_|_){
      // [structural cycle] b12b.#list.tail: structural cycle
    }
    list1: (_|_){
      // [structural cycle] b12b.#list.tail: structural cycle
    }
  }
  b13: (_|_){
    // [structural cycle]
    root: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle]
          0: (_|_){
            // [structural cycle] b13.root.a.0.0: structural cycle
          }
        }
      }
    }
  }
  b14: (_|_){
    // [structural cycle]
    root: (_|_){
      // [structural cycle]
      a: (list){
      }
      b: (_|_){
        // [structural cycle]
        0: (list){
        }
        1: (_|_){
          // [structural cycle]
          0: (list){
          }
          1: (_|_){
            // [structural cycle] b14.root.b.1.1: structural cycle
          }
        }
      }
    }
  }
  b15: (struct){
    root: (struct){
      a: (struct){
      }
    }
  }
  p1: (struct){
    #T: (#struct){
      a: (#struct){
      }
    }
    a: (#struct){
      a: (#struct){
        one: (#struct){
          link: (#struct){
            a: (#struct){
              two: (#struct){
                link: ~(p1.#T)
              }
            }
          }
        }
      }
    }
  }
  p2: (_|_){
    // [structural cycle]
    #T: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        b: (_|_){
          // [structural cycle]
          link: (_|_){
            // [structural cycle] p2.#T.a.b.link: structural cycle
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle]
      a: (struct){
        one: (struct){
          link: (struct){
            a: (struct){
              two: (struct){
              }
            }
          }
        }
      }
    }
  }
  p3: (_|_){
    // [structural cycle]
    #S: (#struct){
      #T: (#struct){
        a: (#struct){
        }
      }
    }
    #U: (_|_){
      // [structural cycle]
      #T: (_|_){
        // [structural cycle]
        a: (_|_){
          // [structural cycle]
          b: (_|_){
            // [structural cycle]
            link: (_|_){
              // [structural cycle] p3.#U.#T.a.b.link: structural cycle
            }
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle] p3.#U.#T.a.b.link: structural cycle
    }
  }
  p4: (struct){
    #T: (#struct){
      a: (list){
      }
    }
    a: (#struct){
      a: (#list){
        0: (#struct){
          link: (#struct){
            a: (#list){
              0: (#struct){
                link: ~(p4.#T)
              }
            }
          }
        }
      }
    }
  }
  p5: (_|_){
    // [structural cycle]
    #T: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle]
          link: (_|_){
            // [structural cycle] p5.#T.a.0.link: structural cycle
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle]
      a: (#list){
        0: (struct){
          link: (struct){
            a: (#list){
              0: (struct){
              }
            }
          }
        }
      }
    }
  }
  p6: (_|_){
    // [structural cycle]
    #S: (#struct){
      #T: (#struct){
        a: (list){
        }
      }
    }
    #U: (_|_){
      // [structural cycle]
      #T: (_|_){
        // [structural cycle]
        a: (_|_){
          // [structural cycle]
          0: (_|_){
            // [structural cycle]
            link: (_|_){
              // [structural cycle] p6.#U.#T.a.0.link: structural cycle
            }
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle] p6.#U.#T.a.0.link: structural cycle
    }
  }
  c1: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      b: (struct){
      }
      c: (_|_){
        // [structural cycle] c1.a.c: structural cycle
      }
    }
  }
  d1: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      b: (_|_){
        // [structural cycle]
        c: (_|_){
          // [structural cycle]
          d: (_|_){
            // [structural cycle]
            h: (int){ int }
            t: (_|_){
              // [structural cycle] d1.r: structural cycle
            }
          }
        }
      }
    }
    r: (_|_){
      // [structural cycle] d1.r: structural cycle
    }
    x: (_|_){
      // [structural cycle] d1.r: structural cycle
    }
  }
  d2: (struct){
    x: ~(d2.a.b.c)
    r: ~(d2.a.b)
    a: (struct){
      b: (struct){
        c: (_|_){
          // [cycle] d2.a.b.c: mutual dependency
        }
      }
    }
  }
  d3: (_|_){
    // [structural cycle]
    config: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        b: (_|_){
          // [structural cycle]
          c: (_|_){
            // [structural cycle] d3.config.0: structural cycle:
            //     ./in.cue:317:13
          }
        }
      }
      indirect: (_|_){
        // [structural cycle] d3.config.0: structural cycle:
        //     ./in.cue:317:13
      }
      i: (int){ |(*(int){ 1 }, (int){ int }) }
    }
    x: (_|_){
      // [structural cycle]
      i: (int){ 0 }
    }
  }
  shortPathFail: (_|_){
    // [structural cycle]
    doubleRef: (struct){
      a: ~(shortPathFail.doubleRef.#List)
      #List: (#struct){
        Next: (null){ null }
      }
    }
    elipsis: (_|_){
      // [structural cycle]
      t1: (struct){
        #Foo: (#struct){
          ref: (null){ null }
        }
      }
      t2: (_|_){
        // [structural cycle]
        Foo: (_|_){
          // [structural cycle]
          ref: (_|_){
            // [structural cycle] shortPathFail.elipsis.t2.Foo.ref: structural cycle
          }
        }
      }
    }
    comprehension: (struct){
      #list: (#struct){
        tail: (null){ null }
      }
    }
  }
  patternFail: (_|_){
    // [structural cycle]
    issue2374: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        r: (int){ 0 }
        b: (_|_){
          // [structural cycle] patternFail.issue2374.a.b: structural cycle
        }
      }
    }
  }
  withLetFail: (_|_){
    // [structural cycle]
    schema: (_|_){
      // [structural cycle]
      next: (_|_){
        // [structural cycle] withLetFail._schema_1: structural cycle
      }
    }
    let _schema_1#1 = (_|_){
      // [structural cycle] withLetFail._schema_1: structural cycle
    }
  }
  fieldsSumInfinite: (_|_){
    // [structural cycle]
    issue3310: (_|_){
      // [structural cycle]
      cheeseburger: (float){ 3.00 }
      fries: (float){ 2.00 }
      sprite: (float){ 1.00 }
      total: (_|_){
        // [structural cycle] fieldsSumInfinite.issue3310.3: structural cycle:
        //     ./in.cue:371:18
      }
    }
  }
  listOptOK: (struct){
    list: (struct){
      head: (int){ int }
      tail?: (_|_){
        // [structural cycle] listOptOK.list.tail: structural cycle
      }
    }
    a: (struct){
      head: (int){ 3 }
      tail: (struct){
        head: (int){ 2 }
        tail?: ~(listOptOK.list)
      }
    }
  }
  e1: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e1.a.c: structural cycle
      }
    }
    b: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e1.b.c: structural cycle
      }
    }
  }
  e2: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e2.a.c: structural cycle
      }
    }
    b: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e2.b.c: structural cycle
      }
    }
  }
  e3: (_|_){
    // [eval]
    a: (_|_){
      // [eval] e3.a: conflicting values [a] and {c:a} (mismatched types list and struct):
      //     ./in.cue:400:5
      //     ./in.cue:401:5
      // e3.a.c: structural cycle
      c: (_|_){
        // [structural cycle] e3.a.c: structural cycle
      }
      0: (_|_){
        // [structural cycle] e3.a.0: structural cycle
      }
    }
    b: (_|_){
      // [eval] e3.b: conflicting values [b] and {c:b} (mismatched types list and struct):
      //     ./in.cue:403:5
      //     ./in.cue:404:5
      // e3.b.c: structural cycle
      c: (_|_){
        // [structural cycle] e3.b.c: structural cycle
      }
      0: (_|_){
        // [structural cycle] e3.b.0: structural cycle
      }
    }
  }
  e4: (_|_){
    // [eval]
    a: (_|_){
      // [eval]
      0: (_|_){
        // [eval] e4.a.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:408:10
        //     ./in.cue:409:6
        // e4.a.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
        //     ./in.cue:409:6
        //     ./in.cue:409:7
        // e4.a.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:408:10
        //     ./in.cue:409:6
        // e4.a.0.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
        //     ./in.cue:409:6
        //     ./in.cue:409:7
        // e4.a.0.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:408:10
        //     ./in.cue:409:6
        // e4.a.0.0.0: structural cycle
        // e4.a.0.0: cannot combine regular field "c" with [1,{c:1} & (a|{}) & [{c:1}]]:
        //     ./in.cue:409:11
        // e4.a.0.0.0: cannot combine regular field "c" with [1,{c:1}]:
        //     ./in.cue:409:11
      }
    }
    b: (_|_){
      // [eval]
      0: (_|_){
        // [eval] e4.b.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:411:6
        //     ./in.cue:412:10
        // e4.b.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
        //     ./in.cue:411:6
        //     ./in.cue:411:7
        // e4.b.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:411:6
        //     ./in.cue:412:10
        // e4.b.0.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
        //     ./in.cue:411:6
        //     ./in.cue:411:7
        // e4.b.0.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:411:6
        //     ./in.cue:412:10
        // e4.b.0.0.0: structural cycle
        // e4.b.0.0: cannot combine regular field "c" with [1,{c:1} & [{c:1}] & (b|{})]:
        //     ./in.cue:411:11
        // e4.b.0.0.0: cannot combine regular field "c" with [1,{c:1}]:
        //     ./in.cue:411:11
      }
    }
  }
  e5: (struct){
    a: (struct){
      c: (int){ int }
    }
    b: (struct){
      c: (int){ int }
    }
  }
  nestedList: (_|_){
    // [eval]
    v1e: (_|_){
      // [eval]
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
      y: (_|_){
        // [eval]
        0: (_|_){
          // [eval] nestedList.v1e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
          //     ./in.cue:426:11
          //     ./in.cue:427:11
          // nestedList.v1e.y.0.0: conflicting values int and [2] (mismatched types int and list):
          //     ./in.cue:426:11
          //     ./in.cue:427:12
          // nestedList.v1e.y.0.0: incompatible list lengths (1 and 2):
          //     ./in.cue:426:6
        }
        1: (int){ 1 }
      }
    }
    v2e: (_|_){
      // [eval]
      y: (_|_){
        // [eval]
        0: (_|_){
          // [eval] nestedList.v2e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
          //     ./in.cue:431:11
          //     ./in.cue:432:11
          // nestedList.v2e.y.0.0: conflicting values int and [2] (mismatched types int and list):
          //     ./in.cue:431:12
          //     ./in.cue:432:11
          // nestedList.v2e.y.0.0: incompatible list lengths (1 and 2):
          //     ./in.cue:432:6
        }
        1: (int){ 1 }
      }
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
    }
    v1: (struct){
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
      y: (#list){
        0: (#list){
          0: (#list){
            0: (int){ 2 }
            1: (int){ 1 }
          }
          1: (int){ 1 }
        }
        1: (int){ 1 }
      }
    }
    v2: (struct){
      y: (#list){
        0: (#list){
          0: (#list){
            0: (int){ 2 }
            1: (int){ 1 }
          }
          1: (int){ 1 }
        }
        1: (int){ 1 }
      }
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
    }
  }
  v3: (struct){
    list: (struct){
      head: (int){ int }
      tail: (null){ null }
    }
    myList: (struct){
      head: (int){ 2 }
      tail: (struct){
        head: (int){ 3 }
        tail: (struct){
          head: (int){ 4 }
          tail: ((null|struct)){ |((struct){
              head: (int){ int }
              tail: (null){ null }
            }, (null){ null }) }
        }
      }
    }
  }
  v4: (struct){
    list: (struct){
      head: (int){ int }
      tail: (int){ 1 }
    }
    myList: (struct){
      head: (int){ 2 }
      tail: (struct){
        head: (int){ 3 }
        tail: ((int|struct)){ |((struct){
            head: (int){ int }
            tail: (int){ 1 }
          }, (int){ 1 }) }
      }
    }
  }
  v5: (struct){
    list: (struct){
      head: (int){ int }
      tail: (struct){
      }
    }
    myList: (struct){
      head: (int){ 2 }
      tail: (struct){ |((struct){
          head: (int){ 3 }
          tail: (struct){ |((struct){
              head: (int){ int }
              tail: (struct){
              }
            }, (struct){
            }) }
        }, (struct){
          head: (int){ 3 }
        }) }
    }
  }
  z1: (_|_){
    // [structural cycle]
    y: (struct){
      f: (struct){
        h: (_){ _ }
      }
      g: (_){ _ }
    }
    x: (struct){
      f: (_){ _ }
      g: (_){ _ }
    }
    z: (_|_){
      // [structural cycle]
      f: (_|_){
        // [structural cycle]
        h: ~(z1.z.g)
      }
      g: (_|_){
        // [structural cycle]
        h: (_|_){
          // [structural cycle] z1.z.g.h: structural cycle
        }
      }
    }
  }
  crossRefNoCycle: (struct){
    t1: (struct){
      T: (struct){
        x: (_){ _ }
        y: (_){ _ }
      }
      C: (struct){
        x: (struct){
          x: (_){ _ }
          y: (_){ _ }
        }
        y: ~(crossRefNoCycle.t1.C.x)
      }
    }
    t2: (struct){
      T: (struct){
        x: (_){ _ }
        y: (_){ _ }
      }
      C: (struct){
        x: (struct){
          x: (_){ _ }
          y: (_){ _ }
        }
        y: ~(crossRefNoCycle.t2.C.x)
      }
    }
    t3: (struct){
      T: (struct){
        x: (_){ _ }
        y: (_){ _ }
        z: (_){ _ }
      }
      C: (struct){
        x: (struct){
          x: (_){ _ }
          y: (_){ _ }
          z: (_){ _ }
        }
        y: ~(crossRefNoCycle.t3.C.x)
        z: ~(crossRefNoCycle.t3.C.x)
      }
    }
    t4: (struct){
      T: (struct){
        x: (_){ _ }
        y: (_){ _ }
        z: (_){ _ }
      }
      C: (struct){
        x: (struct){
          x: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
          y: ~(crossRefNoCycle.t4.C.x.x)
          z: ~(crossRefNoCycle.t4.C.x.x)
        }
        y: ~(crossRefNoCycle.t4.C.x)
        z: ~(crossRefNoCycle.t4.C.x)
      }
    }
  }
  n1: (struct){
    a: (struct){
      b: (int){ int }
    }
  }
  n2: (struct){
    a: (struct){
      b: (int){ int }
      a: (struct){
        b: (int){ int }
      }
    }
  }
  n3: (struct){
    a: (struct){
      b: (int){ int }
    }
  }
  n4: (struct){
    x: (struct){
      y: (struct){
        z: (int){ int }
        a: (struct){
          b: (int){ int }
        }
      }
      a: (struct){
        b: (int){ int }
      }
    }
    a: (struct){
      b: (int){ int }
    }
  }
}
-- diff/-out/evalalpha<==>+out/eval --
diff old new
--- old
+++ new
@@ -4,22 +4,25 @@
 b12b.#list.tail: structural cycle
 b13.root.a.0.0: structural cycle
 b14.root.b.1.1: structural cycle
+b4.b.0: conflicting values 1 and [y] (mismatched types int and list):
+    ./in.cue:55:12
+    ./in.cue:56:8
+b4.b.0.0: structural cycle
 b4.cond1.x.y.0: structural cycle
 b4.cond2.x.y.0: structural cycle
 b4.x.y.0: structural cycle
 b6.b.a.0: conflicting values 1 and [1] (mismatched types int and list):
-    ./in.cue:94:5
     ./in.cue:94:13
     ./in.cue:94:14
-    ./in.cue:95:9
 b6.b.a.0.0: structural cycle
 b6.x.a.0: structural cycle
 b7.a.0: structural cycle
-c1.a.c.c: structural cycle
-d1.a.b.c.d.t: structural cycle
-d2.a.b.c.d.t: structural cycle
-d2.r.c.d.t: structural cycle
-d3.x.a.b.c: structural cycle
+b7.b.0.0: conflicting values 1 and [a] (mismatched types int and list):
+    ./in.cue:99:11
+    ./in.cue:100:5
+b7.b.0.0.0: structural cycle
+c1.a.c: structural cycle
+d1.r: structural cycle
 e1.a.c: structural cycle
 e1.b.c: structural cycle
 e2.a.c: structural cycle
@@ -32,61 +35,74 @@
     ./in.cue:403:5
     ./in.cue:404:5
 e3.b.c: structural cycle
-e4.a.0: 4 errors in empty disjunction:
 e4.a.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
     ./in.cue:408:10
     ./in.cue:409:6
-e4.a.0.0: 2 errors in empty disjunction:
-e4.a.0.0: conflicting values [[{c:1}]] and {c:1} (mismatched types list and struct):
-    ./in.cue:409:5
+e4.a.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
+    ./in.cue:409:6
     ./in.cue:409:7
 e4.a.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
-    ./in.cue:408:6
-    ./in.cue:408:10
-    ./in.cue:409:6
-e4.b.0: 4 errors in empty disjunction:
+    ./in.cue:408:10
+    ./in.cue:409:6
+e4.a.0.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
+    ./in.cue:409:6
+    ./in.cue:409:7
+e4.a.0.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
+    ./in.cue:408:10
+    ./in.cue:409:6
+e4.a.0.0.0: structural cycle
 e4.b.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
     ./in.cue:411:6
     ./in.cue:412:10
-e4.b.0.0: 2 errors in empty disjunction:
-e4.b.0.0: conflicting values [(b|{})] and {c:1} (mismatched types list and struct):
-    ./in.cue:411:7
-    ./in.cue:412:5
+e4.b.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
+    ./in.cue:411:6
+    ./in.cue:411:7
 e4.b.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
     ./in.cue:411:6
-    ./in.cue:412:6
-    ./in.cue:412:10
-nestedList.v1e.y.0: 4 errors in empty disjunction:
+    ./in.cue:412:10
+e4.b.0.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
+    ./in.cue:411:6
+    ./in.cue:411:7
+e4.b.0.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
+    ./in.cue:411:6
+    ./in.cue:412:10
+e4.b.0.0.0: structural cycle
 nestedList.v1e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
     ./in.cue:426:11
     ./in.cue:427:11
-nestedList.v1e.y.0.0: 2 errors in empty disjunction:
 nestedList.v1e.y.0.0: conflicting values int and [2] (mismatched types int and list):
     ./in.cue:426:11
     ./in.cue:427:12
-nestedList.v1e.y.0.0: incompatible list lengths (1 and 2)
-nestedList.v2e.y.0: 4 errors in empty disjunction:
 nestedList.v2e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
     ./in.cue:431:11
     ./in.cue:432:11
-nestedList.v2e.y.0.0: 2 errors in empty disjunction:
 nestedList.v2e.y.0.0: conflicting values int and [2] (mismatched types int and list):
     ./in.cue:431:12
     ./in.cue:432:11
-nestedList.v2e.y.0.0: incompatible list lengths (1 and 2)
 p2.#T.a.b.link: structural cycle
 p3.#U.#T.a.b.link: structural cycle
 p5.#T.a.0.link: structural cycle
 p6.#U.#T.a.0.link: structural cycle
 patternFail.issue2374.a.b: structural cycle
-shortPathFail.elipsis.t2.Foo.ref.ref: structural cycle
-withLetFail.schema.next: structural cycle
-z1.z.f.h: structural cycle
+shortPathFail.elipsis.t2.Foo.ref: structural cycle
+withLetFail._schema_1: structural cycle
 z1.z.g.h: structural cycle
-d1.r: structural cycle:
-    ./in.cue:301:26
-d3.x.indirect: structural cycle:
-    ./in.cue:316:12
+d3.config.0: structural cycle:
+    ./in.cue:317:13
+fieldsSumInfinite.issue3310.3: structural cycle:
+    ./in.cue:371:18
+e4.a.0.0: cannot combine regular field "c" with [1,{c:1} & (a|{}) & [{c:1}]]:
+    ./in.cue:409:11
+e4.a.0.0.0: cannot combine regular field "c" with [1,{c:1}]:
+    ./in.cue:409:11
+e4.b.0.0: cannot combine regular field "c" with [1,{c:1} & [{c:1}] & (b|{})]:
+    ./in.cue:411:11
+e4.b.0.0.0: cannot combine regular field "c" with [1,{c:1}]:
+    ./in.cue:411:11
+nestedList.v1e.y.0.0: incompatible list lengths (1 and 2):
+    ./in.cue:426:6
+nestedList.v2e.y.0.0: incompatible list lengths (1 and 2):
+    ./in.cue:432:6
 
 Result:
 (_|_){
@@ -128,10 +144,7 @@
   a7: (struct){
     a: (string){ "foo" }
     b: (struct){
-      x: (struct){
-        x: (string){ "foo" }
-        y: (int){ 3 }
-      }
+      x: ~(a7.c)
       y: (string){ "foo" }
     }
     c: (struct){
@@ -168,11 +181,17 @@
     }
   }
   b4: (_|_){
-    // [structural cycle]
-    b: (_|_){
-      // [structural cycle]
-      0: (_|_){
-        // [structural cycle] b4.x.y.0: structural cycle
+    // [eval]
+    b: (_|_){
+      // [eval]
+      0: (_|_){
+        // [eval] b4.b.0: conflicting values 1 and [y] (mismatched types int and list):
+        //     ./in.cue:55:12
+        //     ./in.cue:56:8
+        // b4.b.0.0: structural cycle
+        0: (_|_){
+          // [structural cycle] b4.b.0.0: structural cycle
+        }
       }
     }
     x: (_|_){
@@ -240,10 +259,9 @@
         // [eval]
         0: (_|_){
           // [eval] b6.b.a.0: conflicting values 1 and [1] (mismatched types int and list):
-          //     ./in.cue:94:5
           //     ./in.cue:94:13
           //     ./in.cue:94:14
-          //     ./in.cue:95:9
+          // b6.b.a.0.0: structural cycle
           0: (_|_){
             // [structural cycle] b6.b.a.0.0: structural cycle
           }
@@ -261,11 +279,20 @@
     }
   }
   b7: (_|_){
-    // [structural cycle]
-    b: (_|_){
-      // [structural cycle]
-      0: (_|_){
-        // [structural cycle] b7.a.0: structural cycle
+    // [eval]
+    b: (_|_){
+      // [eval]
+      0: (_|_){
+        // [eval]
+        0: (_|_){
+          // [eval] b7.b.0.0: conflicting values 1 and [a] (mismatched types int and list):
+          //     ./in.cue:99:11
+          //     ./in.cue:100:5
+          // b7.b.0.0.0: structural cycle
+          0: (_|_){
+            // [structural cycle] b7.b.0.0.0: structural cycle
+          }
+        }
       }
     }
     a: (_|_){
@@ -276,9 +303,7 @@
     }
   }
   b8: (struct){
-    x: (struct){
-      f: (string){ string }
-    }
+    x: ~(b8.a)
     a: (struct){
       f: (string){ string }
     }
@@ -304,7 +329,7 @@
     #ref: (#struct){
       ref: (string){ string }
     }
-    x: (#struct){ |((#struct){
+    x: (struct){ |((#struct){
         c: (#list){
           0: ((string|struct)){ |((string){ string }, (#struct){
               ref: (string){ string }
@@ -327,7 +352,13 @@
         }) }
     }
     c: (#struct){
-      d: (string){ string }
+      d: ((string|struct)){ |((string){ string }, (#struct){
+          b: ((string|struct)){ |((string){ string }, (#struct){
+              b: ((string|struct)){ |((string){ string }, (#struct){
+                  b: (string){ string }
+                }) }
+            }) }
+        }) }
     }
     d: (struct){
       d: (struct){
@@ -337,9 +368,7 @@
   }
   b11: (struct){
     #list: (#struct){
-      tail: ((null|struct)){ |(*(null){ null }, (#struct){
-          tail: (null){ null }
-        }) }
+      tail: (null){ null }
     }
   }
   b12: (struct){
@@ -356,7 +385,11 @@
           value: (int){ 3 }
           tail: (#struct){
             value: (int){ 4 }
-            tail: (null){ null }
+            tail: ((null|struct)){ |(*(null){ null }, (#struct){
+                value: (int){ int }
+                tail: (null){ null }
+                sum: (int){ int }
+              }) }
             sum: (int){ 4 }
           }
           sum: (int){ 7 }
@@ -428,10 +461,7 @@
           link: (#struct){
             a: (#struct){
               two: (#struct){
-                link: (#struct){
-                  a: (#struct){
-                  }
-                }
+                link: ~(p1.#T)
               }
             }
           }
@@ -505,10 +535,7 @@
           link: (#struct){
             a: (#list){
               0: (#struct){
-                link: (#struct){
-                  a: (list){
-                  }
-                }
+                link: ~(p4.#T)
               }
             }
           }
@@ -578,12 +605,7 @@
       b: (struct){
       }
       c: (_|_){
-        // [structural cycle]
-        b: (struct){
-        }
-        c: (_|_){
-          // [structural cycle] c1.a.c.c: structural cycle
-        }
+        // [structural cycle] c1.a.c: structural cycle
       }
     }
   }
@@ -599,56 +621,26 @@
             // [structural cycle]
             h: (int){ int }
             t: (_|_){
-              // [structural cycle] d1.a.b.c.d.t: structural cycle
-            }
-          }
-        }
-      }
-    }
-    r: (_|_){
-      // [structural cycle] d1.r: structural cycle:
-      //     ./in.cue:301:26
-    }
-    x: (_|_){
-      // [structural cycle] d1.a.b.c.d.t: structural cycle
-    }
-  }
-  d2: (_|_){
-    // [structural cycle]
-    x: (_|_){
-      // [structural cycle]
-      d: (_|_){
-        // [structural cycle]
-        h: (int){ int }
-        t: (_|_){
-          // [structural cycle]
-        }
-      }
-    }
-    r: (_|_){
-      // [structural cycle]
-      c: (_|_){
-        // [structural cycle]
-        d: (_|_){
-          // [structural cycle]
-          h: (int){ int }
-          t: (_|_){
-            // [structural cycle] d2.r.c.d.t: structural cycle
-          }
-        }
-      }
-    }
-    a: (struct){
-      b: (struct){
-        c: (_|_){
-          // [structural cycle]
-          d: (_|_){
-            // [structural cycle]
-            h: (int){ int }
-            t: (_|_){
-              // [structural cycle] d2.a.b.c.d.t: structural cycle
-            }
-          }
+              // [structural cycle] d1.r: structural cycle
+            }
+          }
+        }
+      }
+    }
+    r: (_|_){
+      // [structural cycle] d1.r: structural cycle
+    }
+    x: (_|_){
+      // [structural cycle] d1.r: structural cycle
+    }
+  }
+  d2: (struct){
+    x: ~(d2.a.b.c)
+    r: ~(d2.a.b)
+    a: (struct){
+      b: (struct){
+        c: (_|_){
+          // [cycle] d2.a.b.c: mutual dependency
         }
       }
     }
@@ -655,16 +647,7 @@
   }
   d3: (_|_){
     // [structural cycle]
-    config: (struct){
-      a: (struct){
-        b: (struct){
-          c: (null){ null }
-        }
-      }
-      indirect: (null){ null }
-      i: (int){ |(*(int){ 1 }, (int){ int }) }
-    }
-    x: (_|_){
+    config: (_|_){
       // [structural cycle]
       a: (_|_){
         // [structural cycle]
@@ -671,14 +654,19 @@
         b: (_|_){
           // [structural cycle]
           c: (_|_){
-            // [structural cycle] d3.x.a.b.c: structural cycle
+            // [structural cycle] d3.config.0: structural cycle:
+            //     ./in.cue:317:13
           }
         }
       }
       indirect: (_|_){
-        // [structural cycle] d3.x.indirect: structural cycle:
-        //     ./in.cue:316:12
-      }
+        // [structural cycle] d3.config.0: structural cycle:
+        //     ./in.cue:317:13
+      }
+      i: (int){ |(*(int){ 1 }, (int){ int }) }
+    }
+    x: (_|_){
+      // [structural cycle]
       i: (int){ 0 }
     }
   }
@@ -685,9 +673,7 @@
   shortPathFail: (_|_){
     // [structural cycle]
     doubleRef: (struct){
-      a: (#struct){
-        Next: (null){ null }
-      }
+      a: ~(shortPathFail.doubleRef.#List)
       #List: (#struct){
         Next: (null){ null }
       }
@@ -696,9 +682,7 @@
       // [structural cycle]
       t1: (struct){
         #Foo: (#struct){
-          ref: ((null|struct)){ |((null){ null }, (#struct){
-              ref: (null){ null }
-            }) }
+          ref: (null){ null }
         }
       }
       t2: (_|_){
@@ -706,10 +690,7 @@
         Foo: (_|_){
           // [structural cycle]
           ref: (_|_){
-            // [structural cycle]
-            ref: (_|_){
-              // [structural cycle] shortPathFail.elipsis.t2.Foo.ref.ref: structural cycle
-            }
+            // [structural cycle] shortPathFail.elipsis.t2.Foo.ref: structural cycle
           }
         }
       }
@@ -716,9 +697,7 @@
     }
     comprehension: (struct){
       #list: (#struct){
-        tail: ((null|struct)){ |(*(null){ null }, (#struct){
-            tail: (null){ null }
-          }) }
+        tail: (null){ null }
       }
     }
   }
@@ -740,20 +719,24 @@
     schema: (_|_){
       // [structural cycle]
       next: (_|_){
-        // [structural cycle] withLetFail.schema.next: structural cycle
+        // [structural cycle] withLetFail._schema_1: structural cycle
       }
     }
     let _schema_1#1 = (_|_){
-      // [structural cycle] withLetFail._schema_1: structural cycle:
-      //     ./in.cue:362:17
-    }
-  }
-  fieldsSumInfinite: (struct){
-    issue3310: (struct){
+      // [structural cycle] withLetFail._schema_1: structural cycle
+    }
+  }
+  fieldsSumInfinite: (_|_){
+    // [structural cycle]
+    issue3310: (_|_){
+      // [structural cycle]
       cheeseburger: (float){ 3.00 }
       fries: (float){ 2.00 }
       sprite: (float){ 1.00 }
-      total: (int){ 18 }
+      total: (_|_){
+        // [structural cycle] fieldsSumInfinite.issue3310.3: structural cycle:
+        //     ./in.cue:371:18
+      }
     }
   }
   listOptOK: (struct){
@@ -767,9 +750,7 @@
       head: (int){ 3 }
       tail: (struct){
         head: (int){ 2 }
-        tail?: (_|_){
-          // [structural cycle] listOptOK.a.tail.tail: structural cycle
-        }
+        tail?: ~(listOptOK.list)
       }
     }
   }
@@ -809,11 +790,12 @@
       // [eval] e3.a: conflicting values [a] and {c:a} (mismatched types list and struct):
       //     ./in.cue:400:5
       //     ./in.cue:401:5
-      c: (_|_){
-        // [structural cycle] e3.a.c: structural cycle
-      }
-      0: (_|_){
-        // [structural cycle] e3.a.c: structural cycle
+      // e3.a.c: structural cycle
+      c: (_|_){
+        // [structural cycle] e3.a.c: structural cycle
+      }
+      0: (_|_){
+        // [structural cycle] e3.a.0: structural cycle
       }
     }
     b: (_|_){
@@ -820,11 +802,12 @@
       // [eval] e3.b: conflicting values [b] and {c:b} (mismatched types list and struct):
       //     ./in.cue:403:5
       //     ./in.cue:404:5
-      c: (_|_){
-        // [structural cycle] e3.b.c: structural cycle
-      }
-      0: (_|_){
-        // [structural cycle] e3.b.c: structural cycle
+      // e3.b.c: structural cycle
+      c: (_|_){
+        // [structural cycle] e3.b.c: structural cycle
+      }
+      0: (_|_){
+        // [structural cycle] e3.b.0: structural cycle
       }
     }
   }
@@ -833,41 +816,51 @@
     a: (_|_){
       // [eval]
       0: (_|_){
-        // [eval] e4.a.0: 4 errors in empty disjunction:
-        // e4.a.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
-        //     ./in.cue:408:10
-        //     ./in.cue:409:6
-        // e4.a.0.0: 2 errors in empty disjunction:
-        // e4.a.0.0: conflicting values [[{c:1}]] and {c:1} (mismatched types list and struct):
-        //     ./in.cue:409:5
+        // [eval] e4.a.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
+        //     ./in.cue:408:10
+        //     ./in.cue:409:6
+        // e4.a.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
+        //     ./in.cue:409:6
         //     ./in.cue:409:7
         // e4.a.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
-        //     ./in.cue:408:6
-        //     ./in.cue:408:10
-        //     ./in.cue:409:6
-        0: (struct){
-          c: (int){ 1 }
-        }
-      }
-    }
-    b: (_|_){
-      // [eval]
-      0: (_|_){
-        // [eval] e4.b.0: 4 errors in empty disjunction:
-        // e4.b.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
-        //     ./in.cue:411:6
-        //     ./in.cue:412:10
-        // e4.b.0.0: 2 errors in empty disjunction:
-        // e4.b.0.0: conflicting values [(b|{})] and {c:1} (mismatched types list and struct):
-        //     ./in.cue:411:7
-        //     ./in.cue:412:5
+        //     ./in.cue:408:10
+        //     ./in.cue:409:6
+        // e4.a.0.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
+        //     ./in.cue:409:6
+        //     ./in.cue:409:7
+        // e4.a.0.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
+        //     ./in.cue:408:10
+        //     ./in.cue:409:6
+        // e4.a.0.0.0: structural cycle
+        // e4.a.0.0: cannot combine regular field "c" with [1,{c:1} & (a|{}) & [{c:1}]]:
+        //     ./in.cue:409:11
+        // e4.a.0.0.0: cannot combine regular field "c" with [1,{c:1}]:
+        //     ./in.cue:409:11
+      }
+    }
+    b: (_|_){
+      // [eval]
+      0: (_|_){
+        // [eval] e4.b.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
+        //     ./in.cue:411:6
+        //     ./in.cue:412:10
+        // e4.b.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
+        //     ./in.cue:411:6
+        //     ./in.cue:411:7
         // e4.b.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
         //     ./in.cue:411:6
-        //     ./in.cue:412:6
-        //     ./in.cue:412:10
-        0: (struct){
-          c: (int){ 1 }
-        }
+        //     ./in.cue:412:10
+        // e4.b.0.0.0: conflicting values [{c:1}] and {c:1} (mismatched types list and struct):
+        //     ./in.cue:411:6
+        //     ./in.cue:411:7
+        // e4.b.0.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
+        //     ./in.cue:411:6
+        //     ./in.cue:412:10
+        // e4.b.0.0.0: structural cycle
+        // e4.b.0.0: cannot combine regular field "c" with [1,{c:1} & [{c:1}] & (b|{})]:
+        //     ./in.cue:411:11
+        // e4.b.0.0.0: cannot combine regular field "c" with [1,{c:1}]:
+        //     ./in.cue:411:11
       }
     }
   }
@@ -890,19 +883,14 @@
       y: (_|_){
         // [eval]
         0: (_|_){
-          // [eval] nestedList.v1e.y.0: 4 errors in empty disjunction:
-          // nestedList.v1e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
+          // [eval] nestedList.v1e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
           //     ./in.cue:426:11
           //     ./in.cue:427:11
-          // nestedList.v1e.y.0.0: 2 errors in empty disjunction:
           // nestedList.v1e.y.0.0: conflicting values int and [2] (mismatched types int and list):
           //     ./in.cue:426:11
           //     ./in.cue:427:12
-          // nestedList.v1e.y.0.0: incompatible list lengths (1 and 2)
-          0: (#list){
-            0: (int){ 2 }
-          }
-          1: (int){ 1 }
+          // nestedList.v1e.y.0.0: incompatible list lengths (1 and 2):
+          //     ./in.cue:426:6
         }
         1: (int){ 1 }
       }
@@ -912,19 +900,14 @@
       y: (_|_){
         // [eval]
         0: (_|_){
-          // [eval] nestedList.v2e.y.0: 4 errors in empty disjunction:
-          // nestedList.v2e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
+          // [eval] nestedList.v2e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
           //     ./in.cue:431:11
           //     ./in.cue:432:11
-          // nestedList.v2e.y.0.0: 2 errors in empty disjunction:
           // nestedList.v2e.y.0.0: conflicting values int and [2] (mismatched types int and list):
           //     ./in.cue:431:12
           //     ./in.cue:432:11
-          // nestedList.v2e.y.0.0: incompatible list lengths (1 and 2)
-          0: (#list){
-            0: (int){ 2 }
-          }
-          1: (int){ 1 }
+          // nestedList.v2e.y.0.0: incompatible list lengths (1 and 2):
+          //     ./in.cue:432:6
         }
         1: (int){ 1 }
       }
@@ -977,7 +960,10 @@
         head: (int){ 3 }
         tail: (struct){
           head: (int){ 4 }
-          tail: (null){ null }
+          tail: ((null|struct)){ |((struct){
+              head: (int){ int }
+              tail: (null){ null }
+            }, (null){ null }) }
         }
       }
     }
@@ -991,7 +977,10 @@
       head: (int){ 2 }
       tail: (struct){
         head: (int){ 3 }
-        tail: (int){ 1 }
+        tail: ((int|struct)){ |((struct){
+            head: (int){ int }
+            tail: (int){ 1 }
+          }, (int){ 1 }) }
       }
     }
   }
@@ -1005,8 +994,12 @@
       head: (int){ 2 }
       tail: (struct){ |((struct){
           head: (int){ 3 }
-          tail: (struct){
-          }
+          tail: (struct){ |((struct){
+              head: (int){ int }
+              tail: (struct){
+              }
+            }, (struct){
+            }) }
         }, (struct){
           head: (int){ 3 }
         }) }
@@ -1028,9 +1021,7 @@
       // [structural cycle]
       f: (_|_){
         // [structural cycle]
-        h: (_|_){
-          // [structural cycle] z1.z.f.h: structural cycle
-        }
+        h: ~(z1.z.g)
       }
       g: (_|_){
         // [structural cycle]
@@ -1051,10 +1042,7 @@
           x: (_){ _ }
           y: (_){ _ }
         }
-        y: (struct){
-          x: (_){ _ }
-          y: (_){ _ }
-        }
+        y: ~(crossRefNoCycle.t1.C.x)
       }
     }
     t2: (struct){
@@ -1067,10 +1055,7 @@
           x: (_){ _ }
           y: (_){ _ }
         }
-        y: (struct){
-          x: (_){ _ }
-          y: (_){ _ }
-        }
+        y: ~(crossRefNoCycle.t2.C.x)
       }
     }
     t3: (struct){
@@ -1085,16 +1070,8 @@
           y: (_){ _ }
           z: (_){ _ }
         }
-        y: (struct){
-          x: (_){ _ }
-          y: (_){ _ }
-          z: (_){ _ }
-        }
-        z: (struct){
-          x: (_){ _ }
-          y: (_){ _ }
-          z: (_){ _ }
-        }
+        y: ~(crossRefNoCycle.t3.C.x)
+        z: ~(crossRefNoCycle.t3.C.x)
       }
     }
     t4: (struct){
@@ -1110,51 +1087,11 @@
             y: (_){ _ }
             z: (_){ _ }
           }
-          y: (struct){
-            x: (_){ _ }
-            y: (_){ _ }
-            z: (_){ _ }
-          }
-          z: (struct){
-            x: (_){ _ }
-            y: (_){ _ }
-            z: (_){ _ }
-          }
-        }
-        y: (struct){
-          x: (struct){
-            x: (_){ _ }
-            y: (_){ _ }
-            z: (_){ _ }
-          }
-          y: (struct){
-            x: (_){ _ }
-            y: (_){ _ }
-            z: (_){ _ }
-          }
-          z: (struct){
-            x: (_){ _ }
-            y: (_){ _ }
-            z: (_){ _ }
-          }
-        }
-        z: (struct){
-          x: (struct){
-            x: (_){ _ }
-            y: (_){ _ }
-            z: (_){ _ }
-          }
-          y: (struct){
-            x: (_){ _ }
-            y: (_){ _ }
-            z: (_){ _ }
-          }
-          z: (struct){
-            x: (_){ _ }
-            y: (_){ _ }
-            z: (_){ _ }
-          }
-        }
+          y: ~(crossRefNoCycle.t4.C.x.x)
+          z: ~(crossRefNoCycle.t4.C.x.x)
+        }
+        y: ~(crossRefNoCycle.t4.C.x)
+        z: ~(crossRefNoCycle.t4.C.x)
       }
     }
   }
@@ -1177,19 +1114,19 @@
     }
   }
   n4: (struct){
-    a: (struct){
-      b: (int){ int }
-    }
-    x: (struct){
-      a: (struct){
-        b: (int){ int }
-      }
-      y: (struct){
+    x: (struct){
+      y: (struct){
+        z: (int){ int }
         a: (struct){
           b: (int){ int }
         }
-        z: (int){ int }
-      }
+      }
+      a: (struct){
+        b: (int){ int }
+      }
+    }
+    a: (struct){
+      b: (int){ int }
     }
   }
 }
-- diff/todo/p1 --
d2.x: reports mutual dependency, instead of structural cycle.
Reducer:
	x: a.c
	r: a
	a: c: r
-- diff/todo/p2 --
b7.b.0.0.0: cycle too deep before detection.
TODO(share): fix the following bug once we have structure sharing.
d3.config: should structural cycle be reported?
p3.a.a: field not allowed incorrect?
-- diff/todo/p3 --
n4: Reordering.
b12b: reported at correct level, but investigate if it is not processing
    too deep anyway.
-- diff/explanation --
Structural cycles are reported in all chains. compared to old implementation.
d3.config: reports cycle at correct position.
b4.b: Structural error converted to eval error: there is both a structural and
   eval error at this field. The newly reported error is correct.
b7.b.0.0: structural cycle nested one too deep: the eval error takes precedence.
   The cycle is reported at the correct level according to the spec.
b10.c.d: position now allows b: string as well. This is correct. This is mostly
   a representational issue, as the evaluator would still accept such values
   when merged, but it is still useful.
fieldsSumInfinite.issue3310: evalv3 correctly spots a structural cycle,
   where evalv2 computes an incorrect result without erroring.
-- out/eval --
Errors:
a1.f.0: structural cycle
a3.f.g: structural cycle
b12b.#list.tail: structural cycle
b13.root.a.0.0: structural cycle
b14.root.b.1.1: structural cycle
b4.cond1.x.y.0: structural cycle
b4.cond2.x.y.0: structural cycle
b4.x.y.0: structural cycle
b6.b.a.0: conflicting values 1 and [1] (mismatched types int and list):
    ./in.cue:94:5
    ./in.cue:94:13
    ./in.cue:94:14
    ./in.cue:95:9
b6.b.a.0.0: structural cycle
b6.x.a.0: structural cycle
b7.a.0: structural cycle
c1.a.c.c: structural cycle
d1.a.b.c.d.t: structural cycle
d2.a.b.c.d.t: structural cycle
d2.r.c.d.t: structural cycle
d3.x.a.b.c: structural cycle
e1.a.c: structural cycle
e1.b.c: structural cycle
e2.a.c: structural cycle
e2.b.c: structural cycle
e3.a: conflicting values [a] and {c:a} (mismatched types list and struct):
    ./in.cue:400:5
    ./in.cue:401:5
e3.a.c: structural cycle
e3.b: conflicting values [b] and {c:b} (mismatched types list and struct):
    ./in.cue:403:5
    ./in.cue:404:5
e3.b.c: structural cycle
e4.a.0: 4 errors in empty disjunction:
e4.a.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:408:10
    ./in.cue:409:6
e4.a.0.0: 2 errors in empty disjunction:
e4.a.0.0: conflicting values [[{c:1}]] and {c:1} (mismatched types list and struct):
    ./in.cue:409:5
    ./in.cue:409:7
e4.a.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:408:6
    ./in.cue:408:10
    ./in.cue:409:6
e4.b.0: 4 errors in empty disjunction:
e4.b.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:411:6
    ./in.cue:412:10
e4.b.0.0: 2 errors in empty disjunction:
e4.b.0.0: conflicting values [(b|{})] and {c:1} (mismatched types list and struct):
    ./in.cue:411:7
    ./in.cue:412:5
e4.b.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:411:6
    ./in.cue:412:6
    ./in.cue:412:10
nestedList.v1e.y.0: 4 errors in empty disjunction:
nestedList.v1e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
    ./in.cue:426:11
    ./in.cue:427:11
nestedList.v1e.y.0.0: 2 errors in empty disjunction:
nestedList.v1e.y.0.0: conflicting values int and [2] (mismatched types int and list):
    ./in.cue:426:11
    ./in.cue:427:12
nestedList.v1e.y.0.0: incompatible list lengths (1 and 2)
nestedList.v2e.y.0: 4 errors in empty disjunction:
nestedList.v2e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
    ./in.cue:431:11
    ./in.cue:432:11
nestedList.v2e.y.0.0: 2 errors in empty disjunction:
nestedList.v2e.y.0.0: conflicting values int and [2] (mismatched types int and list):
    ./in.cue:431:12
    ./in.cue:432:11
nestedList.v2e.y.0.0: incompatible list lengths (1 and 2)
p2.#T.a.b.link: structural cycle
p3.#U.#T.a.b.link: structural cycle
p5.#T.a.0.link: structural cycle
p6.#U.#T.a.0.link: structural cycle
patternFail.issue2374.a.b: structural cycle
shortPathFail.elipsis.t2.Foo.ref.ref: structural cycle
withLetFail.schema.next: structural cycle
z1.z.f.h: structural cycle
z1.z.g.h: structural cycle
d1.r: structural cycle:
    ./in.cue:301:26
d3.x.indirect: structural cycle:
    ./in.cue:316:12

Result:
(_|_){
  // [eval]
  a1: (_|_){
    // [structural cycle]
    f: (_|_){
      // [structural cycle]
      0: (_|_){
        // [structural cycle] a1.f.0: structural cycle
      }
    }
  }
  a2: (struct){
    f: (_){ _ }
  }
  a3: (_|_){
    // [structural cycle]
    f: (_|_){
      // [structural cycle]
      g: (_|_){
        // [structural cycle] a3.f.g: structural cycle
      }
    }
  }
  a4: (struct){
    a: (#list){
      0: (int){ int }
    }
  }
  a5: (struct){
    a: (struct){
      b: (int){ int }
    }
  }
  a6: (struct){
    a: (_){ |((_){ _ }, (int){ int }) }
  }
  a7: (struct){
    a: (string){ "foo" }
    b: (struct){
      x: (struct){
        x: (string){ "foo" }
        y: (int){ 3 }
      }
      y: (string){ "foo" }
    }
    c: (struct){
      x: (string){ "foo" }
      y: (int){ 3 }
    }
  }
  b1: (struct){
    b: (#list){
      0: (int){ 1 }
    }
    a: (#list){
      0: (int){ int }
    }
  }
  b2: (struct){
    a: (#list){
      0: (int){ int }
    }
    b: (#list){
      0: (int){ 1 }
    }
  }
  b3: (struct){
    x: (struct){
      a: (#list){
        0: (int){ int }
      }
    }
    b: (struct){
      a: (#list){
        0: (int){ 1 }
      }
    }
  }
  b4: (_|_){
    // [structural cycle]
    b: (_|_){
      // [structural cycle]
      0: (_|_){
        // [structural cycle] b4.x.y.0: structural cycle
      }
    }
    x: (_|_){
      // [structural cycle]
      y: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle] b4.x.y.0: structural cycle
        }
      }
    }
    cond1: (_|_){
      // [structural cycle]
      b: (#list){
        _z: (bool){ false }
        0: (int){ 1 }
      }
      x: (_|_){
        // [structural cycle]
        y: (_|_){
          // [structural cycle]
          _z: (bool){ |(*(bool){ true }, (bool){ bool }) }
          0: (_|_){
            // [structural cycle] b4.cond1.x.y.0: structural cycle
          }
        }
      }
    }
    cond2: (_|_){
      // [structural cycle]
      x: (_|_){
        // [structural cycle]
        y: (_|_){
          // [structural cycle]
          _z: (bool){ |(*(bool){ true }, (bool){ bool }) }
          0: (_|_){
            // [structural cycle] b4.cond2.x.y.0: structural cycle
          }
        }
      }
      b: (_|_){
        // [structural cycle] b4.cond2.x.y.0: structural cycle
      }
    }
  }
  b5: (struct){
    b: (struct){
      a: (#list){
        0: (int){ 1 }
      }
    }
    x: (struct){
      y: (struct){
        a: (#list){
          0: (int){ int }
        }
      }
    }
  }
  b6: (_|_){
    // [eval]
    b: (_|_){
      // [eval]
      a: (_|_){
        // [eval]
        0: (_|_){
          // [eval] b6.b.a.0: conflicting values 1 and [1] (mismatched types int and list):
          //     ./in.cue:94:5
          //     ./in.cue:94:13
          //     ./in.cue:94:14
          //     ./in.cue:95:9
          0: (_|_){
            // [structural cycle] b6.b.a.0.0: structural cycle
          }
        }
      }
    }
    x: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle] b6.x.a.0: structural cycle
        }
      }
    }
  }
  b7: (_|_){
    // [structural cycle]
    b: (_|_){
      // [structural cycle]
      0: (_|_){
        // [structural cycle] b7.a.0: structural cycle
      }
    }
    a: (_|_){
      // [structural cycle]
      0: (_|_){
        // [structural cycle] b7.a.0: structural cycle
      }
    }
  }
  b8: (struct){
    x: (struct){
      f: (string){ string }
    }
    a: (struct){
      f: (string){ string }
    }
    b: (string){ string }
  }
  b9: (struct){
    #a: ((string|struct)){ |((string){ string }, (#struct){
        ref: (string){ string }
      }) }
    #b: (#struct){
      c: (#list){
        0: ((string|struct)){ |((string){ string }, (#struct){
            ref: (string){ string }
          }) }
        1: ((string|struct)){ |((string){ string }, (#struct){
            ref: (string){ string }
          }) }
        2: ((string|struct)){ |((string){ string }, (#struct){
            ref: (string){ string }
          }) }
      }
    }
    #ref: (#struct){
      ref: (string){ string }
    }
    x: (#struct){ |((#struct){
        c: (#list){
          0: ((string|struct)){ |((string){ string }, (#struct){
              ref: (string){ string }
            }) }
          1: ((string|struct)){ |((string){ string }, (#struct){
              ref: (string){ string }
            }) }
          2: ((string|struct)){ |((string){ string }, (#struct){
              ref: (string){ string }
            }) }
        }
      }, (#struct){
        ref: (string){ string }
      }) }
  }
  b10: (struct){
    a: (#struct){
      b: ((string|struct)){ |((string){ string }, (#struct){
          d: (string){ string }
        }) }
    }
    c: (#struct){
      d: (string){ string }
    }
    d: (struct){
      d: (struct){
        b: (string){ string }
      }
    }
  }
  b11: (struct){
    #list: (#struct){
      tail: ((null|struct)){ |(*(null){ null }, (#struct){
          tail: (null){ null }
        }) }
    }
  }
  b12: (struct){
    #list: (#struct){
      value: (int){ int }
      tail: (null){ null }
      sum: (int){ int }
    }
    list1: (#struct){
      value: (int){ 1 }
      tail: (#struct){
        value: (int){ 2 }
        tail: (#struct){
          value: (int){ 3 }
          tail: (#struct){
            value: (int){ 4 }
            tail: (null){ null }
            sum: (int){ 4 }
          }
          sum: (int){ 7 }
        }
        sum: (int){ 9 }
      }
      sum: (int){ 10 }
    }
  }
  b12b: (_|_){
    // [structural cycle]
    #list: (_|_){
      // [structural cycle] b12b.#list.tail: structural cycle
    }
    list1: (_|_){
      // [structural cycle] b12b.#list.tail: structural cycle
    }
  }
  b13: (_|_){
    // [structural cycle]
    root: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle]
          0: (_|_){
            // [structural cycle] b13.root.a.0.0: structural cycle
          }
        }
      }
    }
  }
  b14: (_|_){
    // [structural cycle]
    root: (_|_){
      // [structural cycle]
      a: (list){
      }
      b: (_|_){
        // [structural cycle]
        0: (list){
        }
        1: (_|_){
          // [structural cycle]
          0: (list){
          }
          1: (_|_){
            // [structural cycle] b14.root.b.1.1: structural cycle
          }
        }
      }
    }
  }
  b15: (struct){
    root: (struct){
      a: (struct){
      }
    }
  }
  p1: (struct){
    #T: (#struct){
      a: (#struct){
      }
    }
    a: (#struct){
      a: (#struct){
        one: (#struct){
          link: (#struct){
            a: (#struct){
              two: (#struct){
                link: (#struct){
                  a: (#struct){
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  p2: (_|_){
    // [structural cycle]
    #T: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        b: (_|_){
          // [structural cycle]
          link: (_|_){
            // [structural cycle] p2.#T.a.b.link: structural cycle
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle]
      a: (struct){
        one: (struct){
          link: (struct){
            a: (struct){
              two: (struct){
              }
            }
          }
        }
      }
    }
  }
  p3: (_|_){
    // [structural cycle]
    #S: (#struct){
      #T: (#struct){
        a: (#struct){
        }
      }
    }
    #U: (_|_){
      // [structural cycle]
      #T: (_|_){
        // [structural cycle]
        a: (_|_){
          // [structural cycle]
          b: (_|_){
            // [structural cycle]
            link: (_|_){
              // [structural cycle] p3.#U.#T.a.b.link: structural cycle
            }
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle] p3.#U.#T.a.b.link: structural cycle
    }
  }
  p4: (struct){
    #T: (#struct){
      a: (list){
      }
    }
    a: (#struct){
      a: (#list){
        0: (#struct){
          link: (#struct){
            a: (#list){
              0: (#struct){
                link: (#struct){
                  a: (list){
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  p5: (_|_){
    // [structural cycle]
    #T: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle]
          link: (_|_){
            // [structural cycle] p5.#T.a.0.link: structural cycle
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle]
      a: (#list){
        0: (struct){
          link: (struct){
            a: (#list){
              0: (struct){
              }
            }
          }
        }
      }
    }
  }
  p6: (_|_){
    // [structural cycle]
    #S: (#struct){
      #T: (#struct){
        a: (list){
        }
      }
    }
    #U: (_|_){
      // [structural cycle]
      #T: (_|_){
        // [structural cycle]
        a: (_|_){
          // [structural cycle]
          0: (_|_){
            // [structural cycle]
            link: (_|_){
              // [structural cycle] p6.#U.#T.a.0.link: structural cycle
            }
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle] p6.#U.#T.a.0.link: structural cycle
    }
  }
  c1: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      b: (struct){
      }
      c: (_|_){
        // [structural cycle]
        b: (struct){
        }
        c: (_|_){
          // [structural cycle] c1.a.c.c: structural cycle
        }
      }
    }
  }
  d1: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      b: (_|_){
        // [structural cycle]
        c: (_|_){
          // [structural cycle]
          d: (_|_){
            // [structural cycle]
            h: (int){ int }
            t: (_|_){
              // [structural cycle] d1.a.b.c.d.t: structural cycle
            }
          }
        }
      }
    }
    r: (_|_){
      // [structural cycle] d1.r: structural cycle:
      //     ./in.cue:301:26
    }
    x: (_|_){
      // [structural cycle] d1.a.b.c.d.t: structural cycle
    }
  }
  d2: (_|_){
    // [structural cycle]
    x: (_|_){
      // [structural cycle]
      d: (_|_){
        // [structural cycle]
        h: (int){ int }
        t: (_|_){
          // [structural cycle]
        }
      }
    }
    r: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle]
        d: (_|_){
          // [structural cycle]
          h: (int){ int }
          t: (_|_){
            // [structural cycle] d2.r.c.d.t: structural cycle
          }
        }
      }
    }
    a: (struct){
      b: (struct){
        c: (_|_){
          // [structural cycle]
          d: (_|_){
            // [structural cycle]
            h: (int){ int }
            t: (_|_){
              // [structural cycle] d2.a.b.c.d.t: structural cycle
            }
          }
        }
      }
    }
  }
  d3: (_|_){
    // [structural cycle]
    config: (struct){
      a: (struct){
        b: (struct){
          c: (null){ null }
        }
      }
      indirect: (null){ null }
      i: (int){ |(*(int){ 1 }, (int){ int }) }
    }
    x: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        b: (_|_){
          // [structural cycle]
          c: (_|_){
            // [structural cycle] d3.x.a.b.c: structural cycle
          }
        }
      }
      indirect: (_|_){
        // [structural cycle] d3.x.indirect: structural cycle:
        //     ./in.cue:316:12
      }
      i: (int){ 0 }
    }
  }
  shortPathFail: (_|_){
    // [structural cycle]
    doubleRef: (struct){
      a: (#struct){
        Next: (null){ null }
      }
      #List: (#struct){
        Next: (null){ null }
      }
    }
    elipsis: (_|_){
      // [structural cycle]
      t1: (struct){
        #Foo: (#struct){
          ref: ((null|struct)){ |((null){ null }, (#struct){
              ref: (null){ null }
            }) }
        }
      }
      t2: (_|_){
        // [structural cycle]
        Foo: (_|_){
          // [structural cycle]
          ref: (_|_){
            // [structural cycle]
            ref: (_|_){
              // [structural cycle] shortPathFail.elipsis.t2.Foo.ref.ref: structural cycle
            }
          }
        }
      }
    }
    comprehension: (struct){
      #list: (#struct){
        tail: ((null|struct)){ |(*(null){ null }, (#struct){
            tail: (null){ null }
          }) }
      }
    }
  }
  patternFail: (_|_){
    // [structural cycle]
    issue2374: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        r: (int){ 0 }
        b: (_|_){
          // [structural cycle] patternFail.issue2374.a.b: structural cycle
        }
      }
    }
  }
  withLetFail: (_|_){
    // [structural cycle]
    schema: (_|_){
      // [structural cycle]
      next: (_|_){
        // [structural cycle] withLetFail.schema.next: structural cycle
      }
    }
    let _schema_1#1 = (_|_){
      // [structural cycle] withLetFail._schema_1: structural cycle:
      //     ./in.cue:362:17
    }
  }
  fieldsSumInfinite: (struct){
    issue3310: (struct){
      cheeseburger: (float){ 3.00 }
      fries: (float){ 2.00 }
      sprite: (float){ 1.00 }
      total: (int){ 18 }
    }
  }
  listOptOK: (struct){
    list: (struct){
      head: (int){ int }
      tail?: (_|_){
        // [structural cycle] listOptOK.list.tail: structural cycle
      }
    }
    a: (struct){
      head: (int){ 3 }
      tail: (struct){
        head: (int){ 2 }
        tail?: (_|_){
          // [structural cycle] listOptOK.a.tail.tail: structural cycle
        }
      }
    }
  }
  e1: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e1.a.c: structural cycle
      }
    }
    b: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e1.b.c: structural cycle
      }
    }
  }
  e2: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e2.a.c: structural cycle
      }
    }
    b: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e2.b.c: structural cycle
      }
    }
  }
  e3: (_|_){
    // [eval]
    a: (_|_){
      // [eval] e3.a: conflicting values [a] and {c:a} (mismatched types list and struct):
      //     ./in.cue:400:5
      //     ./in.cue:401:5
      c: (_|_){
        // [structural cycle] e3.a.c: structural cycle
      }
      0: (_|_){
        // [structural cycle] e3.a.c: structural cycle
      }
    }
    b: (_|_){
      // [eval] e3.b: conflicting values [b] and {c:b} (mismatched types list and struct):
      //     ./in.cue:403:5
      //     ./in.cue:404:5
      c: (_|_){
        // [structural cycle] e3.b.c: structural cycle
      }
      0: (_|_){
        // [structural cycle] e3.b.c: structural cycle
      }
    }
  }
  e4: (_|_){
    // [eval]
    a: (_|_){
      // [eval]
      0: (_|_){
        // [eval] e4.a.0: 4 errors in empty disjunction:
        // e4.a.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:408:10
        //     ./in.cue:409:6
        // e4.a.0.0: 2 errors in empty disjunction:
        // e4.a.0.0: conflicting values [[{c:1}]] and {c:1} (mismatched types list and struct):
        //     ./in.cue:409:5
        //     ./in.cue:409:7
        // e4.a.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:408:6
        //     ./in.cue:408:10
        //     ./in.cue:409:6
        0: (struct){
          c: (int){ 1 }
        }
      }
    }
    b: (_|_){
      // [eval]
      0: (_|_){
        // [eval] e4.b.0: 4 errors in empty disjunction:
        // e4.b.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:411:6
        //     ./in.cue:412:10
        // e4.b.0.0: 2 errors in empty disjunction:
        // e4.b.0.0: conflicting values [(b|{})] and {c:1} (mismatched types list and struct):
        //     ./in.cue:411:7
        //     ./in.cue:412:5
        // e4.b.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:411:6
        //     ./in.cue:412:6
        //     ./in.cue:412:10
        0: (struct){
          c: (int){ 1 }
        }
      }
    }
  }
  e5: (struct){
    a: (struct){
      c: (int){ int }
    }
    b: (struct){
      c: (int){ int }
    }
  }
  nestedList: (_|_){
    // [eval]
    v1e: (_|_){
      // [eval]
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
      y: (_|_){
        // [eval]
        0: (_|_){
          // [eval] nestedList.v1e.y.0: 4 errors in empty disjunction:
          // nestedList.v1e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
          //     ./in.cue:426:11
          //     ./in.cue:427:11
          // nestedList.v1e.y.0.0: 2 errors in empty disjunction:
          // nestedList.v1e.y.0.0: conflicting values int and [2] (mismatched types int and list):
          //     ./in.cue:426:11
          //     ./in.cue:427:12
          // nestedList.v1e.y.0.0: incompatible list lengths (1 and 2)
          0: (#list){
            0: (int){ 2 }
          }
          1: (int){ 1 }
        }
        1: (int){ 1 }
      }
    }
    v2e: (_|_){
      // [eval]
      y: (_|_){
        // [eval]
        0: (_|_){
          // [eval] nestedList.v2e.y.0: 4 errors in empty disjunction:
          // nestedList.v2e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
          //     ./in.cue:431:11
          //     ./in.cue:432:11
          // nestedList.v2e.y.0.0: 2 errors in empty disjunction:
          // nestedList.v2e.y.0.0: conflicting values int and [2] (mismatched types int and list):
          //     ./in.cue:431:12
          //     ./in.cue:432:11
          // nestedList.v2e.y.0.0: incompatible list lengths (1 and 2)
          0: (#list){
            0: (int){ 2 }
          }
          1: (int){ 1 }
        }
        1: (int){ 1 }
      }
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
    }
    v1: (struct){
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
      y: (#list){
        0: (#list){
          0: (#list){
            0: (int){ 2 }
            1: (int){ 1 }
          }
          1: (int){ 1 }
        }
        1: (int){ 1 }
      }
    }
    v2: (struct){
      y: (#list){
        0: (#list){
          0: (#list){
            0: (int){ 2 }
            1: (int){ 1 }
          }
          1: (int){ 1 }
        }
        1: (int){ 1 }
      }
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
    }
  }
  v3: (struct){
    list: (struct){
      head: (int){ int }
      tail: (null){ null }
    }
    myList: (struct){
      head: (int){ 2 }
      tail: (struct){
        head: (int){ 3 }
        tail: (struct){
          head: (int){ 4 }
          tail: (null){ null }
        }
      }
    }
  }
  v4: (struct){
    list: (struct){
      head: (int){ int }
      tail: (int){ 1 }
    }
    myList: (struct){
      head: (int){ 2 }
      tail: (struct){
        head: (int){ 3 }
        tail: (int){ 1 }
      }
    }
  }
  v5: (struct){
    list: (struct){
      head: (int){ int }
      tail: (struct){
      }
    }
    myList: (struct){
      head: (int){ 2 }
      tail: (struct){ |((struct){
          head: (int){ 3 }
          tail: (struct){
          }
        }, (struct){
          head: (int){ 3 }
        }) }
    }
  }
  z1: (_|_){
    // [structural cycle]
    y: (struct){
      f: (struct){
        h: (_){ _ }
      }
      g: (_){ _ }
    }
    x: (struct){
      f: (_){ _ }
      g: (_){ _ }
    }
    z: (_|_){
      // [structural cycle]
      f: (_|_){
        // [structural cycle]
        h: (_|_){
          // [structural cycle] z1.z.f.h: structural cycle
        }
      }
      g: (_|_){
        // [structural cycle]
        h: (_|_){
          // [structural cycle] z1.z.g.h: structural cycle
        }
      }
    }
  }
  crossRefNoCycle: (struct){
    t1: (struct){
      T: (struct){
        x: (_){ _ }
        y: (_){ _ }
      }
      C: (struct){
        x: (struct){
          x: (_){ _ }
          y: (_){ _ }
        }
        y: (struct){
          x: (_){ _ }
          y: (_){ _ }
        }
      }
    }
    t2: (struct){
      T: (struct){
        x: (_){ _ }
        y: (_){ _ }
      }
      C: (struct){
        x: (struct){
          x: (_){ _ }
          y: (_){ _ }
        }
        y: (struct){
          x: (_){ _ }
          y: (_){ _ }
        }
      }
    }
    t3: (struct){
      T: (struct){
        x: (_){ _ }
        y: (_){ _ }
        z: (_){ _ }
      }
      C: (struct){
        x: (struct){
          x: (_){ _ }
          y: (_){ _ }
          z: (_){ _ }
        }
        y: (struct){
          x: (_){ _ }
          y: (_){ _ }
          z: (_){ _ }
        }
        z: (struct){
          x: (_){ _ }
          y: (_){ _ }
          z: (_){ _ }
        }
      }
    }
    t4: (struct){
      T: (struct){
        x: (_){ _ }
        y: (_){ _ }
        z: (_){ _ }
      }
      C: (struct){
        x: (struct){
          x: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
          y: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
          z: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
        }
        y: (struct){
          x: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
          y: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
          z: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
        }
        z: (struct){
          x: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
          y: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
          z: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
        }
      }
    }
  }
  n1: (struct){
    a: (struct){
      b: (int){ int }
    }
  }
  n2: (struct){
    a: (struct){
      b: (int){ int }
      a: (struct){
        b: (int){ int }
      }
    }
  }
  n3: (struct){
    a: (struct){
      b: (int){ int }
    }
  }
  n4: (struct){
    a: (struct){
      b: (int){ int }
    }
    x: (struct){
      a: (struct){
        b: (int){ int }
      }
      y: (struct){
        a: (struct){
          b: (int){ int }
        }
        z: (int){ int }
      }
    }
  }
}
-- out/compile --
--- in.cue
{
  a1: {
    f: [
      1;f,
    ]
  }
  a2: {
    f: 0;f
  }
  a3: {
    f: {
      g: 1;f
    }
  }
  a4: {
    a: [
      (1;a|int),
    ]
  }
  a5: {
    a: {
      b: (1;a|int)
    }
  }
  a6: {
    a: (0;a|int)
  }
  a7: {
    a: 0;c.x
    b: {
      x: 1;c
      y: "foo"
    }
    c: {
      x: 1;b.y
      y: 3
    }
  }
  b1: {
    b: (0;a & [
      1,
    ])
    a: [
      (1;a|int),
    ]
  }
  b2: {
    a: [
      (1;a|int),
    ]
    b: (0;a & [
      1,
    ])
  }
  b3: {
    x: {
      a: [
        (1;a|int),
      ]
    }
    b: (0;x & {
      a: [
        1,
      ]
    })
  }
  b4: {
    b: (0;x.y & [
      1,
    ])
    x: {
      y: [
        1;y,
      ]
    }
  }
  b4: {
    cond1: {
      b: (0;x.y & {
        _z: false
        [
          1,
        ]
      })
      x: {
        y: {
          _z: (*true|bool)
          if 0;_z {
            [
              3;y,
            ]
          }
        }
      }
    }
  }
  b4: {
    cond2: {
      x: {
        y: {
          _z: (*true|bool)
          if 0;_z {
            [
              3;y,
            ]
          }
        }
      }
      b: (0;x.y & {
        _z: false
        [
          1,
        ]
      })
    }
  }
  b5: {
    b: (0;x.y & {
      a: [
        1,
      ]
    })
    x: {
      y: {
        a: [
          (1;a|int),
        ]
      }
    }
  }
  b6: {
    b: (0;x & {
      a: [
        1,
      ]
    })
    x: {
      a: [
        1;a,
      ]
    }
  }
  b7: {
    b: (0;a & [
      [
        1,
      ],
    ])
    a: [
      1;a,
    ]
  }
  b8: {
    x: 0;a
    a: {
      f: 1;b
    }
    b: (0;a|string)
  }
  b9: {
    #a: (string|0;#b|0;#ref)
    #b: {
      c: [
        2;#a,
        2;#a,
        2;#a,
      ]
    }
    #ref: {
      ref: string
    }
    x: (0;#b|0;#ref)
  }
  b10: {
    a: close({
      b: (string|1;a|1;c)
    })
    c: close({
      d: (string|1;a)
    })
    d: {
      d: {
        b: string
      }
    }
  }
  b11: {
    #list: {
      tail: (1;#list|*null)
      if (0;tail != null) {}
    }
  }
  b12: {
    #list: {
      value: int
      tail: (1;#list|*null)
      if (0;tail != null) {
        sum: (1;value + 1;tail.sum)
      }
      if (0;tail == null) {
        sum: 1;value
      }
    }
    list1: 0;#list
    list1: {
      value: 1
      tail: {
        value: 2
        tail: {
          value: 3
          tail: {
            value: 4
          }
        }
      }
    }
  }
  b12b: {
    #list: {
      tail: 1;#list
      if (0;tail != null) {
        sum: 1;tail.sum
      }
    }
    list1: 0;#list
    list1: {
      tail: {
        tail: {}
      }
    }
  }
  b13: {
    root: {
      a: [
        for _, x in 2;root {
          1;x
        },
      ]
    }
  }
  b14: {
    root: {
      a: [
        ...int,
      ]
      for _, x in 0;a {
        "\(1;x)": {}
      }
      b: [
        for _, x in 2;root {
          1;x
        },
      ]
    }
  }
  b15: {
    root: {
      a: {
        for _, x in 2;root {
          1;x
        }
      }
    }
  }
  p1: {
    #T: {
      a: {
        [string]: {
          link: 3;#T
        }
      }
    }
    a: (0;#T & {
      a: {
        one: {
          link: {
            a: {
              two: {}
            }
          }
        }
      }
    })
  }
  p2: {
    #T: {
      a: {
        [string]: {
          link: 3;#T
        }
      }
      a: {
        b: {}
      }
    }
    a: (0;#T & {
      a: {
        one: {
          link: {
            a: {
              two: {}
            }
          }
        }
      }
    })
  }
  p3: {
    #S: {
      #T: {
        a: {
          [string]: {
            link: 3;#T
          }
        }
      }
    }
    #U: {
      1;#S
      #T: {
        a: {
          b: {}
        }
      }
    }
    a: (0;#U.#T & {
      a: {
        one: {
          link: {
            a: {
              two: {}
            }
          }
        }
      }
    })
  }
  p4: {
    #T: {
      a: [
        ...{
          link: 3;#T
        },
      ]
    }
    a: (0;#T & {
      a: [
        {
          link: {
            a: [
              {},
            ]
          }
        },
      ]
    })
  }
  p5: {
    #T: {
      a: [
        ...{
          link: 3;#T
        },
      ]
      a: [
        {},
      ]
    }
    a: (0;#T & {
      a: [
        {
          link: {
            a: [
              {},
            ]
          }
        },
      ]
    })
  }
  p6: {
    #S: {
      #T: {
        a: [
          ...{
            link: 3;#T
          },
        ]
      }
    }
    #U: {
      1;#S
      #T: {
        a: [
          {},
        ]
      }
    }
    a: (0;#U.#T & {
      a: [
        {
          link: {
            a: [
              {},
            ]
          }
        },
      ]
    })
  }
  c1: {
    a: {
      b: {}
      c: (1;a & 0;b)
    }
  }
  d1: {
    a: {
      b: {
        c: {
          d: {
            h: int
            t: 4;r
          }
        }
      }
    }
    r: 0;a.b
    x: 0;a.b.c
  }
  d2: {
    x: 0;a.b.c
    r: 0;a.b
    a: {
      b: {
        c: {
          d: {
            h: int
            t: 4;r
          }
        }
      }
    }
  }
  d3: {
    config: {
      a: {
        b: {
          c: 2;indirect
        }
      }
      indirect: [
        1;a.b,
        null,
      ][0;i]
      i: (int|*1)
    }
    x: (0;config & {
      i: 0
    })
  }
  shortPathFail: _
  shortPathFail: {
    doubleRef: {
      a: 0;#List
      #List: {
        Next: (1;#List|*null)
      }
    }
  }
  shortPathFail: {
    elipsis: {
      t1: {
        #Foo: {
          ref: (null|1;#Foo)
        }
        #Foo: {
          ...
        }
      }
      t2: {
        Foo: {
          ref: 1;Foo
        }
        Foo: {
          ...
        }
      }
    }
  }
  patternFail: {
    issue2374: {
      [string]: {
        b: 1;(0;-)
      }
      a: {
        r: 0
      }
    }
  }
  shortPathFail: {
    comprehension: {
      #list: {
        tail: (1;#list|*null)
        if (0;tail != null) {}
      }
    }
  }
  withLetFail: {
    schema: {
      next: 1;let _schema_1#1
    }
    let _schema_1#1 = 0;schema
  }
  fieldsSumInfinite: {
    issue3310: {
      cheeseburger: 3.00
      fries: 2.00
      sprite: 1.00
      total: import;list.Sum([
        for _, v in 2;issue3310 {
          1;v
        },
      ])
    }
  }
  listOptOK: {
    list: {
      head: int
      tail?: 1;list
    }
    a: (0;list & {
      head: 3
      tail: {
        head: 2
      }
    })
  }
  e1: {
    a: 0;a
    a: {
      c: 1;a
    }
    b: {
      c: 1;b
    }
    b: 0;b
  }
  e2: {
    a: {
      1;a
    }
    a: {
      c: 1;a
    }
    b: {
      c: 1;b
    }
    b: {
      1;b
    }
  }
  e3: {
    a: [
      1;a,
    ]
    a: {
      c: 1;a
    }
    b: [
      1;b,
    ]
    b: {
      c: 1;b
    }
  }
  e4: {
    a: [
      (1;a|{}),
    ]
    a: [
      [
        {
          c: 1
        },
      ],
    ]
    b: [
      [
        {
          c: 1
        },
      ],
    ]
    b: [
      (1;b|{}),
    ]
  }
  e5: {
    a: {
      c: (1;a|int)
    }
    a: (0;a|int)
    b: (0;b|int)
    b: {
      c: (1;b|int)
    }
  }
  nestedList: {
    v1e: {
      x: [
        (1;x|int),
        1,
      ]
      y: (0;x & [
        [
          [
            2,
          ],
          1,
        ],
        1,
      ])
    }
    v2e: {
      y: (0;x & [
        [
          [
            2,
          ],
          1,
        ],
        1,
      ])
      x: [
        (1;x|int),
        1,
      ]
    }
    v1: {
      x: [
        (1;x|int),
        1,
      ]
      y: (0;x & [
        [
          [
            2,
            1,
          ],
          1,
        ],
        1,
      ])
    }
    v2: {
      y: (0;x & [
        [
          [
            2,
            1,
          ],
          1,
        ],
        1,
      ])
      x: [
        (1;x|int),
        1,
      ]
    }
  }
  v3: {
    list: {
      head: int
      tail: (1;list|null)
    }
    myList: 0;list
    myList: {
      head: 2
      tail: {
        head: 3
        tail: {
          head: 4
        }
      }
    }
  }
  v4: {
    list: {
      head: int
      tail: (1;list|1)
    }
    myList: 0;list
    myList: {
      head: 2
      tail: {
        head: 3
      }
    }
  }
  v5: {
    list: {
      head: int
      tail: (1;list|{})
    }
    myList: 0;list
    myList: {
      head: 2
      tail: {
        head: 3
      }
    }
  }
  z1: {
    y: {
      f: {
        h: 1;g
      }
      g: _
    }
    x: {
      f: _
      g: 0;f
    }
    z: (0;x & 0;y)
  }
  crossRefNoCycle: {
    t1: {
      T: {
        x: _
        y: 0;x
      }
      C: ({
        x: 1;T
      } & 0;T)
    }
  }
  crossRefNoCycle: {
    t2: {
      T: {
        x: _
        y: 0;x
      }
      C: (0;T & {
        x: 1;T
      })
    }
  }
  crossRefNoCycle: {
    t3: {
      T: {
        x: _
        y: 0;x
        z: 0;y
      }
      C: (0;T & {
        x: 1;T
      })
    }
  }
  crossRefNoCycle: {
    t4: {
      T: {
        x: _
        y: 0;x
        z: 0;y
      }
      C: (0;T & {
        x: (1;T & {
          x: 2;T
        })
      })
    }
  }
  n1: {
    a: {
      b: int
    }
  }
  n2: (0;n1 & {
    a: 1;n1
  })
  n3: (0;n1 & {
    1;n1
  })
  n4: (0;n1 & {
    x: (1;n1 & {
      y: (2;n1 & {
        z: int
      })
    })
  })
}
