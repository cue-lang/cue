-- in.cue --
a1: {
	f: [f]
}

a2: {
	f: f
}

a3: {
	f: {g: f}
}

a4: {
	a: [a | int]
}

a5: {
	a: b: a | int
}

a6: {
	a: a | int
}

a7: {
	a: c.x
	b: {
		x: c
		y: "foo"
	}
	c: {
		x: b.y
		y: 3
	}
}

b1: {
	b: a & [1]
	a: [a | int]
}

b2: {
	a: [a | int]
	b: a & [1]
}

b3: {
	x: a: [a | int]
	b: x & {a: [1]}
}

b4: {
	b: x.y & [1]
	x: y: [y]
}

b5: {
	b: x.y & {a: [1]}
	x: y: a: [a | int]
}

b6: {
	b: x & {a: [1]}
	x: a: [a]
}

b7: {
	b: a & [[1]]
	a: [a]
}

// Issue #555
b8: {
	x: a
	a: f: b
	b: a | string
}

// Issue #555
b9: {
	#a: string | #b | #ref
	#b: {
		c: [#a, #a, #a]
	}
	#ref: ref: string
	x: #b | #ref
}

// Issue #534
b10: {
	a: close({
		b: string | a | c
	})
	c: close({
		d: string | a
	})
}

// Issue #509 -- with comprehension
b11: {
	#list: {
		tail: #list | *null
		if tail != null {
		}
	}
}

// Issue #509 -- with comprehension
b12: {
	#list: {
		V=value: int
		T=tail:  #list | *null
		if T != null {
			sum: V + T.sum
		}
		if T == null {
			sum: V
		}
	}

	list1: #list
	list1: {
		value: 1
		tail: {
			value: 2
			tail: {
				value: 3
				tail: {
					value: 4
				}
			}
		}
	}
}

// More trigger happy on stack overflows.
b12b: {
	#list: {
		tail: #list

		if tail != null {
			sum: tail.sum
		}
	}

	list1: #list
	list1: {
		tail: {
			tail: {
			}
		}
	}
}

// Issue #587
b13: root: a: [ for x in root {x}]

// Issue #587
b14: {
	root: {
		a: [...int]

		for x in a {
			"\(x)": {}
		}

		b: [ for x in root {x}]
	}
}

// This is okay
// Issue #587
b15: root: a: {for x in root {x}}

// Issue #502 -- unused bulk constraints are not cyclic
p1: {
	#T: {
		a: [string]: link: #T
	}

	a: #T & {
		a: one: link: a: two: {}
	}
}

// Issue #502 -- but they are if it is invoked within the struct.
p2: {
	#T: {
		a: [string]: link: #T
		a: b: {}
	}

	a: #T & {
		a: one: link: a: two: {}
	}
}

// Issue #502 -- or added later.
p3: {
	#S: #T: {
		a: [string]: link: #T
	}

	#U: {
		#S
		#T: a: b: {}
	}

	a: #U.#T & {
		a: one: link: a: two: {}
	}
}

// Issue #502 -- unused bulk constraints are not cyclic
p4: {
	#T: {
		a: [...{link: #T}]
	}

	a: #T & {
		a: [{link: a: [{}]}]
	}
}

// Issue #502 -- but they are if it is invoked within the struct.
p5: {
	#T: {
		a: [...{link: #T}]
		a: [{}]
	}

	a: #T & {
		a: [{link: a: [{}]}]
	}
}

// Issue #502 -- or added later.
p6: {
	#S: #T: {
		a: [...{link: #T}]
	}

	#U: {
		#S
		#T: a: [{}]
	}

	a: #U.#T & {
		a: [{link: a: [{}]}]
	}
}

c1: {
	a: {
		b: {}
		c: a & b
	}
}

// indirection
d1: {
	a: b: c: d: {h: int, t: r}
	r: a.b

	x: a.b.c
}

d2: {
	x: a.b.c

	r: a.b
	a: b: c: d: {h: int, t: r}
}

d3: {
	config: {
		a: b: c: indirect
		indirect: [a.b, null][i]
		i:        int | *1
	}
	x: config & {i: 0}
}

// combining structural with reference cycles
e1: {
	a: a
	a: c: a

	b: c: b
	b: b
}

e2: {
	a: {a}
	a: c: a

	b: c: b
	b: {b}
}

e3: {
	a: [a]
	a: c: a

	b: [b]
	b: c: b
}

e4: {
	a: [a | {}]
	a: [[{c: 1}]]

	b: [[{c: 1}]]
	b: [b | {}]
}

e5: {
	a: c: a | int
	a: a | int

	b: b | int
	b: c: b | int
}

// validating values
nestedList: {
	v1e: {
		x: [x | int, 1]
		y: x & [[[2], 1], 1]
	}

	v2e: {
		y: x & [[[2], 1], 1]
		x: [x | int, 1]
	}

	v1: {
		x: [x | int, 1]
		y: x & [[[2, 1], 1], 1]
	}

	v2: {
		y: x & [[[2, 1], 1], 1]
		x: [x | int, 1]
	}
}

v3: {
	list: {
		head: int
		tail: list | null
	}

	myList: list
	myList: {
		head: 2
		tail: {
			head: 3
			tail: {
				head: 4
			}
		}
	}
}

v4: {
	list: {
		head: int
		tail: list | 1
	}

	myList: list
	myList: {
		head: 2
		tail: head: 3
	}
}

v5: {
	list: {
		head: int
		tail: list | {}
	}

	myList: list
	myList: {
		head: 2
		tail: head: 3
	}
}

// Example from "The Logic of Type Feature Structures" (Bob Carpenter)/
z1: {
	y: {
		f: h: g
		g: _
	}
	x: {
		f: _
		g: f
	}
	z: x & y
}

// Ensure these are NOT treated as structural errors.

n1: a: b: int
n2: n1 & {a: n1}
n3: n1 & {n1}
n4: n1 & {x: n1 & {y: n1 & {z: int}}}
-- out/eval --
Errors:
a1.f.0: structural cycle
a3.f.g: structural cycle
b12b.#list.tail.tail: structural cycle
b13.root.a.0.0: structural cycle
b14.root.b.1.1: structural cycle
b4.b.0: conflicting values 1 and [y] (mismatched types int and list):
    ./in.cue:53:5
    ./in.cue:53:12
    ./in.cue:54:8
    ./in.cue:54:9
b4.b.0.0: structural cycle
b4.x.y.0: structural cycle
b6.b.a.0: conflicting values 1 and [1] (mismatched types int and list):
    ./in.cue:63:5
    ./in.cue:63:13
    ./in.cue:63:14
    ./in.cue:64:9
b6.b.a.0.0: conflicting values 1 and [1] (mismatched types int and list):
    ./in.cue:63:5
    ./in.cue:63:13
    ./in.cue:63:14
    ./in.cue:64:9
b6.b.a.0.0: structural cycle
b6.x.a.0: structural cycle
b7.a.0: structural cycle
b7.b.0.0: conflicting values 1 and [a] (mismatched types int and list):
    ./in.cue:68:5
    ./in.cue:68:11
    ./in.cue:69:5
    ./in.cue:69:6
b7.b.0.0.0: structural cycle
c1.a.c.c: structural cycle
d1.a.b.c.d.t: structural cycle
d1.r: structural cycle
d2.r.c.d.t: structural cycle
d2.x.d.t.c.d.t: structural cycle
e1.a.c: structural cycle
e1.b.c: structural cycle
e2.a.c: structural cycle
e2.b.c: structural cycle
e3.a: conflicting values [a] and {c:a} (mismatched types list and struct):
    ./in.cue:302:5
    ./in.cue:303:5
e3.a.0: conflicting values [a] and {c:a} (mismatched types list and struct):
    ./in.cue:302:5
    ./in.cue:302:6
    ./in.cue:303:5
e3.a.0: structural cycle
e3.a.c: conflicting values [a] and {c:a} (mismatched types list and struct):
    ./in.cue:302:5
    ./in.cue:303:5
    ./in.cue:303:8
e3.a.c: structural cycle
e3.b: conflicting values [b] and {c:b} (mismatched types list and struct):
    ./in.cue:305:5
    ./in.cue:306:5
e3.b.0: conflicting values [b] and {c:b} (mismatched types list and struct):
    ./in.cue:305:5
    ./in.cue:305:6
    ./in.cue:306:5
e3.b.0: structural cycle
e3.b.c: conflicting values [b] and {c:b} (mismatched types list and struct):
    ./in.cue:305:5
    ./in.cue:306:5
    ./in.cue:306:8
e3.b.c: structural cycle
e4.a.0: 4 errors in empty disjunction:
e4.a.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:310:10
    ./in.cue:311:6
e4.a.0.0: 2 errors in empty disjunction:
e4.a.0.0: conflicting values [[{c:1}]] and {c:1} (mismatched types list and struct):
    ./in.cue:311:5
    ./in.cue:311:7
e4.a.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:310:6
    ./in.cue:310:10
    ./in.cue:311:6
e4.b.0: 4 errors in empty disjunction:
e4.b.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:313:6
    ./in.cue:314:10
e4.b.0.0: 2 errors in empty disjunction:
e4.b.0.0: conflicting values [(b|{})] and {c:1} (mismatched types list and struct):
    ./in.cue:313:7
    ./in.cue:314:5
e4.b.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:313:6
    ./in.cue:314:6
    ./in.cue:314:10
nestedList.v1e.y.0: 4 errors in empty disjunction:
nestedList.v1e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
    ./in.cue:328:11
    ./in.cue:329:11
nestedList.v1e.y.0.0: 2 errors in empty disjunction:
nestedList.v1e.y.0.0: conflicting values int and [2] (mismatched types int and list):
    ./in.cue:328:11
    ./in.cue:329:12
nestedList.v1e.y.0.0: incompatible list lengths (1 and 2)
nestedList.v2e.y.0: 4 errors in empty disjunction:
nestedList.v2e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
    ./in.cue:333:11
    ./in.cue:334:11
nestedList.v2e.y.0.0: 2 errors in empty disjunction:
nestedList.v2e.y.0.0: conflicting values int and [2] (mismatched types int and list):
    ./in.cue:333:12
    ./in.cue:334:11
nestedList.v2e.y.0.0: incompatible list lengths (1 and 2)
p2.#T.a.b.link: structural cycle
p3.#U.#T.a.b.link: structural cycle
p5.#T.a.0.link: structural cycle
p6.#U.#T.a.0.link: structural cycle
z1.z.f.h.h: structural cycle
z1.z.g.h: structural cycle
cycle error:
    ./in.cue:141:6
d3.config.0: structural cycle:
    ./in.cue:278:13

Result:
(_|_){
  // [eval]
  a1: (_|_){
    // [structural cycle]
    f: (_|_){
      // [structural cycle]
      0: (_|_){
        // [structural cycle] a1.f.0: structural cycle
      }
    }
  }
  a2: (struct){
    f: (_){ _ }
  }
  a3: (_|_){
    // [structural cycle]
    f: (_|_){
      // [structural cycle]
      g: (_|_){
        // [structural cycle] a3.f.g: structural cycle
      }
    }
  }
  a4: (struct){
    a: (#list){
      0: (int){ int }
    }
  }
  a5: (struct){
    a: (struct){
      b: (int){ int }
    }
  }
  a6: (struct){
    a: (_){ |((_){ _ }, (int){ int }) }
  }
  a7: (struct){
    a: (string){ "foo" }
    b: (struct){
      x: (struct){
        x: (string){ "foo" }
        y: (int){ 3 }
      }
      y: (string){ "foo" }
    }
    c: (struct){
      x: (string){ "foo" }
      y: (int){ 3 }
    }
  }
  b1: (struct){
    b: (#list){
      0: (int){ 1 }
    }
    a: (#list){
      0: (int){ int }
    }
  }
  b2: (struct){
    a: (#list){
      0: (int){ int }
    }
    b: (#list){
      0: (int){ 1 }
    }
  }
  b3: (struct){
    x: (struct){
      a: (#list){
        0: (int){ int }
      }
    }
    b: (struct){
      a: (#list){
        0: (int){ 1 }
      }
    }
  }
  b4: (_|_){
    // [eval]
    b: (_|_){
      // [eval]
      0: (_|_){
        // [eval] b4.b.0: conflicting values 1 and [y] (mismatched types int and list):
        //     ./in.cue:53:5
        //     ./in.cue:53:12
        //     ./in.cue:54:8
        //     ./in.cue:54:9
        0: (_|_){
          // [structural cycle] b4.b.0.0: structural cycle
        }
      }
    }
    x: (_|_){
      // [structural cycle]
      y: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle] b4.x.y.0: structural cycle
        }
      }
    }
  }
  b5: (struct){
    b: (struct){
      a: (#list){
        0: (int){ 1 }
      }
    }
    x: (struct){
      y: (struct){
        a: (#list){
          0: (int){ int }
        }
      }
    }
  }
  b6: (_|_){
    // [eval]
    b: (_|_){
      // [eval]
      a: (_|_){
        // [eval]
        0: (_|_){
          // [eval] b6.b.a.0: conflicting values 1 and [1] (mismatched types int and list):
          //     ./in.cue:63:5
          //     ./in.cue:63:13
          //     ./in.cue:63:14
          //     ./in.cue:64:9
          0: (_|_){
            // [eval] b6.b.a.0.0: conflicting values 1 and [1] (mismatched types int and list):
            //     ./in.cue:63:5
            //     ./in.cue:63:13
            //     ./in.cue:63:14
            //     ./in.cue:64:9
            // b6.b.a.0.0: structural cycle
          }
        }
      }
    }
    x: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle] b6.x.a.0: structural cycle
        }
      }
    }
  }
  b7: (_|_){
    // [eval]
    b: (_|_){
      // [eval]
      0: (_|_){
        // [eval]
        0: (_|_){
          // [eval] b7.b.0.0: conflicting values 1 and [a] (mismatched types int and list):
          //     ./in.cue:68:5
          //     ./in.cue:68:11
          //     ./in.cue:69:5
          //     ./in.cue:69:6
          0: (_|_){
            // [structural cycle] b7.b.0.0.0: structural cycle
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle]
      0: (_|_){
        // [structural cycle] b7.a.0: structural cycle
      }
    }
  }
  b8: (struct){
    x: (struct){
      f: (string){ string }
    }
    a: (struct){
      f: (string){ string }
    }
    b: (string){ string }
  }
  b9: (struct){
    #a: ((string|struct)){ |((string){ string }, (#struct){
        ref: (string){ string }
      }) }
    #b: (#struct){
      c: (#list){
        0: ((string|struct)){ |((string){ string }, (#struct){
            ref: (string){ string }
          }) }
        1: ((string|struct)){ |((string){ string }, (#struct){
            ref: (string){ string }
          }) }
        2: ((string|struct)){ |((string){ string }, (#struct){
            ref: (string){ string }
          }) }
      }
    }
    #ref: (#struct){
      ref: (string){ string }
    }
    x: (#struct){ |((#struct){
        c: (#list){
          0: ((string|struct)){ |((string){ string }, (#struct){
              ref: (string){ string }
            }) }
          1: ((string|struct)){ |((string){ string }, (#struct){
              ref: (string){ string }
            }) }
          2: ((string|struct)){ |((string){ string }, (#struct){
              ref: (string){ string }
            }) }
        }
      }, (#struct){
        ref: (string){ string }
      }) }
  }
  b10: (struct){
    a: (#struct){
      b: ((string|struct)){ |((string){ string }, (#struct){
          d: (string){ string }
        }) }
    }
    c: (#struct){
      d: ((string|struct)){ |((string){ string }, (#struct){
          b: (string){ string }
        }) }
    }
  }
  b11: (struct){
    #list: (#struct){
      tail: ((null|struct)){ |(*(null){ null }, (#struct){
          tail: (null){ null }
        }) }
    }
  }
  b12: (struct){
    #list: (#struct){
      value: (int){ int }
      tail: ((null|struct)){ |(*(null){ null }, (#struct){
          value: (int){ int }
          tail: (null){ null }
          sum: (int){ int }
        }) }
      sum: (int){ int }
    }
    list1: (#struct){
      value: (int){ 1 }
      tail: (#struct){
        value: (int){ 2 }
        tail: (#struct){
          value: (int){ 3 }
          tail: (#struct){
            value: (int){ 4 }
            tail: (null){ null }
            sum: (int){ 4 }
          }
          sum: (int){ 7 }
        }
        sum: (int){ 9 }
      }
      sum: (int){ 10 }
    }
  }
  b12b: (_|_){
    // [structural cycle]
    #list: (_|_){
      // [structural cycle] cycle error:
      //     ./in.cue:141:6
      tail: (_|_){
        // [structural cycle] cycle error:
        //     ./in.cue:141:6
        tail: (_|_){
          // [structural cycle] b12b.#list.tail.tail: structural cycle
        }
      }
    }
    list1: (_|_){
      // [structural cycle] cycle error:
      //     ./in.cue:141:6
      tail: (struct){
        tail: (struct){
        }
      }
    }
  }
  b13: (_|_){
    // [structural cycle]
    root: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle]
          0: (_|_){
            // [structural cycle] b13.root.a.0.0: structural cycle
          }
        }
      }
    }
  }
  b14: (_|_){
    // [structural cycle]
    root: (_|_){
      // [structural cycle]
      a: (list){
      }
      b: (_|_){
        // [structural cycle]
        0: (list){
        }
        1: (_|_){
          // [structural cycle]
          0: (list){
          }
          1: (_|_){
            // [structural cycle] b14.root.b.1.1: structural cycle
          }
        }
      }
    }
  }
  b15: (struct){
    root: (struct){
      a: (struct){
      }
    }
  }
  p1: (struct){
    #T: (#struct){
      a: (#struct){
      }
    }
    a: (#struct){
      a: (#struct){
        one: (#struct){
          link: (#struct){
            a: (#struct){
              two: (#struct){
                link: (#struct){
                  a: (#struct){
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  p2: (_|_){
    // [structural cycle]
    #T: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        b: (_|_){
          // [structural cycle]
          link: (_|_){
            // [structural cycle] p2.#T.a.b.link: structural cycle
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle]
      a: (struct){
        one: (struct){
          link: (struct){
            a: (struct){
              two: (struct){
              }
            }
          }
        }
      }
    }
  }
  p3: (_|_){
    // [structural cycle]
    #S: (#struct){
      #T: (#struct){
        a: (#struct){
        }
      }
    }
    #U: (_|_){
      // [structural cycle]
      #T: (_|_){
        // [structural cycle]
        a: (_|_){
          // [structural cycle]
          b: (_|_){
            // [structural cycle]
            link: (_|_){
              // [structural cycle] p3.#U.#T.a.b.link: structural cycle
            }
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle] p3.#U.#T.a.b.link: structural cycle
      a: (struct){
        one: (struct){
          link: (struct){
            a: (struct){
              two: (struct){
              }
            }
          }
        }
      }
    }
  }
  p4: (struct){
    #T: (#struct){
      a: (list){
      }
    }
    a: (#struct){
      a: (#list){
        0: (#struct){
          link: (#struct){
            a: (#list){
              0: (#struct){
                link: (#struct){
                  a: (list){
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  p5: (_|_){
    // [structural cycle]
    #T: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle]
          link: (_|_){
            // [structural cycle] p5.#T.a.0.link: structural cycle
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle]
      a: (#list){
        0: (struct){
          link: (struct){
            a: (#list){
              0: (struct){
              }
            }
          }
        }
      }
    }
  }
  p6: (_|_){
    // [structural cycle]
    #S: (#struct){
      #T: (#struct){
        a: (list){
        }
      }
    }
    #U: (_|_){
      // [structural cycle]
      #T: (_|_){
        // [structural cycle]
        a: (_|_){
          // [structural cycle]
          0: (_|_){
            // [structural cycle]
            link: (_|_){
              // [structural cycle] p6.#U.#T.a.0.link: structural cycle
            }
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle] p6.#U.#T.a.0.link: structural cycle
      a: (#list){
        0: (struct){
          link: (struct){
            a: (#list){
              0: (struct){
              }
            }
          }
        }
      }
    }
  }
  c1: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      b: (struct){
      }
      c: (_|_){
        // [structural cycle]
        b: (struct){
        }
        c: (_|_){
          // [structural cycle] c1.a.c.c: structural cycle
        }
      }
    }
  }
  d1: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      b: (_|_){
        // [structural cycle]
        c: (_|_){
          // [structural cycle]
          d: (_|_){
            // [structural cycle]
            h: (int){ int }
            t: (_|_){
              // [structural cycle] d1.a.b.c.d.t: structural cycle
            }
          }
        }
      }
    }
    r: (_|_){
      // [structural cycle] d1.r: structural cycle
    }
    x: (_|_){
      // [structural cycle] d1.a.b.c.d.t: structural cycle
    }
  }
  d2: (_|_){
    // [structural cycle]
    x: (_|_){
      // [structural cycle]
      d: (_|_){
        // [structural cycle]
        h: (int){ int }
        t: (_|_){
          // [structural cycle]
          c: (_|_){
            // [structural cycle]
            d: (_|_){
              // [structural cycle]
              h: (int){ int }
              t: (_|_){
                // [structural cycle] d2.x.d.t.c.d.t: structural cycle
              }
            }
          }
        }
      }
    }
    r: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle]
        d: (_|_){
          // [structural cycle]
          h: (int){ int }
          t: (_|_){
            // [structural cycle] d2.r.c.d.t: structural cycle
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle]
      b: (_|_){
        // [structural cycle]
        c: (_|_){
          // [structural cycle]
          d: (_|_){
            // [structural cycle]
            h: (int){ int }
            t: (_|_){
              // [structural cycle]
            }
          }
        }
      }
    }
  }
  d3: (_|_){
    // [structural cycle]
    config: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        b: (_|_){
          // [structural cycle]
          c: (_|_){
            // [structural cycle] d3.config.0: structural cycle:
            //     ./in.cue:278:13
          }
        }
      }
      indirect: (_|_){
        // [structural cycle] d3.config.0: structural cycle:
        //     ./in.cue:278:13
      }
      i: (int){ |(*(int){ 1 }, (int){ int }) }
    }
    x: (_|_){
      // [structural cycle] d3.config.0: structural cycle:
      //     ./in.cue:278:13
      i: (int){ 0 }
    }
  }
  e1: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e1.a.c: structural cycle
      }
    }
    b: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e1.b.c: structural cycle
      }
    }
  }
  e2: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e2.a.c: structural cycle
      }
    }
    b: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e2.b.c: structural cycle
      }
    }
  }
  e3: (_|_){
    // [eval]
    a: (_|_){
      // [eval] e3.a: conflicting values [a] and {c:a} (mismatched types list and struct):
      //     ./in.cue:302:5
      //     ./in.cue:303:5
      c: (_|_){
        // [eval] e3.a.c: conflicting values [a] and {c:a} (mismatched types list and struct):
        //     ./in.cue:302:5
        //     ./in.cue:303:5
        //     ./in.cue:303:8
        // e3.a.c: structural cycle
      }
      0: (_|_){
        // [eval] e3.a.0: conflicting values [a] and {c:a} (mismatched types list and struct):
        //     ./in.cue:302:5
        //     ./in.cue:302:6
        //     ./in.cue:303:5
        // e3.a.0: structural cycle
      }
    }
    b: (_|_){
      // [eval] e3.b: conflicting values [b] and {c:b} (mismatched types list and struct):
      //     ./in.cue:305:5
      //     ./in.cue:306:5
      c: (_|_){
        // [eval] e3.b.c: conflicting values [b] and {c:b} (mismatched types list and struct):
        //     ./in.cue:305:5
        //     ./in.cue:306:5
        //     ./in.cue:306:8
        // e3.b.c: structural cycle
      }
      0: (_|_){
        // [eval] e3.b.0: conflicting values [b] and {c:b} (mismatched types list and struct):
        //     ./in.cue:305:5
        //     ./in.cue:305:6
        //     ./in.cue:306:5
        // e3.b.0: structural cycle
      }
    }
  }
  e4: (_|_){
    // [eval]
    a: (_|_){
      // [eval]
      0: (_|_){
        // [eval] e4.a.0: 4 errors in empty disjunction:
        // e4.a.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:310:10
        //     ./in.cue:311:6
        // e4.a.0.0: 2 errors in empty disjunction:
        // e4.a.0.0: conflicting values [[{c:1}]] and {c:1} (mismatched types list and struct):
        //     ./in.cue:311:5
        //     ./in.cue:311:7
        // e4.a.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:310:6
        //     ./in.cue:310:10
        //     ./in.cue:311:6
        0: (struct){
          c: (int){ 1 }
        }
      }
    }
    b: (_|_){
      // [eval]
      0: (_|_){
        // [eval] e4.b.0: 4 errors in empty disjunction:
        // e4.b.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:313:6
        //     ./in.cue:314:10
        // e4.b.0.0: 2 errors in empty disjunction:
        // e4.b.0.0: conflicting values [(b|{})] and {c:1} (mismatched types list and struct):
        //     ./in.cue:313:7
        //     ./in.cue:314:5
        // e4.b.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:313:6
        //     ./in.cue:314:6
        //     ./in.cue:314:10
        0: (struct){
          c: (int){ 1 }
        }
      }
    }
  }
  e5: (struct){
    a: (struct){
      c: (int){ int }
    }
    b: (struct){
      c: (int){ int }
    }
  }
  nestedList: (_|_){
    // [eval]
    v1e: (_|_){
      // [eval]
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
      y: (_|_){
        // [eval]
        0: (_|_){
          // [eval] nestedList.v1e.y.0: 4 errors in empty disjunction:
          // nestedList.v1e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
          //     ./in.cue:328:11
          //     ./in.cue:329:11
          // nestedList.v1e.y.0.0: 2 errors in empty disjunction:
          // nestedList.v1e.y.0.0: conflicting values int and [2] (mismatched types int and list):
          //     ./in.cue:328:11
          //     ./in.cue:329:12
          // nestedList.v1e.y.0.0: incompatible list lengths (1 and 2)
          0: (#list){
            0: (int){ 2 }
          }
          1: (int){ 1 }
        }
        1: (int){ 1 }
      }
    }
    v2e: (_|_){
      // [eval]
      y: (_|_){
        // [eval]
        0: (_|_){
          // [eval] nestedList.v2e.y.0: 4 errors in empty disjunction:
          // nestedList.v2e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
          //     ./in.cue:333:11
          //     ./in.cue:334:11
          // nestedList.v2e.y.0.0: 2 errors in empty disjunction:
          // nestedList.v2e.y.0.0: conflicting values int and [2] (mismatched types int and list):
          //     ./in.cue:333:12
          //     ./in.cue:334:11
          // nestedList.v2e.y.0.0: incompatible list lengths (1 and 2)
          0: (#list){
            0: (int){ 2 }
          }
          1: (int){ 1 }
        }
        1: (int){ 1 }
      }
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
    }
    v1: (struct){
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
      y: (#list){
        0: (#list){
          0: (#list){
            0: (int){ 2 }
            1: (int){ 1 }
          }
          1: (int){ 1 }
        }
        1: (int){ 1 }
      }
    }
    v2: (struct){
      y: (#list){
        0: (#list){
          0: (#list){
            0: (int){ 2 }
            1: (int){ 1 }
          }
          1: (int){ 1 }
        }
        1: (int){ 1 }
      }
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
    }
  }
  v3: (struct){
    list: (struct){
      head: (int){ int }
      tail: (null){ null }
    }
    myList: (struct){
      head: (int){ 2 }
      tail: (struct){
        head: (int){ 3 }
        tail: (struct){
          head: (int){ 4 }
          tail: (null){ null }
        }
      }
    }
  }
  v4: (struct){
    list: (struct){
      head: (int){ int }
      tail: (int){ 1 }
    }
    myList: (struct){
      head: (int){ 2 }
      tail: (struct){
        head: (int){ 3 }
        tail: (int){ 1 }
      }
    }
  }
  v5: (struct){
    list: (struct){
      head: (int){ int }
      tail: (struct){
      }
    }
    myList: (struct){
      head: (int){ 2 }
      tail: (struct){ |((struct){
          head: (int){ 3 }
          tail: (struct){
          }
        }, (struct){
          head: (int){ 3 }
        }) }
    }
  }
  z1: (_|_){
    // [structural cycle]
    y: (struct){
      f: (struct){
        h: (_){ _ }
      }
      g: (_){ _ }
    }
    x: (struct){
      f: (_){ _ }
      g: (_){ _ }
    }
    z: (_|_){
      // [structural cycle]
      f: (_|_){
        // [structural cycle]
        h: (_|_){
          // [structural cycle]
          h: (_|_){
            // [structural cycle] z1.z.f.h.h: structural cycle
          }
        }
      }
      g: (_|_){
        // [structural cycle]
        h: (_|_){
          // [structural cycle] z1.z.g.h: structural cycle
        }
      }
    }
  }
  n1: (struct){
    a: (struct){
      b: (int){ int }
    }
  }
  n2: (struct){
    a: (struct){
      b: (int){ int }
      a: (struct){
        b: (int){ int }
      }
    }
  }
  n3: (struct){
    a: (struct){
      b: (int){ int }
    }
  }
  n4: (struct){
    a: (struct){
      b: (int){ int }
    }
    x: (struct){
      a: (struct){
        b: (int){ int }
      }
      y: (struct){
        a: (struct){
          b: (int){ int }
        }
        z: (int){ int }
      }
    }
  }
}
-- out/compile --
--- in.cue
{
  a1: {
    f: [
      〈1;f〉,
    ]
  }
  a2: {
    f: 〈0;f〉
  }
  a3: {
    f: {
      g: 〈1;f〉
    }
  }
  a4: {
    a: [
      (〈1;a〉|int),
    ]
  }
  a5: {
    a: {
      b: (〈1;a〉|int)
    }
  }
  a6: {
    a: (〈0;a〉|int)
  }
  a7: {
    a: 〈0;c〉.x
    b: {
      x: 〈1;c〉
      y: "foo"
    }
    c: {
      x: 〈1;b〉.y
      y: 3
    }
  }
  b1: {
    b: (〈0;a〉 & [
      1,
    ])
    a: [
      (〈1;a〉|int),
    ]
  }
  b2: {
    a: [
      (〈1;a〉|int),
    ]
    b: (〈0;a〉 & [
      1,
    ])
  }
  b3: {
    x: {
      a: [
        (〈1;a〉|int),
      ]
    }
    b: (〈0;x〉 & {
      a: [
        1,
      ]
    })
  }
  b4: {
    b: (〈0;x〉.y & [
      1,
    ])
    x: {
      y: [
        〈1;y〉,
      ]
    }
  }
  b5: {
    b: (〈0;x〉.y & {
      a: [
        1,
      ]
    })
    x: {
      y: {
        a: [
          (〈1;a〉|int),
        ]
      }
    }
  }
  b6: {
    b: (〈0;x〉 & {
      a: [
        1,
      ]
    })
    x: {
      a: [
        〈1;a〉,
      ]
    }
  }
  b7: {
    b: (〈0;a〉 & [
      [
        1,
      ],
    ])
    a: [
      〈1;a〉,
    ]
  }
  b8: {
    x: 〈0;a〉
    a: {
      f: 〈1;b〉
    }
    b: (〈0;a〉|string)
  }
  b9: {
    #a: (string|〈0;#b〉|〈0;#ref〉)
    #b: {
      c: [
        〈2;#a〉,
        〈2;#a〉,
        〈2;#a〉,
      ]
    }
    #ref: {
      ref: string
    }
    x: (〈0;#b〉|〈0;#ref〉)
  }
  b10: {
    a: close({
      b: (string|〈1;a〉|〈1;c〉)
    })
    c: close({
      d: (string|〈1;a〉)
    })
  }
  b11: {
    #list: {
      tail: (〈1;#list〉|*null)
      if (〈0;tail〉 != null) {}
    }
  }
  b12: {
    #list: {
      value: int
      tail: (〈1;#list〉|*null)
      if (〈0;tail〉 != null) {
        sum: (〈1;value〉 + 〈1;tail〉.sum)
      }
      if (〈0;tail〉 == null) {
        sum: 〈1;value〉
      }
    }
    list1: 〈0;#list〉
    list1: {
      value: 1
      tail: {
        value: 2
        tail: {
          value: 3
          tail: {
            value: 4
          }
        }
      }
    }
  }
  b12b: {
    #list: {
      tail: 〈1;#list〉
      if (〈0;tail〉 != null) {
        sum: 〈1;tail〉.sum
      }
    }
    list1: 〈0;#list〉
    list1: {
      tail: {
        tail: {}
      }
    }
  }
  b13: {
    root: {
      a: [
        for _, x in 〈2;root〉 {
          〈1;x〉
        },
      ]
    }
  }
  b14: {
    root: {
      a: [
        ...int,
      ]
      for _, x in 〈0;a〉 {
        "\(〈1;x〉)": {}
      }
      b: [
        for _, x in 〈2;root〉 {
          〈1;x〉
        },
      ]
    }
  }
  b15: {
    root: {
      a: {
        for _, x in 〈2;root〉 {
          〈1;x〉
        }
      }
    }
  }
  p1: {
    #T: {
      a: {
        [string]: {
          link: 〈3;#T〉
        }
      }
    }
    a: (〈0;#T〉 & {
      a: {
        one: {
          link: {
            a: {
              two: {}
            }
          }
        }
      }
    })
  }
  p2: {
    #T: {
      a: {
        [string]: {
          link: 〈3;#T〉
        }
      }
      a: {
        b: {}
      }
    }
    a: (〈0;#T〉 & {
      a: {
        one: {
          link: {
            a: {
              two: {}
            }
          }
        }
      }
    })
  }
  p3: {
    #S: {
      #T: {
        a: {
          [string]: {
            link: 〈3;#T〉
          }
        }
      }
    }
    #U: {
      〈1;#S〉
      #T: {
        a: {
          b: {}
        }
      }
    }
    a: (〈0;#U〉.#T & {
      a: {
        one: {
          link: {
            a: {
              two: {}
            }
          }
        }
      }
    })
  }
  p4: {
    #T: {
      a: [
        ...{
          link: 〈3;#T〉
        },
      ]
    }
    a: (〈0;#T〉 & {
      a: [
        {
          link: {
            a: [
              {},
            ]
          }
        },
      ]
    })
  }
  p5: {
    #T: {
      a: [
        ...{
          link: 〈3;#T〉
        },
      ]
      a: [
        {},
      ]
    }
    a: (〈0;#T〉 & {
      a: [
        {
          link: {
            a: [
              {},
            ]
          }
        },
      ]
    })
  }
  p6: {
    #S: {
      #T: {
        a: [
          ...{
            link: 〈3;#T〉
          },
        ]
      }
    }
    #U: {
      〈1;#S〉
      #T: {
        a: [
          {},
        ]
      }
    }
    a: (〈0;#U〉.#T & {
      a: [
        {
          link: {
            a: [
              {},
            ]
          }
        },
      ]
    })
  }
  c1: {
    a: {
      b: {}
      c: (〈1;a〉 & 〈0;b〉)
    }
  }
  d1: {
    a: {
      b: {
        c: {
          d: {
            h: int
            t: 〈4;r〉
          }
        }
      }
    }
    r: 〈0;a〉.b
    x: 〈0;a〉.b.c
  }
  d2: {
    x: 〈0;a〉.b.c
    r: 〈0;a〉.b
    a: {
      b: {
        c: {
          d: {
            h: int
            t: 〈4;r〉
          }
        }
      }
    }
  }
  d3: {
    config: {
      a: {
        b: {
          c: 〈2;indirect〉
        }
      }
      indirect: [
        〈1;a〉.b,
        null,
      ][〈0;i〉]
      i: (int|*1)
    }
    x: (〈0;config〉 & {
      i: 0
    })
  }
  e1: {
    a: 〈0;a〉
    a: {
      c: 〈1;a〉
    }
    b: {
      c: 〈1;b〉
    }
    b: 〈0;b〉
  }
  e2: {
    a: {
      〈1;a〉
    }
    a: {
      c: 〈1;a〉
    }
    b: {
      c: 〈1;b〉
    }
    b: {
      〈1;b〉
    }
  }
  e3: {
    a: [
      〈1;a〉,
    ]
    a: {
      c: 〈1;a〉
    }
    b: [
      〈1;b〉,
    ]
    b: {
      c: 〈1;b〉
    }
  }
  e4: {
    a: [
      (〈1;a〉|{}),
    ]
    a: [
      [
        {
          c: 1
        },
      ],
    ]
    b: [
      [
        {
          c: 1
        },
      ],
    ]
    b: [
      (〈1;b〉|{}),
    ]
  }
  e5: {
    a: {
      c: (〈1;a〉|int)
    }
    a: (〈0;a〉|int)
    b: (〈0;b〉|int)
    b: {
      c: (〈1;b〉|int)
    }
  }
  nestedList: {
    v1e: {
      x: [
        (〈1;x〉|int),
        1,
      ]
      y: (〈0;x〉 & [
        [
          [
            2,
          ],
          1,
        ],
        1,
      ])
    }
    v2e: {
      y: (〈0;x〉 & [
        [
          [
            2,
          ],
          1,
        ],
        1,
      ])
      x: [
        (〈1;x〉|int),
        1,
      ]
    }
    v1: {
      x: [
        (〈1;x〉|int),
        1,
      ]
      y: (〈0;x〉 & [
        [
          [
            2,
            1,
          ],
          1,
        ],
        1,
      ])
    }
    v2: {
      y: (〈0;x〉 & [
        [
          [
            2,
            1,
          ],
          1,
        ],
        1,
      ])
      x: [
        (〈1;x〉|int),
        1,
      ]
    }
  }
  v3: {
    list: {
      head: int
      tail: (〈1;list〉|null)
    }
    myList: 〈0;list〉
    myList: {
      head: 2
      tail: {
        head: 3
        tail: {
          head: 4
        }
      }
    }
  }
  v4: {
    list: {
      head: int
      tail: (〈1;list〉|1)
    }
    myList: 〈0;list〉
    myList: {
      head: 2
      tail: {
        head: 3
      }
    }
  }
  v5: {
    list: {
      head: int
      tail: (〈1;list〉|{})
    }
    myList: 〈0;list〉
    myList: {
      head: 2
      tail: {
        head: 3
      }
    }
  }
  z1: {
    y: {
      f: {
        h: 〈1;g〉
      }
      g: _
    }
    x: {
      f: _
      g: 〈0;f〉
    }
    z: (〈0;x〉 & 〈0;y〉)
  }
  n1: {
    a: {
      b: int
    }
  }
  n2: (〈0;n1〉 & {
    a: 〈1;n1〉
  })
  n3: (〈0;n1〉 & {
    〈1;n1〉
  })
  n4: (〈0;n1〉 & {
    x: (〈1;n1〉 & {
      y: (〈2;n1〉 & {
        z: int
      })
    })
  })
}
