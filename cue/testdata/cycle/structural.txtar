-- in.cue --
a1: {
	f: [f]
}

a2: {
	f: f
}

a3: {
	f: {g: f}
}

a4: {
	a: [a | int]
}

a5: {
	a: b: a | int
}

a6: {
	a: a | int
}

a7: {
	a: c.x
	b: {
		x: c
		y: "foo"
	}
	c: {
		x: b.y
		y: 3
	}
}

b1: {
	b: a & [1]
	a: [a | int]
}

b2: {
	a: [a | int]
	b: a & [1]
}

b3: {
	x: a: [a | int]
	b: x & {a: [1]}
}

b4: {
	b: x.y & [1]
	x: y: [y]
}

// Ensure that the cycle error is not blindly copied to a referring field,
// as the cycle may not persist.
b4: cond1: {
	b: x.y & { _z: false, [1] }
	x: y: {
		_z: *true | bool
		if _z {
			[y]
		}
	}
}

// This reports a structural cycle at b4.cond2.b, because the value it refers
// has a structural cycle. Technically, this is incorrect, as the cycle
// really only occurs in b4.cond2.x.y. But since structural cycles are
// permanent, the entire configuration is invalidated, so the spurious
// additional cycle is merely cosmetic. By most logical standards, one can prove
// any fact from a contradiction. So assuming that, this is not incorrect.
// TODO: fix this cosmetic blemish.
b4: cond2: {
	x: y: {
		_z: *true | bool
		if _z {
			[y]
		}
	}
	b: x.y & { _z: false, [1] }
}

b5: {
	b: x.y & {a: [1]}
	x: y: a: [a | int]
}

b6: {
	b: x & {a: [1]}
	x: a: [a]
}

b7: {
	b: a & [[1]]
	a: [a]
}

// Issue #555
b8: {
	x: a
	a: f: b
	b: a | string
}

// Issue #555
b9: {
	#a: string | #b | #ref
	#b: {
		c: [#a, #a, #a]
	}
	#ref: ref: string
	x: #b | #ref
}

// Issue #534
// TODO: the resolution here is arguably incorrect: c should be
// 		d: string | { b: string }
// However, this is not the end of the world, as the disjunction is preserved
// under the hood and still unifies with extended structure.
b10: {
	a: close({
		b: string | a | c
	})
	c: close({
		d: string | a
	})

	d: d: b: string
}

// Issue #509 -- with comprehension
b11: {
	#list: {
		tail: #list | *null
		if tail != null {
		}
	}
}

// Issue #509 -- with comprehension
b12: {
	#list: {
		V=value: int
		T=tail:  #list | *null
		if T != null {
			sum: V + T.sum
		}
		if T == null {
			sum: V
		}
	}

	list1: #list
	list1: {
		value: 1
		tail: {
			value: 2
			tail: {
				value: 3
				tail: {
					value: 4
				}
			}
		}
	}
}

// More trigger happy on stack overflows.
b12b: {
	#list: {
		tail: #list

		if tail != null {
			sum: tail.sum
		}
	}

	list1: #list
	list1: {
		tail: {
			tail: {
			}
		}
	}
}

// Issue #587
b13: root: a: [ for x in root {x}]

// Issue #587
// TODO: this should probably be okay if we allow shallow evaluation of
// comprehension sources. See #1881.
b14: {
	root: {
		a: [...int]

		for x in a {
			"\(x)": {}
		}

		b: [ for x in root {x}]
	}
}

// This is okay
// Issue #587
b15: root: a: {for x in root {x}}

// Issue #502 -- unused bulk constraints are not cyclic
p1: {
	#T: {
		a: [string]: link: #T
	}

	a: #T & {
		a: one: link: a: two: {}
	}
}

// Issue #502 -- but they are if it is invoked within the struct.
p2: {
	#T: {
		a: [string]: link: #T
		a: b: {}
	}

	a: #T & {
		a: one: link: a: two: {}
	}
}

// Issue #502 -- or added later.
p3: {
	#S: #T: {
		a: [string]: link: #T
	}

	#U: {
		#S
		#T: a: b: {}
	}

	a: #U.#T & {
		a: one: link: a: two: {}
	}
}

// Issue #502 -- unused bulk constraints are not cyclic
p4: {
	#T: {
		a: [...{link: #T}]
	}

	a: #T & {
		a: [{link: a: [{}]}]
	}
}

// Issue #502 -- but they are if it is invoked within the struct.
p5: {
	#T: {
		a: [...{link: #T}]
		a: [{}]
	}

	a: #T & {
		a: [{link: a: [{}]}]
	}
}

// Issue #502 -- or added later.
p6: {
	#S: #T: {
		a: [...{link: #T}]
	}

	#U: {
		#S
		#T: a: [{}]
	}

	a: #U.#T & {
		a: [{link: a: [{}]}]
	}
}

c1: {
	a: {
		b: {}
		c: a & b
	}
}

// indirection
d1: {
	a: b: c: d: {h: int, t: r}
	r: a.b

	x: a.b.c
}

d2: {
	x: a.b.c

	r: a.b
	a: b: c: d: {h: int, t: r}
}

d3: {
	config: {
		a: b: c: indirect
		indirect: [a.b, null][i]
		i:        int | *1
	}
	x: config & {i: 0}
}

// Ensure that the cycles here fail early.
// TODO: they can still be shorter.
shortPathFail: _

shortPathFail: doubleRef: {
	// Avoid this: the first #List reference is different from the second, so
	// the second #List reference counts as a first occurrence, causing the
	// result to be longer than perhaps expected.
	a: #List
	#List: Next: #List | *null
}

shortPathFail: elipsis: {
	// Avoid this: the elipsis causes `_` to be mixed in with the #Foo
	// reference, causing the first cycle to be discounted.
	t1: {
		#Foo: ref:  null | #Foo
		#Foo: { ... }
	}
	t2: {
		Foo: ref:  Foo
		Foo: {...}
	}
}

shortPathFail: comprehension: {
	#list: {
		tail: #list | *null
		if tail != null {
		}
	}
}

withLetFail: {
	schema: next:  _schema_1
	let _schema_1 = schema
}

listOptOK: {
	list: {
		head: int
		tail?: list
	}
	a: list & {head: 3, tail: head: 2}
}

// combining structural with reference cycles
e1: {
	a: a
	a: c: a

	b: c: b
	b: b
}

e2: {
	a: {a}
	a: c: a

	b: c: b
	b: {b}
}

e3: {
	a: [a]
	a: c: a

	b: [b]
	b: c: b
}

e4: {
	a: [a | {}]
	a: [[{c: 1}]]

	b: [[{c: 1}]]
	b: [b | {}]
}

e5: {
	a: c: a | int
	a: a | int

	b: b | int
	b: c: b | int
}

// validating values
nestedList: {
	v1e: {
		x: [x | int, 1]
		y: x & [[[2], 1], 1]
	}

	v2e: {
		y: x & [[[2], 1], 1]
		x: [x | int, 1]
	}

	v1: {
		x: [x | int, 1]
		y: x & [[[2, 1], 1], 1]
	}

	v2: {
		y: x & [[[2, 1], 1], 1]
		x: [x | int, 1]
	}
}

v3: {
	list: {
		head: int
		tail: list | null
	}

	myList: list
	myList: {
		head: 2
		tail: {
			head: 3
			tail: {
				head: 4
			}
		}
	}
}

v4: {
	list: {
		head: int
		tail: list | 1
	}

	myList: list
	myList: {
		head: 2
		tail: head: 3
	}
}

v5: {
	list: {
		head: int
		tail: list | {}
	}

	myList: list
	myList: {
		head: 2
		tail: head: 3
	}
}

// Example from "The Logic of Type Feature Structures" (Bob Carpenter)/
z1: {
	y: {
		f: h: g
		g: _
	}
	x: {
		f: _
		g: f
	}
	z: x & y
}

// Cross references. Here there is no cycle, but the repeated instantiations
// of T will cause, in turn, cause repeated resolution of `x`. The algorithm
// should not identify these as cyclic references. Instead, it should be
// noted that the reference is each time referring to new content.
// Issue #754
crossRefNoCycle: t1: {
	T: {
		x: _
		y: x
	}
	C: { x: T } & T
}

crossRefNoCycle: t2: {
	T: {
		x: _
		y: x
	}
	C: T & { x: T }
}

crossRefNoCycle: t3: {
	T: {
		x: _
		y: x
		z: y
	}
	C: T & { x: T }
}

crossRefNoCycle: t4: {
	T: {
		x: _
		y: x
		z: y
	}
	C: T & { x: T & { x: T } }
}

// Ensure these are NOT treated as structural errors.

n1: a: b: int
n2: n1 & {a: n1}
n3: n1 & {n1}
n4: n1 & {x: n1 & {y: n1 & {z: int}}}
-- out/eval/stats --
Leaks:  16
Freed:  794
Reused: 782
Allocs: 28
Retain: 65

Unifications: 624
Conjuncts:    1221
Disjuncts:    843
-- out/eval --
Errors:
a1.f.0: structural cycle
a3.f.g: structural cycle
b13.root.a.0.0: structural cycle
b14.root.b.1.1: structural cycle
b4.cond1.x.y.0: structural cycle
b4.cond2.x.y.0: structural cycle
b4.x.y.0: structural cycle
b6.b.a.0: conflicting values 1 and [1] (mismatched types int and list):
    ./in.cue:92:5
    ./in.cue:92:13
    ./in.cue:92:14
    ./in.cue:93:9
b6.b.a.0.0: structural cycle
b6.x.a.0: structural cycle
b7.a.0: structural cycle
c1.a.c.c: structural cycle
d1.a.b.c.d.t: structural cycle
d2.a.b.c.d.t: structural cycle
d2.r.c.d.t: structural cycle
d3.x.a.b.c: structural cycle
e1.a.c: structural cycle
e1.b.c: structural cycle
e2.a.c: structural cycle
e2.b.c: structural cycle
e3.a: conflicting values [a] and {c:a} (mismatched types list and struct):
    ./in.cue:385:5
    ./in.cue:386:5
e3.a.c: structural cycle
e3.b: conflicting values [b] and {c:b} (mismatched types list and struct):
    ./in.cue:388:5
    ./in.cue:389:5
e3.b.c: structural cycle
e4.a.0: 4 errors in empty disjunction:
e4.a.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:393:10
    ./in.cue:394:6
e4.a.0.0: 2 errors in empty disjunction:
e4.a.0.0: conflicting values [[{c:1}]] and {c:1} (mismatched types list and struct):
    ./in.cue:394:5
    ./in.cue:394:7
e4.a.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:393:6
    ./in.cue:393:10
    ./in.cue:394:6
e4.b.0: 4 errors in empty disjunction:
e4.b.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:396:6
    ./in.cue:397:10
e4.b.0.0: 2 errors in empty disjunction:
e4.b.0.0: conflicting values [(b|{})] and {c:1} (mismatched types list and struct):
    ./in.cue:396:7
    ./in.cue:397:5
e4.b.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
    ./in.cue:396:6
    ./in.cue:397:6
    ./in.cue:397:10
nestedList.v1e.y.0: 4 errors in empty disjunction:
nestedList.v1e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
    ./in.cue:411:11
    ./in.cue:412:11
nestedList.v1e.y.0.0: 2 errors in empty disjunction:
nestedList.v1e.y.0.0: conflicting values int and [2] (mismatched types int and list):
    ./in.cue:411:11
    ./in.cue:412:12
nestedList.v1e.y.0.0: incompatible list lengths (1 and 2)
nestedList.v2e.y.0: 4 errors in empty disjunction:
nestedList.v2e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
    ./in.cue:416:11
    ./in.cue:417:11
nestedList.v2e.y.0.0: 2 errors in empty disjunction:
nestedList.v2e.y.0.0: conflicting values int and [2] (mismatched types int and list):
    ./in.cue:416:12
    ./in.cue:417:11
nestedList.v2e.y.0.0: incompatible list lengths (1 and 2)
p2.#T.a.b.link: structural cycle
p3.#U.#T.a.b.link: structural cycle
p5.#T.a.0.link: structural cycle
p6.#U.#T.a.0.link: structural cycle
shortPathFail.elipsis.t2.Foo.ref.ref: structural cycle
withLetFail.schema.next: structural cycle
z1.z.f.h: structural cycle
z1.z.g.h: structural cycle
b12b.#list.tail: structural cycle:
    ./in.cue:176:6
d1.r: structural cycle:
    ./in.cue:299:26
d3.x.indirect: structural cycle:
    ./in.cue:314:12

Result:
(_|_){
  // [eval]
  a1: (_|_){
    // [structural cycle]
    f: (_|_){
      // [structural cycle]
      0: (_|_){
        // [structural cycle] a1.f.0: structural cycle
      }
    }
  }
  a2: (struct){
    f: (_){ _ }
  }
  a3: (_|_){
    // [structural cycle]
    f: (_|_){
      // [structural cycle]
      g: (_|_){
        // [structural cycle] a3.f.g: structural cycle
      }
    }
  }
  a4: (struct){
    a: (#list){
      0: (int){ int }
    }
  }
  a5: (struct){
    a: (struct){
      b: (int){ int }
    }
  }
  a6: (struct){
    a: (_){ |((_){ _ }, (int){ int }) }
  }
  a7: (struct){
    a: (string){ "foo" }
    b: (struct){
      x: (struct){
        x: (string){ "foo" }
        y: (int){ 3 }
      }
      y: (string){ "foo" }
    }
    c: (struct){
      x: (string){ "foo" }
      y: (int){ 3 }
    }
  }
  b1: (struct){
    b: (#list){
      0: (int){ 1 }
    }
    a: (#list){
      0: (int){ int }
    }
  }
  b2: (struct){
    a: (#list){
      0: (int){ int }
    }
    b: (#list){
      0: (int){ 1 }
    }
  }
  b3: (struct){
    x: (struct){
      a: (#list){
        0: (int){ int }
      }
    }
    b: (struct){
      a: (#list){
        0: (int){ 1 }
      }
    }
  }
  b4: (_|_){
    // [structural cycle]
    b: (_|_){
      // [structural cycle]
      0: (_|_){
        // [structural cycle] b4.x.y.0: structural cycle
      }
    }
    x: (_|_){
      // [structural cycle]
      y: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle] b4.x.y.0: structural cycle
        }
      }
    }
    cond1: (_|_){
      // [structural cycle]
      b: (#list){
        _z: (bool){ false }
        0: (int){ 1 }
      }
      x: (_|_){
        // [structural cycle]
        y: (_|_){
          // [structural cycle]
          _z: (bool){ |(*(bool){ true }, (bool){ bool }) }
          0: (_|_){
            // [structural cycle] b4.cond1.x.y.0: structural cycle
          }
        }
      }
    }
    cond2: (_|_){
      // [structural cycle]
      x: (_|_){
        // [structural cycle]
        y: (_|_){
          // [structural cycle]
          _z: (bool){ |(*(bool){ true }, (bool){ bool }) }
          0: (_|_){
            // [structural cycle] b4.cond2.x.y.0: structural cycle
          }
        }
      }
      b: (_|_){
        // [structural cycle] b4.cond2.x.y.0: structural cycle
        _z: (bool){ false }
        0: (int){ 1 }
      }
    }
  }
  b5: (struct){
    b: (struct){
      a: (#list){
        0: (int){ 1 }
      }
    }
    x: (struct){
      y: (struct){
        a: (#list){
          0: (int){ int }
        }
      }
    }
  }
  b6: (_|_){
    // [eval]
    b: (_|_){
      // [eval]
      a: (_|_){
        // [eval]
        0: (_|_){
          // [eval] b6.b.a.0: conflicting values 1 and [1] (mismatched types int and list):
          //     ./in.cue:92:5
          //     ./in.cue:92:13
          //     ./in.cue:92:14
          //     ./in.cue:93:9
          0: (_|_){
            // [structural cycle] b6.b.a.0.0: structural cycle
          }
        }
      }
    }
    x: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle] b6.x.a.0: structural cycle
        }
      }
    }
  }
  b7: (_|_){
    // [structural cycle]
    b: (_|_){
      // [structural cycle]
      0: (_|_){
        // [structural cycle] b7.a.0: structural cycle
        0: (int){ 1 }
      }
    }
    a: (_|_){
      // [structural cycle]
      0: (_|_){
        // [structural cycle] b7.a.0: structural cycle
      }
    }
  }
  b8: (struct){
    x: (struct){
      f: (string){ string }
    }
    a: (struct){
      f: (string){ string }
    }
    b: (string){ string }
  }
  b9: (struct){
    #a: ((string|struct)){ |((string){ string }, (#struct){
        ref: (string){ string }
      }) }
    #b: (#struct){
      c: (#list){
        0: ((string|struct)){ |((string){ string }, (#struct){
            ref: (string){ string }
          }) }
        1: ((string|struct)){ |((string){ string }, (#struct){
            ref: (string){ string }
          }) }
        2: ((string|struct)){ |((string){ string }, (#struct){
            ref: (string){ string }
          }) }
      }
    }
    #ref: (#struct){
      ref: (string){ string }
    }
    x: (#struct){ |((#struct){
        c: (#list){
          0: ((string|struct)){ |((string){ string }, (#struct){
              ref: (string){ string }
            }) }
          1: ((string|struct)){ |((string){ string }, (#struct){
              ref: (string){ string }
            }) }
          2: ((string|struct)){ |((string){ string }, (#struct){
              ref: (string){ string }
            }) }
        }
      }, (#struct){
        ref: (string){ string }
      }) }
  }
  b10: (struct){
    a: (#struct){
      b: ((string|struct)){ |((string){ string }, (#struct){
          d: (string){ string }
        }) }
    }
    c: (#struct){
      d: (string){ string }
    }
    d: (struct){
      d: (struct){
        b: (string){ string }
      }
    }
  }
  b11: (struct){
    #list: (#struct){
      tail: ((null|struct)){ |(*(null){ null }, (#struct){
          tail: (null){ null }
        }) }
    }
  }
  b12: (struct){
    #list: (#struct){
      sum: (int){ int }
      value: (int){ int }
      tail: (null){ null }
    }
    list1: (#struct){
      sum: (int){ 10 }
      value: (int){ 1 }
      tail: (#struct){
        value: (int){ 2 }
        tail: (#struct){
          value: (int){ 3 }
          tail: (#struct){
            value: (int){ 4 }
            sum: (int){ 4 }
            tail: (null){ null }
          }
          sum: (int){ 7 }
        }
        sum: (int){ 9 }
      }
    }
  }
  b12b: (_|_){
    // [structural cycle]
    #list: (_|_){
      // [structural cycle] b12b.#list.tail: structural cycle:
      //     ./in.cue:176:6
      tail: (_|_){
        // [structural cycle] b12b.#list.tail: structural cycle:
        //     ./in.cue:176:6
      }
    }
    list1: (_|_){
      // [structural cycle] b12b.#list.tail: structural cycle:
      //     ./in.cue:176:6
      tail: (struct){
        tail: (struct){
        }
      }
    }
  }
  b13: (_|_){
    // [structural cycle]
    root: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle]
          0: (_|_){
            // [structural cycle] b13.root.a.0.0: structural cycle
          }
        }
      }
    }
  }
  b14: (_|_){
    // [structural cycle]
    root: (_|_){
      // [structural cycle]
      a: (list){
      }
      b: (_|_){
        // [structural cycle]
        0: (list){
        }
        1: (_|_){
          // [structural cycle]
          0: (list){
          }
          1: (_|_){
            // [structural cycle] b14.root.b.1.1: structural cycle
          }
        }
      }
    }
  }
  b15: (struct){
    root: (struct){
      a: (struct){
      }
    }
  }
  p1: (struct){
    #T: (#struct){
      a: (#struct){
      }
    }
    a: (#struct){
      a: (#struct){
        one: (#struct){
          link: (#struct){
            a: (#struct){
              two: (#struct){
                link: (#struct){
                  a: (#struct){
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  p2: (_|_){
    // [structural cycle]
    #T: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        b: (_|_){
          // [structural cycle]
          link: (_|_){
            // [structural cycle] p2.#T.a.b.link: structural cycle
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle]
      a: (struct){
        one: (struct){
          link: (struct){
            a: (struct){
              two: (struct){
              }
            }
          }
        }
      }
    }
  }
  p3: (_|_){
    // [structural cycle]
    #S: (#struct){
      #T: (#struct){
        a: (#struct){
        }
      }
    }
    #U: (_|_){
      // [structural cycle]
      #T: (_|_){
        // [structural cycle]
        a: (_|_){
          // [structural cycle]
          b: (_|_){
            // [structural cycle]
            link: (_|_){
              // [structural cycle] p3.#U.#T.a.b.link: structural cycle
            }
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle] p3.#U.#T.a.b.link: structural cycle
      a: (struct){
        one: (struct){
          link: (struct){
            a: (struct){
              two: (struct){
              }
            }
          }
        }
      }
    }
  }
  p4: (struct){
    #T: (#struct){
      a: (list){
      }
    }
    a: (#struct){
      a: (#list){
        0: (#struct){
          link: (#struct){
            a: (#list){
              0: (#struct){
                link: (#struct){
                  a: (list){
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  p5: (_|_){
    // [structural cycle]
    #T: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        0: (_|_){
          // [structural cycle]
          link: (_|_){
            // [structural cycle] p5.#T.a.0.link: structural cycle
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle]
      a: (#list){
        0: (struct){
          link: (struct){
            a: (#list){
              0: (struct){
              }
            }
          }
        }
      }
    }
  }
  p6: (_|_){
    // [structural cycle]
    #S: (#struct){
      #T: (#struct){
        a: (list){
        }
      }
    }
    #U: (_|_){
      // [structural cycle]
      #T: (_|_){
        // [structural cycle]
        a: (_|_){
          // [structural cycle]
          0: (_|_){
            // [structural cycle]
            link: (_|_){
              // [structural cycle] p6.#U.#T.a.0.link: structural cycle
            }
          }
        }
      }
    }
    a: (_|_){
      // [structural cycle] p6.#U.#T.a.0.link: structural cycle
      a: (#list){
        0: (struct){
          link: (struct){
            a: (#list){
              0: (struct){
              }
            }
          }
        }
      }
    }
  }
  c1: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      b: (struct){
      }
      c: (_|_){
        // [structural cycle]
        b: (struct){
        }
        c: (_|_){
          // [structural cycle] c1.a.c.c: structural cycle
        }
      }
    }
  }
  d1: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      b: (_|_){
        // [structural cycle]
        c: (_|_){
          // [structural cycle]
          d: (_|_){
            // [structural cycle]
            h: (int){ int }
            t: (_|_){
              // [structural cycle] d1.a.b.c.d.t: structural cycle
            }
          }
        }
      }
    }
    r: (_|_){
      // [structural cycle] d1.r: structural cycle:
      //     ./in.cue:299:26
    }
    x: (_|_){
      // [structural cycle] d1.a.b.c.d.t: structural cycle
    }
  }
  d2: (_|_){
    // [structural cycle]
    x: (_|_){
      // [structural cycle]
      d: (_|_){
        // [structural cycle]
        h: (int){ int }
        t: (_|_){
          // [structural cycle]
        }
      }
    }
    r: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle]
        d: (_|_){
          // [structural cycle]
          h: (int){ int }
          t: (_|_){
            // [structural cycle] d2.r.c.d.t: structural cycle
          }
        }
      }
    }
    a: (struct){
      b: (struct){
        c: (_|_){
          // [structural cycle]
          d: (_|_){
            // [structural cycle]
            h: (int){ int }
            t: (_|_){
              // [structural cycle] d2.a.b.c.d.t: structural cycle
            }
          }
        }
      }
    }
  }
  d3: (_|_){
    // [structural cycle]
    config: (struct){
      a: (struct){
        b: (struct){
          c: (null){ null }
        }
      }
      indirect: (null){ null }
      i: (int){ |(*(int){ 1 }, (int){ int }) }
    }
    x: (_|_){
      // [structural cycle]
      a: (_|_){
        // [structural cycle]
        b: (_|_){
          // [structural cycle]
          c: (_|_){
            // [structural cycle] d3.x.a.b.c: structural cycle
          }
        }
      }
      indirect: (_|_){
        // [structural cycle] d3.x.indirect: structural cycle:
        //     ./in.cue:314:12
      }
      i: (int){ 0 }
    }
  }
  shortPathFail: (_|_){
    // [structural cycle]
    doubleRef: (struct){
      a: (#struct){
        Next: (null){ null }
      }
      #List: (#struct){
        Next: (null){ null }
      }
    }
    elipsis: (_|_){
      // [structural cycle]
      t1: (struct){
        #Foo: (#struct){
          ref: ((null|struct)){ |((null){ null }, (#struct){
              ref: (null){ null }
            }) }
        }
      }
      t2: (_|_){
        // [structural cycle]
        Foo: (_|_){
          // [structural cycle]
          ref: (_|_){
            // [structural cycle]
            ref: (_|_){
              // [structural cycle] shortPathFail.elipsis.t2.Foo.ref.ref: structural cycle
            }
          }
        }
      }
    }
    comprehension: (struct){
      #list: (#struct){
        tail: ((null|struct)){ |(*(null){ null }, (#struct){
            tail: (null){ null }
          }) }
      }
    }
  }
  withLetFail: (_|_){
    // [structural cycle]
    schema: (_|_){
      // [structural cycle]
      next: (_|_){
        // [structural cycle] withLetFail.schema.next: structural cycle
      }
    }
    let _schema_1#1 = (_|_){
      // [structural cycle] withLetFail._schema_1: structural cycle:
      //     ./in.cue:355:17
    }
  }
  listOptOK: (struct){
    list: (struct){
      head: (int){ int }
      tail?: (_|_){
        // [structural cycle] listOptOK.list.tail: structural cycle
      }
    }
    a: (struct){
      head: (int){ 3 }
      tail: (struct){
        head: (int){ 2 }
        tail?: (_|_){
          // [structural cycle] listOptOK.a.tail.tail: structural cycle
        }
      }
    }
  }
  e1: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e1.a.c: structural cycle
      }
    }
    b: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e1.b.c: structural cycle
      }
    }
  }
  e2: (_|_){
    // [structural cycle]
    a: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e2.a.c: structural cycle
      }
    }
    b: (_|_){
      // [structural cycle]
      c: (_|_){
        // [structural cycle] e2.b.c: structural cycle
      }
    }
  }
  e3: (_|_){
    // [eval]
    a: (_|_){
      // [eval] e3.a: conflicting values [a] and {c:a} (mismatched types list and struct):
      //     ./in.cue:385:5
      //     ./in.cue:386:5
      c: (_|_){
        // [structural cycle] e3.a.c: structural cycle
      }
      0: (_|_){
        // [structural cycle] e3.a.c: structural cycle
      }
    }
    b: (_|_){
      // [eval] e3.b: conflicting values [b] and {c:b} (mismatched types list and struct):
      //     ./in.cue:388:5
      //     ./in.cue:389:5
      c: (_|_){
        // [structural cycle] e3.b.c: structural cycle
      }
      0: (_|_){
        // [structural cycle] e3.b.c: structural cycle
      }
    }
  }
  e4: (_|_){
    // [eval]
    a: (_|_){
      // [eval]
      0: (_|_){
        // [eval] e4.a.0: 4 errors in empty disjunction:
        // e4.a.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:393:10
        //     ./in.cue:394:6
        // e4.a.0.0: 2 errors in empty disjunction:
        // e4.a.0.0: conflicting values [[{c:1}]] and {c:1} (mismatched types list and struct):
        //     ./in.cue:394:5
        //     ./in.cue:394:7
        // e4.a.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:393:6
        //     ./in.cue:393:10
        //     ./in.cue:394:6
        0: (struct){
          c: (int){ 1 }
        }
      }
    }
    b: (_|_){
      // [eval]
      0: (_|_){
        // [eval] e4.b.0: 4 errors in empty disjunction:
        // e4.b.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:396:6
        //     ./in.cue:397:10
        // e4.b.0.0: 2 errors in empty disjunction:
        // e4.b.0.0: conflicting values [(b|{})] and {c:1} (mismatched types list and struct):
        //     ./in.cue:396:7
        //     ./in.cue:397:5
        // e4.b.0.0: conflicting values [{c:1}] and {} (mismatched types list and struct):
        //     ./in.cue:396:6
        //     ./in.cue:397:6
        //     ./in.cue:397:10
        0: (struct){
          c: (int){ 1 }
        }
      }
    }
  }
  e5: (struct){
    a: (struct){
      c: (int){ int }
    }
    b: (struct){
      c: (int){ int }
    }
  }
  nestedList: (_|_){
    // [eval]
    v1e: (_|_){
      // [eval]
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
      y: (_|_){
        // [eval]
        0: (_|_){
          // [eval] nestedList.v1e.y.0: 4 errors in empty disjunction:
          // nestedList.v1e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
          //     ./in.cue:411:11
          //     ./in.cue:412:11
          // nestedList.v1e.y.0.0: 2 errors in empty disjunction:
          // nestedList.v1e.y.0.0: conflicting values int and [2] (mismatched types int and list):
          //     ./in.cue:411:11
          //     ./in.cue:412:12
          // nestedList.v1e.y.0.0: incompatible list lengths (1 and 2)
          0: (#list){
            0: (int){ 2 }
          }
          1: (int){ 1 }
        }
        1: (int){ 1 }
      }
    }
    v2e: (_|_){
      // [eval]
      y: (_|_){
        // [eval]
        0: (_|_){
          // [eval] nestedList.v2e.y.0: 4 errors in empty disjunction:
          // nestedList.v2e.y.0: conflicting values int and [[2],1] (mismatched types int and list):
          //     ./in.cue:416:11
          //     ./in.cue:417:11
          // nestedList.v2e.y.0.0: 2 errors in empty disjunction:
          // nestedList.v2e.y.0.0: conflicting values int and [2] (mismatched types int and list):
          //     ./in.cue:416:12
          //     ./in.cue:417:11
          // nestedList.v2e.y.0.0: incompatible list lengths (1 and 2)
          0: (#list){
            0: (int){ 2 }
          }
          1: (int){ 1 }
        }
        1: (int){ 1 }
      }
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
    }
    v1: (struct){
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
      y: (#list){
        0: (#list){
          0: (#list){
            0: (int){ 2 }
            1: (int){ 1 }
          }
          1: (int){ 1 }
        }
        1: (int){ 1 }
      }
    }
    v2: (struct){
      y: (#list){
        0: (#list){
          0: (#list){
            0: (int){ 2 }
            1: (int){ 1 }
          }
          1: (int){ 1 }
        }
        1: (int){ 1 }
      }
      x: (#list){
        0: (int){ int }
        1: (int){ 1 }
      }
    }
  }
  v3: (struct){
    list: (struct){
      head: (int){ int }
      tail: (null){ null }
    }
    myList: (struct){
      head: (int){ 2 }
      tail: (struct){
        head: (int){ 3 }
        tail: (struct){
          head: (int){ 4 }
          tail: (null){ null }
        }
      }
    }
  }
  v4: (struct){
    list: (struct){
      head: (int){ int }
      tail: (int){ 1 }
    }
    myList: (struct){
      head: (int){ 2 }
      tail: (struct){
        head: (int){ 3 }
        tail: (int){ 1 }
      }
    }
  }
  v5: (struct){
    list: (struct){
      head: (int){ int }
      tail: (struct){
      }
    }
    myList: (struct){
      head: (int){ 2 }
      tail: (struct){ |((struct){
          head: (int){ 3 }
          tail: (struct){
          }
        }, (struct){
          head: (int){ 3 }
        }) }
    }
  }
  z1: (_|_){
    // [structural cycle]
    y: (struct){
      f: (struct){
        h: (_){ _ }
      }
      g: (_){ _ }
    }
    x: (struct){
      f: (_){ _ }
      g: (_){ _ }
    }
    z: (_|_){
      // [structural cycle]
      f: (_|_){
        // [structural cycle]
        h: (_|_){
          // [structural cycle] z1.z.f.h: structural cycle
        }
      }
      g: (_|_){
        // [structural cycle]
        h: (_|_){
          // [structural cycle] z1.z.g.h: structural cycle
        }
      }
    }
  }
  crossRefNoCycle: (struct){
    t1: (struct){
      T: (struct){
        x: (_){ _ }
        y: (_){ _ }
      }
      C: (struct){
        x: (struct){
          x: (_){ _ }
          y: (_){ _ }
        }
        y: (struct){
          x: (_){ _ }
          y: (_){ _ }
        }
      }
    }
    t2: (struct){
      T: (struct){
        x: (_){ _ }
        y: (_){ _ }
      }
      C: (struct){
        x: (struct){
          x: (_){ _ }
          y: (_){ _ }
        }
        y: (struct){
          x: (_){ _ }
          y: (_){ _ }
        }
      }
    }
    t3: (struct){
      T: (struct){
        x: (_){ _ }
        y: (_){ _ }
        z: (_){ _ }
      }
      C: (struct){
        x: (struct){
          x: (_){ _ }
          y: (_){ _ }
          z: (_){ _ }
        }
        y: (struct){
          x: (_){ _ }
          y: (_){ _ }
          z: (_){ _ }
        }
        z: (struct){
          x: (_){ _ }
          y: (_){ _ }
          z: (_){ _ }
        }
      }
    }
    t4: (struct){
      T: (struct){
        x: (_){ _ }
        y: (_){ _ }
        z: (_){ _ }
      }
      C: (struct){
        x: (struct){
          x: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
          y: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
          z: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
        }
        y: (struct){
          x: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
          y: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
          z: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
        }
        z: (struct){
          x: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
          y: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
          z: (struct){
            x: (_){ _ }
            y: (_){ _ }
            z: (_){ _ }
          }
        }
      }
    }
  }
  n1: (struct){
    a: (struct){
      b: (int){ int }
    }
  }
  n2: (struct){
    a: (struct){
      b: (int){ int }
      a: (struct){
        b: (int){ int }
      }
    }
  }
  n3: (struct){
    a: (struct){
      b: (int){ int }
    }
  }
  n4: (struct){
    a: (struct){
      b: (int){ int }
    }
    x: (struct){
      a: (struct){
        b: (int){ int }
      }
      y: (struct){
        a: (struct){
          b: (int){ int }
        }
        z: (int){ int }
      }
    }
  }
}
-- out/compile --
--- in.cue
{
  a1: {
    f: [
      〈1;f〉,
    ]
  }
  a2: {
    f: 〈0;f〉
  }
  a3: {
    f: {
      g: 〈1;f〉
    }
  }
  a4: {
    a: [
      (〈1;a〉|int),
    ]
  }
  a5: {
    a: {
      b: (〈1;a〉|int)
    }
  }
  a6: {
    a: (〈0;a〉|int)
  }
  a7: {
    a: 〈0;c〉.x
    b: {
      x: 〈1;c〉
      y: "foo"
    }
    c: {
      x: 〈1;b〉.y
      y: 3
    }
  }
  b1: {
    b: (〈0;a〉 & [
      1,
    ])
    a: [
      (〈1;a〉|int),
    ]
  }
  b2: {
    a: [
      (〈1;a〉|int),
    ]
    b: (〈0;a〉 & [
      1,
    ])
  }
  b3: {
    x: {
      a: [
        (〈1;a〉|int),
      ]
    }
    b: (〈0;x〉 & {
      a: [
        1,
      ]
    })
  }
  b4: {
    b: (〈0;x〉.y & [
      1,
    ])
    x: {
      y: [
        〈1;y〉,
      ]
    }
  }
  b4: {
    cond1: {
      b: (〈0;x〉.y & {
        _z: false
        [
          1,
        ]
      })
      x: {
        y: {
          _z: (*true|bool)
          if 〈0;_z〉 {
            [
              〈3;y〉,
            ]
          }
        }
      }
    }
  }
  b4: {
    cond2: {
      x: {
        y: {
          _z: (*true|bool)
          if 〈0;_z〉 {
            [
              〈3;y〉,
            ]
          }
        }
      }
      b: (〈0;x〉.y & {
        _z: false
        [
          1,
        ]
      })
    }
  }
  b5: {
    b: (〈0;x〉.y & {
      a: [
        1,
      ]
    })
    x: {
      y: {
        a: [
          (〈1;a〉|int),
        ]
      }
    }
  }
  b6: {
    b: (〈0;x〉 & {
      a: [
        1,
      ]
    })
    x: {
      a: [
        〈1;a〉,
      ]
    }
  }
  b7: {
    b: (〈0;a〉 & [
      [
        1,
      ],
    ])
    a: [
      〈1;a〉,
    ]
  }
  b8: {
    x: 〈0;a〉
    a: {
      f: 〈1;b〉
    }
    b: (〈0;a〉|string)
  }
  b9: {
    #a: (string|〈0;#b〉|〈0;#ref〉)
    #b: {
      c: [
        〈2;#a〉,
        〈2;#a〉,
        〈2;#a〉,
      ]
    }
    #ref: {
      ref: string
    }
    x: (〈0;#b〉|〈0;#ref〉)
  }
  b10: {
    a: close({
      b: (string|〈1;a〉|〈1;c〉)
    })
    c: close({
      d: (string|〈1;a〉)
    })
    d: {
      d: {
        b: string
      }
    }
  }
  b11: {
    #list: {
      tail: (〈1;#list〉|*null)
      if (〈0;tail〉 != null) {}
    }
  }
  b12: {
    #list: {
      value: int
      tail: (〈1;#list〉|*null)
      if (〈0;tail〉 != null) {
        sum: (〈1;value〉 + 〈1;tail〉.sum)
      }
      if (〈0;tail〉 == null) {
        sum: 〈1;value〉
      }
    }
    list1: 〈0;#list〉
    list1: {
      value: 1
      tail: {
        value: 2
        tail: {
          value: 3
          tail: {
            value: 4
          }
        }
      }
    }
  }
  b12b: {
    #list: {
      tail: 〈1;#list〉
      if (〈0;tail〉 != null) {
        sum: 〈1;tail〉.sum
      }
    }
    list1: 〈0;#list〉
    list1: {
      tail: {
        tail: {}
      }
    }
  }
  b13: {
    root: {
      a: [
        for _, x in 〈2;root〉 {
          〈1;x〉
        },
      ]
    }
  }
  b14: {
    root: {
      a: [
        ...int,
      ]
      for _, x in 〈0;a〉 {
        "\(〈1;x〉)": {}
      }
      b: [
        for _, x in 〈2;root〉 {
          〈1;x〉
        },
      ]
    }
  }
  b15: {
    root: {
      a: {
        for _, x in 〈2;root〉 {
          〈1;x〉
        }
      }
    }
  }
  p1: {
    #T: {
      a: {
        [string]: {
          link: 〈3;#T〉
        }
      }
    }
    a: (〈0;#T〉 & {
      a: {
        one: {
          link: {
            a: {
              two: {}
            }
          }
        }
      }
    })
  }
  p2: {
    #T: {
      a: {
        [string]: {
          link: 〈3;#T〉
        }
      }
      a: {
        b: {}
      }
    }
    a: (〈0;#T〉 & {
      a: {
        one: {
          link: {
            a: {
              two: {}
            }
          }
        }
      }
    })
  }
  p3: {
    #S: {
      #T: {
        a: {
          [string]: {
            link: 〈3;#T〉
          }
        }
      }
    }
    #U: {
      〈1;#S〉
      #T: {
        a: {
          b: {}
        }
      }
    }
    a: (〈0;#U〉.#T & {
      a: {
        one: {
          link: {
            a: {
              two: {}
            }
          }
        }
      }
    })
  }
  p4: {
    #T: {
      a: [
        ...{
          link: 〈3;#T〉
        },
      ]
    }
    a: (〈0;#T〉 & {
      a: [
        {
          link: {
            a: [
              {},
            ]
          }
        },
      ]
    })
  }
  p5: {
    #T: {
      a: [
        ...{
          link: 〈3;#T〉
        },
      ]
      a: [
        {},
      ]
    }
    a: (〈0;#T〉 & {
      a: [
        {
          link: {
            a: [
              {},
            ]
          }
        },
      ]
    })
  }
  p6: {
    #S: {
      #T: {
        a: [
          ...{
            link: 〈3;#T〉
          },
        ]
      }
    }
    #U: {
      〈1;#S〉
      #T: {
        a: [
          {},
        ]
      }
    }
    a: (〈0;#U〉.#T & {
      a: [
        {
          link: {
            a: [
              {},
            ]
          }
        },
      ]
    })
  }
  c1: {
    a: {
      b: {}
      c: (〈1;a〉 & 〈0;b〉)
    }
  }
  d1: {
    a: {
      b: {
        c: {
          d: {
            h: int
            t: 〈4;r〉
          }
        }
      }
    }
    r: 〈0;a〉.b
    x: 〈0;a〉.b.c
  }
  d2: {
    x: 〈0;a〉.b.c
    r: 〈0;a〉.b
    a: {
      b: {
        c: {
          d: {
            h: int
            t: 〈4;r〉
          }
        }
      }
    }
  }
  d3: {
    config: {
      a: {
        b: {
          c: 〈2;indirect〉
        }
      }
      indirect: [
        〈1;a〉.b,
        null,
      ][〈0;i〉]
      i: (int|*1)
    }
    x: (〈0;config〉 & {
      i: 0
    })
  }
  shortPathFail: _
  shortPathFail: {
    doubleRef: {
      a: 〈0;#List〉
      #List: {
        Next: (〈1;#List〉|*null)
      }
    }
  }
  shortPathFail: {
    elipsis: {
      t1: {
        #Foo: {
          ref: (null|〈1;#Foo〉)
        }
        #Foo: {
          ...
        }
      }
      t2: {
        Foo: {
          ref: 〈1;Foo〉
        }
        Foo: {
          ...
        }
      }
    }
  }
  shortPathFail: {
    comprehension: {
      #list: {
        tail: (〈1;#list〉|*null)
        if (〈0;tail〉 != null) {}
      }
    }
  }
  withLetFail: {
    schema: {
      next: 〈1;let _schema_1#1〉
    }
    let _schema_1#1 = 〈0;schema〉
  }
  listOptOK: {
    list: {
      head: int
      tail?: 〈1;list〉
    }
    a: (〈0;list〉 & {
      head: 3
      tail: {
        head: 2
      }
    })
  }
  e1: {
    a: 〈0;a〉
    a: {
      c: 〈1;a〉
    }
    b: {
      c: 〈1;b〉
    }
    b: 〈0;b〉
  }
  e2: {
    a: {
      〈1;a〉
    }
    a: {
      c: 〈1;a〉
    }
    b: {
      c: 〈1;b〉
    }
    b: {
      〈1;b〉
    }
  }
  e3: {
    a: [
      〈1;a〉,
    ]
    a: {
      c: 〈1;a〉
    }
    b: [
      〈1;b〉,
    ]
    b: {
      c: 〈1;b〉
    }
  }
  e4: {
    a: [
      (〈1;a〉|{}),
    ]
    a: [
      [
        {
          c: 1
        },
      ],
    ]
    b: [
      [
        {
          c: 1
        },
      ],
    ]
    b: [
      (〈1;b〉|{}),
    ]
  }
  e5: {
    a: {
      c: (〈1;a〉|int)
    }
    a: (〈0;a〉|int)
    b: (〈0;b〉|int)
    b: {
      c: (〈1;b〉|int)
    }
  }
  nestedList: {
    v1e: {
      x: [
        (〈1;x〉|int),
        1,
      ]
      y: (〈0;x〉 & [
        [
          [
            2,
          ],
          1,
        ],
        1,
      ])
    }
    v2e: {
      y: (〈0;x〉 & [
        [
          [
            2,
          ],
          1,
        ],
        1,
      ])
      x: [
        (〈1;x〉|int),
        1,
      ]
    }
    v1: {
      x: [
        (〈1;x〉|int),
        1,
      ]
      y: (〈0;x〉 & [
        [
          [
            2,
            1,
          ],
          1,
        ],
        1,
      ])
    }
    v2: {
      y: (〈0;x〉 & [
        [
          [
            2,
            1,
          ],
          1,
        ],
        1,
      ])
      x: [
        (〈1;x〉|int),
        1,
      ]
    }
  }
  v3: {
    list: {
      head: int
      tail: (〈1;list〉|null)
    }
    myList: 〈0;list〉
    myList: {
      head: 2
      tail: {
        head: 3
        tail: {
          head: 4
        }
      }
    }
  }
  v4: {
    list: {
      head: int
      tail: (〈1;list〉|1)
    }
    myList: 〈0;list〉
    myList: {
      head: 2
      tail: {
        head: 3
      }
    }
  }
  v5: {
    list: {
      head: int
      tail: (〈1;list〉|{})
    }
    myList: 〈0;list〉
    myList: {
      head: 2
      tail: {
        head: 3
      }
    }
  }
  z1: {
    y: {
      f: {
        h: 〈1;g〉
      }
      g: _
    }
    x: {
      f: _
      g: 〈0;f〉
    }
    z: (〈0;x〉 & 〈0;y〉)
  }
  crossRefNoCycle: {
    t1: {
      T: {
        x: _
        y: 〈0;x〉
      }
      C: ({
        x: 〈1;T〉
      } & 〈0;T〉)
    }
  }
  crossRefNoCycle: {
    t2: {
      T: {
        x: _
        y: 〈0;x〉
      }
      C: (〈0;T〉 & {
        x: 〈1;T〉
      })
    }
  }
  crossRefNoCycle: {
    t3: {
      T: {
        x: _
        y: 〈0;x〉
        z: 〈0;y〉
      }
      C: (〈0;T〉 & {
        x: 〈1;T〉
      })
    }
  }
  crossRefNoCycle: {
    t4: {
      T: {
        x: _
        y: 〈0;x〉
        z: 〈0;y〉
      }
      C: (〈0;T〉 & {
        x: (〈1;T〉 & {
          x: 〈2;T〉
        })
      })
    }
  }
  n1: {
    a: {
      b: int
    }
  }
  n2: (〈0;n1〉 & {
    a: 〈1;n1〉
  })
  n3: (〈0;n1〉 & {
    〈1;n1〉
  })
  n4: (〈0;n1〉 & {
    x: (〈1;n1〉 & {
      y: (〈2;n1〉 & {
        z: int
      })
    })
  })
}
