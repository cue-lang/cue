-- in.cue --
#A: {
	a:      "foo"
	"\(a)": 3
}
#B: a: b: {
	c: string
	d: 2
}
#C: a: b: {
	c: *"d" | string
	(c): 2
}

x: #B & #C

-- evalv3regress.cue --
chained: x: {
	(a.b): "foo"
	(x.hello): "true"
	a: b: "hello"
}
-- out/eval/stats --
Leaks:  0
Freed:  23
Reused: 16
Allocs: 7
Retain: 1

Unifications: 19
Conjuncts:    29
Disjuncts:    23
-- out/evalalpha --
Errors:
chained.x: conflicting values "foo" and {a.b:"foo",x.hello:"true",a:{b:"hello"}} (mismatched types string and struct):
    ./evalv3regress.cue:1:13
    ./evalv3regress.cue:2:9

Result:
(_|_){
  // [eval]
  chained: (_|_){
    // [eval]
    x: (_|_){
      // [eval] chained.x: conflicting values "foo" and {a.b:"foo",x.hello:"true",a:{b:"hello"}} (mismatched types string and struct):
      //     ./evalv3regress.cue:1:13
      //     ./evalv3regress.cue:2:9
      a: (_|_){
        // [cycle] cycle error
      }
      hello: (_|_){
        // [cycle] cycle error
      }
    }
  }
  #A: (#struct){
    a: (string){ "foo" }
    foo: (int){ 3 }
  }
  #B: (#struct){
    a: (#struct){
      b: (#struct){
        c: (string){ string }
        d: (int){ 2 }
      }
    }
  }
  #C: (#struct){
    a: (#struct){
      b: (#struct){
        c: (string){ |(*(string){ "d" }, (string){ string }) }
        d: (int){ 2 }
      }
    }
  }
  x: (#struct){
    a: (#struct){
      b: (#struct){
        c: (string){ |(*(string){ "d" }, (string){ string }) }
        d: (int){ 2 }
      }
    }
  }
}
-- diff/-out/evalalpha<==>+out/eval --
diff old new
--- old
+++ new
@@ -1,4 +1,25 @@
-(struct){
+Errors:
+chained.x: conflicting values "foo" and {a.b:"foo",x.hello:"true",a:{b:"hello"}} (mismatched types string and struct):
+    ./evalv3regress.cue:1:13
+    ./evalv3regress.cue:2:9
+
+Result:
+(_|_){
+  // [eval]
+  chained: (_|_){
+    // [eval]
+    x: (_|_){
+      // [eval] chained.x: conflicting values "foo" and {a.b:"foo",x.hello:"true",a:{b:"hello"}} (mismatched types string and struct):
+      //     ./evalv3regress.cue:1:13
+      //     ./evalv3regress.cue:2:9
+      a: (_|_){
+        // [cycle] cycle error
+      }
+      hello: (_|_){
+        // [cycle] cycle error
+      }
+    }
+  }
   #A: (#struct){
     a: (string){ "foo" }
     foo: (int){ 3 }
-- out/eval --
(struct){
  #A: (#struct){
    a: (string){ "foo" }
    foo: (int){ 3 }
  }
  #B: (#struct){
    a: (#struct){
      b: (#struct){
        c: (string){ string }
        d: (int){ 2 }
      }
    }
  }
  #C: (#struct){
    a: (#struct){
      b: (#struct){
        c: (string){ |(*(string){ "d" }, (string){ string }) }
        d: (int){ 2 }
      }
    }
  }
  x: (#struct){
    a: (#struct){
      b: (#struct){
        c: (string){ |(*(string){ "d" }, (string){ string }) }
        d: (int){ 2 }
      }
    }
  }
}
-- out/compile --
--- evalv3regress.cue
{
  chained: {
    x: {
      〈0;a〉.b: "foo"
      〈1;x〉.hello: "true"
      a: {
        b: "hello"
      }
    }
  }
}
--- in.cue
{
  #A: {
    a: "foo"
    "\(〈0;a〉)": 3
  }
  #B: {
    a: {
      b: {
        c: string
        d: 2
      }
    }
  }
  #C: {
    a: {
      b: {
        c: (*"d"|string)
        〈0;c〉: 2
      }
    }
  }
  x: (〈0;#B〉 & 〈0;#C〉)
}
