-- in.cue --
embed: simple: {
	#A: b: 1
	a: { #A }
	a: err: 1
}
embed: andInStruct: {
	#Foo: a: int
	a: { #Foo & { err: 2 } }
}
embed: embedDefWithEmbedding: {
	#Foo: {{a: int}}
	a: { #Foo & { err: 2 } } // not allowed
}
embed: embedComprehension: {
	#Foo: {if true {a: int}}
	a: { #Foo & { err: 2 } } // not allowed
}
embed: fieldWithAnd: {
	#A: {}
	{ a: #A & {err: 3} }
}
embed: embedAndRecursive: {
	#A: a: int
	B: x: #A
	B & { x: err: 2 }
}
embed: andEmbed: {
	#A: b: int
	#B: b: int
	#D: {#A & #B}
	d: #D & {err: 3}
}
and: transitive: ok: {
	Z: a: string
	#Y: Z
	#X: #Y & Z
	out: #X & {
		a: "foo"
	}
}
and: transitive: err: {
	Z: a: string
	#Y: Z
	#X: #Y & Z
	out: #X & {
		err: "foo"
	}
}
and: transitiveWithEmbed: ok: {
	Z: a: string
	#X: #Y & Z
	#Y: {Z}
	out: #X & {
		a: "foo"
	}
}
and: transitiveWithEmbed: err: {
	Z: a: string
	#X: #Y & Z
	#Y: {Z}
	out: #X & {
		err: "foo"
	}
}
embed: nonDef: t1: {
	X: a: string
	#Y: #Z & X
	#Z: {
		X
		b?:    string
	}
}
embed: defAndHidden: full: {
	_stepCommon: Name: string
	#Step: #Command & _stepCommon
	#Command: {
		_stepCommon
		Path?:    string
	}
	out: #Step & {
		Name: "foo"
	}
}
embed: withIndirect: {
	A: #B
	#B: b: int
	A & { err: 2 } // not allowed
}
-- validators.cue --
import (
	"struct"
	"list"
)

embed: normalValidator: {
	#X: {
		struct.MaxFields(1)
		a?: int
		b?: int
	}
	x: #X
	x: err: 1
}
embed: openValidator: t1: {
	#X: {
		matchN(0, [])
		a?: int
		b?: int
	}
	x: #X
	x: err: 1
}
embed: openValidator: t2: {
	Y: matchN(1, [X])
	X: b?: Y
	a: X
	a: b: 1
}
disjunction: withErr: t1: {
	params: {}
	out: #Schema1 & {
		b1: b2: b3: params.mayExistLater
	}
	#Schema1: b1?: null | #Schema2
	#Schema2: b2?: null | {b3?: string}
}
embed: nestedValidator: {
	#types: z?: list.UniqueItems
	x: y: z: [1]
	x: {
		#def
		y?: #types
	}
	#def: {}
}
-- inline.cue --
embedInline: {
	#Schema: {
		a: "hello"
		// do not close outer struct of 'b', as inlined value is not a schema.
		b: { {x: c: "foo"}.x }
		b: {
			c: string
			d: "never printed"
		}
	}
	out: #Schema & __no_sharing
}
issue3853: {
	#Schema: {
		a: "hello"
		// do not close outer struct of 'b', as inlined value is not a schema.
		b: { {x: c: "foo"}.x }
		b: {
			c: string
			d: "never printed"
		}
	}
	out: {x: (#Schema & {}).a}.x
}
-- disjunction.cue --
import "list"

issue3947: full: {
	#Schema: allowed?: string
	_defaults: disallowed: _ | *"default value"
	out: #Schema & _defaults
}
issue3957: reduced: {
	c: a: "bar"
	c: #B & {a: string | *"foo"}
	#B: b?: string
}
issue3957: full: {
	#oneof: {a: string} | {b?: [...string]}
	c: #oneof & {a: string | *"foo"}
	c: a: "bar"
}
issue3957: derived: t1: {
	#Schema: {
		in: string | [...string]
		out: list.FlattenN([in], 1)
	}
	x: #Schema & {in: "foo"}
}
issue3957: derived: t2: {
	#Schema: {
		in: string | [...string]
		let _flat = list.FlattenN([in], 1)
		out: _flat
	}
	out: #Schema & {in: "foo"}
}
-- issue3833.cue --
issue3833: ok: {
	out: { #A & { a: #B } }
	#A: {
		a: {b: string, ...}
		...
	}
	#C: c: string
	#B: {
		#C & {c: "foo"}
		b: "foo"
	}
}
issue3833: evalv2Issue:{
	out: { #A & { a: #B } }
	#A: {
		a: b: string
		...
	}
	#C: c: string
	#B: {
		#C & {c: "foo"}
		b: "foo"
	}
}
-- issue3837.cue --
issue3837: reduced: {
	A: {
		#Embed
		extra: "foo"
	}
	out: {{ x: A & __no_sharing }}
	#Embed: {}
}
issue3837: full: {
	#Embed: {}
	#A: {
		#Embed
		extra: "foo"
	}
	#B: (#C | {})
	#C: bar: string
	out: #B & {
		bar: "baz"
		{
			#def: (#A & __no_sharing)
		}
	}
}
-- issue3832.cue --
issue3832: {
	_person: self: firstName: "Sam"

	#T: {
		_subject: {
			in:  _
			out: {
				let self = in.self
				outFirstName: self.firstName
			}
		}
		_assert: pass: _
		_assert: {
			check!: _
			pass:   "never"
		} | {
			invoke!: _
			pass:    (_subject & {in: invoke}).out
		}
		results: _assert.pass
	}
	#T & {
		_assert: invoke: _person
	}
}
-- issue3839.cue --
issue3839: reduced: {
	x: { A & __no_sharing }
	x: y: 1
	#B: {}
	A: {
		#B
		...
	}
}
issue3839: full: {
	_globals: glb: globalField: ""

	#GlobalContext: globalField: string
	#Context: {
		glb: #GlobalContext
		out: glb
	}
	out: {
		ingress: {
			#Ingress & {
				#def: (#Context & _globals).out
			}
		}

		ingress?: {
			foo: 1234
			bar: "http"
		}
	}
	#Embed: #def: {...}

	#Ingress: {
		#Embed
		...
	}
}
-- chaineddef.cue --
// chained definitions should be handled correctly within embeddings.
issue3920: {
	out: {
		#A
		a: b: "out" // do not enforce #B
	}
	#A: a?: #B
	#B: c?: string
}
onlyCloseDirectStruct: {
	#foo: {}
	x: {y: {{a: #foo}}}
	x: y: b: 1
}
closeInEmbed: {
	x: {close({{["d"]: f: int}})}
	x: d: e: 1
}
-- embedelim.cue --
issue3921: top: {
	#A: #B
	#A: b: string
	#B: _
	a: {#A & {}}
}
issue3921: hidden: {
	#A: #B
	#A: _hidden: b: string
	#B: {}
	a: { #A & { _hidden: {} }}
}
issue3921: full: {
	out: #templateList & #defineMap
	#templateList: {
		#stepMap: [string]: _
		stepList: [for c in #stepMap {c}]
	}
	#defineMap: {
		#stepMap: foo: #Step & {
			image: "bar"
			#config: {}
		}
		stepList: _
	}
	#Step: #StepInner & {
		image: string
		#config: version:   string
	}
	#StepInner: image: string
}
-- issue3843.cue --
// Pattern is unified twice. Ensure that deduping is handled correctly.
dedupPattern: t1: p1: {
	A: {
		#Z: [string]: _
		x: #Z
		x: y: z: 1
	}
	B: A & __no_sharing
	out: A.#Z & B.x
}
dedupPattern: t1: p2: {
	A: {
		#Z: [string]: _
		x: #Z
		x: y: z: 1
	}
	B: A & __no_sharing
	out: B.x & A.#Z
}
-- issue3858.cue --
orig: t1: {
	#Image: embed: image: "foo:v1"
	#JobConfig: {
		image: #Image
		job: #Job & {
			image.embed
		}
	}
	#Job: {
		image: string
		vcs:   "git"
		args:  [...string]
		env:   [string]: string
	}

	#Output: {
		_in:  _
		out:  (_in & {})
	}
	#Output & {
		_in: (#JobConfig & {}).job
	}
}
reduced: t1: {
	Y: {
		a: e: "foo"
		b: X & { a }
	}
	X: {
		e: string
		f: 1 // fails in `out`
	}
	#Z: {
		_in:  _
		out:  _in & __no_sharing
	}
	#Z & {
		_in: Y
	}
}
orig: t2: {
	#JobConfig: {
		image: spec: image: "someimage"
		job: #Job & {
			image.spec
		}
	}
	#Job: {
		image: string
		env:   "FOO"
	}
	
	#Output: {
		in: _
		out: (in & {}).input
	}
	out: #Output & {
		in: input: (#JobConfig & {}).job
	}
}
reduced: t2: {
	Y: {
		a: e: "foo"
		b: X & { a }
	}
	X: {
		e: string
		f: 1 // fails
	}
	#Z: {
		_in:  _
		out:  _in
	}
	#Z & { _in: Y }
}
-- issue3934.cue --
issue3934: {
	out: #Foo & {
		foo: {
			if false {
				extra: nested: 123
			}
		}
	}
	#Foo: foo?: null | #Bar | *{bar: 3}
	#Bar: {
		bar?:   int
		extra?: null | {...}
	}
}
-- large.cue --
full: {
	#Resource: {
		someMsg: string
		obs: {} | *{missing: true}

		let pickMsg = [
			if obs.missing {msg: "\(someMsg)"},
			{msg: "bar"},
		][0]
		patches: [{
			op:    "add"
			path:  "/metadata"
			value: pickMsg.msg
		}]
	}

	#Patches: [string]: _
	#JSONPatch: {
		namespace?: string
		patch: [...#JSONOp]
		output: #Patches & {(namespace): patch}
	}
	#JSONOp: {
		op:    "add"
		path:  string
		value: _
	} | {
		op:   "remove"
		path: string
	}

	#Main: {
		NS=namespace: string

		output: jsonPatch.output

		let jsonPatch = #JSONPatch & {
			let base = #Resource & {}
			let withMsg = base & {someMsg: "foo"}

			namespace: NS

			patch: withMsg.patches
		}
	}
	out: (#Main & {namespace: "ns1"}).output
}
-- ellipsis.cue --
nestedEllipsis: minimal: {
	out: #Schema & { extra: "foo" }
	#Schema: {
		#meta
		...
	}
	#meta: {}
}
nestedEllipsis: nestedWithPatterns: {
	out: #Schema & {
		objs: obj1: extra: "foo"
	}
	#Schema: {
		[_]: [_]: {
			#meta
			...
		}
		#meta: name?: int
		objs?: _
	}
}
issue4015: reduced: {
	#X: { ... }
	out: {
		// Embedded schema allows `a: _`. Adding `a` below should not change that.
		#X
		a: b: string
	}
	out: {
		a: {
			c: "h"
			b: "x"
		}
	}
}
issue4015: nested: {
	#X: { foo: {...} }
	out: {
		#X
		foo: a: b: string
	}
	out: {
		foo: a: {
			c: "h"
			b: "x"
		}
	}
}
issue4015: full: {
	#Schema: {
		cfg: {
			foo: {
				enabled:    bool | *false
				fooField: string
			}
			bar: barField: string
		}
		capacity: int | *3
	}

	#MoreCapacity: {
		capacity: 30
		...
	}

	out: #Schema
	out: {
		#MoreCapacity
		cfg: foo: enabled: true
	}
	out: {
		cfg: {
			foo: fooField: "h"
			bar: barField: "x"
		}
	}
}
-- issue3964.cue --
issue3964: reduced: {
	#Output: { #Embedded }
	#Embedded: {
		name: string
		#Unused | #Used
	}
	#Unused: {}
	#Used: {}
}
issue3964: full: {
	out: #Output & {
		name: "oauth2"
		used: "bar"
	}
	#Output: { #Embedded }
	#Embedded: {
		name: string
		#Unused | #Used
	}
	#Unused: unused: string
	#Used: used: string
}
-- cycle.cue --
issue4006: {
	#A: {
		#B
		fieldA: string
	}
	#B: { #A }
	#C: #A & {}
	out: #C & #B
}
-- out/evalalpha/stats --
Leaks:  47
Freed:  876
Reused: 819
Allocs: 104
Retain: 0

Unifications: 756
Conjuncts:    1520
Disjuncts:    84
Notifications: 7

NumCloseIDs: 445

ConjunctInfos:       1109
MaxConjunctInfos:    5
MaxReqSets:          9
MaxRedirect:         2
-- diff/-out/evalalpha/stats<==>+out/eval/stats --
diff old new
--- old
+++ new
@@ -1,11 +1,17 @@
 Leaks:  47
-Freed:  1002
-Reused: 988
-Allocs: 61
-Retain: 227
-
-Unifications: 929
-Conjuncts:    2032
-Disjuncts:    1209
-
-NumCloseIDs: 3
+Freed:  876
+Reused: 819
+Allocs: 104
+Retain: 0
+
+Unifications: 756
+Conjuncts:    1520
+Disjuncts:    84
+Notifications: 7
+
+NumCloseIDs: 445
+
+ConjunctInfos:       1109
+MaxConjunctInfos:    5
+MaxReqSets:          9
+MaxRedirect:         2
-- out/eval/stats --
Leaks:  47
Freed:  1002
Reused: 988
Allocs: 61
Retain: 227

Unifications: 929
Conjuncts:    2032
Disjuncts:    1209

NumCloseIDs: 3
-- out/evalalpha --
Errors:
and.transitive.err.out.err: field not allowed:
    ./in.cue:46:3
and.transitiveWithEmbed.err.out.err: field not allowed:
    ./in.cue:62:3
embed.andEmbed.d.err: field not allowed:
    ./in.cue:31:11
embed.andInStruct.a.err: field not allowed:
    ./in.cue:8:16
embed.embedAndRecursive.x.err: field not allowed:
    ./in.cue:25:11
embed.embedComprehension.a.err: field not allowed:
    ./in.cue:16:16
embed.embedDefWithEmbedding.a.err: field not allowed:
    ./in.cue:12:16
embed.fieldWithAnd.a.err: field not allowed:
    ./in.cue:20:13
embed.openValidator.t2.a.b: conflicting values 1 and {b?:Y} (mismatched types int and struct):
    ./validators.cue:25:16
    ./validators.cue:26:5
    ./validators.cue:26:9
    ./validators.cue:27:5
    ./validators.cue:28:8
embed.simple.a.err: field not allowed:
    ./in.cue:4:5
embed.withIndirect.err: field not allowed:
    ./in.cue:87:8
issue3833.evalv2Issue.out.a.c: field not allowed:
    ./issue3833.cue:19:6
    ./issue3833.cue:21:9
issue3947.full.out.disallowed: field not allowed:
    ./disjunction.cue:5:13
issue3957.reduced.c.a: field not allowed:
    ./disjunction.cue:9:5
    ./disjunction.cue:10:11
embed.normalValidator.x.err: field not allowed:
    ./validators.cue:8:3
    ./validators.cue:13:5
embed.openValidator.t2.a.b: invalid value 1 (does not satisfy matchN): 0 matched, expected 1:
    ./validators.cue:25:5
    ./validators.cue:25:12
    ./validators.cue:26:9
    ./validators.cue:28:8

Result:
(_|_){
  // [eval]
  issue3920: (struct){
    out: (#struct){
      a: (#struct){
        b: (string){ "out" }
        c?: (string){ string }
      }
    }
    #A: (#struct){
      a?: ~(issue3920.#B)
    }
    #B: (#struct){
      c?: (string){ string }
    }
  }
  onlyCloseDirectStruct: (struct){
    #foo: (#struct){
    }
    x: (struct){
      y: (struct){
        a: (#struct){
        }
        b: (int){ 1 }
      }
    }
  }
  closeInEmbed: (struct){
    x: (#struct){
      d: (struct){
        e: (int){ 1 }
        f: (int){ int }
      }
    }
  }
  issue4006: (struct){
    #A: (#struct){
      fieldA: (string){ string }
    }
    #B: (#struct){
      fieldA: (string){ string }
    }
    #C: (#struct){
      fieldA: (string){ string }
    }
    out: (#struct){
      fieldA: (string){ string }
    }
  }
  issue3947: (_|_){
    // [eval]
    full: (_|_){
      // [eval]
      #Schema: (#struct){
        allowed?: (string){ string }
      }
      _defaults: (struct){
        disallowed: (_){ |(*(string){ "default value" }, (_){ _ }) }
      }
      out: (_|_){
        // [eval]
        allowed?: (string){ string }
        disallowed: (_|_){
          // [eval] issue3947.full.out.disallowed: field not allowed:
          //     ./disjunction.cue:5:13
        }
      }
    }
  }
  issue3957: (_|_){
    // [eval]
    reduced: (_|_){
      // [eval]
      c: (_|_){
        // [eval]
        a: (_|_){
          // [eval] issue3957.reduced.c.a: field not allowed:
          //     ./disjunction.cue:9:5
          //     ./disjunction.cue:10:11
        }
        b?: (string){ string }
      }
      #B: (#struct){
        b?: (string){ string }
      }
    }
    full: (struct){
      #oneof: (#struct){ |((#struct){
          a: (string){ string }
        }, (#struct){
          b?: (list){
          }
        }) }
      c: (#struct){
        a: (string){ "bar" }
      }
    }
    derived: (struct){
      t1: (struct){
        #Schema: (#struct){
          in: ((string|list)){ |((string){ string }, (list){
            }) }
          out: (#list){
            0: ((string|list)){ |((string){ string }, (list){
              }) }
          }
        }
        x: (#struct){
          in: (string){ "foo" }
          out: (#list){
            0: (string){ "foo" }
          }
        }
      }
      t2: (struct){
        #Schema: (#struct){
          in: ((string|list)){ |((string){ string }, (list){
            }) }
          let _flat#1 = (#list){
            0: ((string|list)){ |((string){ string }, (list){
              }) }
          }
          out: (#list){
            0: ((string|list)){ |((string){ string }, (list){
              }) }
          }
        }
        out: (#struct){
          in: (string){ "foo" }
          let _flat#1 = (#list){
            0: (string){ "foo" }
          }
          out: (#list){
            0: (string){ "foo" }
          }
        }
      }
    }
  }
  nestedEllipsis: (struct){
    minimal: (struct){
      out: (#struct){
        extra: (string){ "foo" }
      }
      #Schema: (#struct){
      }
      #meta: (#struct){
      }
    }
    nestedWithPatterns: (struct){
      out: (#struct){
        objs: (#struct){
          obj1: (#struct){
            extra: (string){ "foo" }
            name?: (int){ int }
          }
        }
        #meta: (#struct){
          name?: (int){ int }
        }
      }
      #Schema: (#struct){
        #meta: (#struct){
          name?: (int){ int }
        }
        objs?: (#struct){
        }
      }
    }
  }
  issue4015: (struct){
    reduced: (struct){
      #X: (#struct){
      }
      out: (#struct){
        a: (struct){
          b: (string){ "x" }
          c: (string){ "h" }
        }
      }
    }
    nested: (struct){
      #X: (#struct){
        foo: (#struct){
        }
      }
      out: (#struct){
        foo: (#struct){
          a: (struct){
            b: (string){ "x" }
            c: (string){ "h" }
          }
        }
      }
    }
    full: (struct){
      #Schema: (#struct){
        cfg: (#struct){
          foo: (#struct){
            enabled: (bool){ |(*(bool){ false }, (bool){ bool }) }
            fooField: (string){ string }
          }
          bar: (#struct){
            barField: (string){ string }
          }
        }
        capacity: (int){ |(*(int){ 3 }, (int){ int }) }
      }
      #MoreCapacity: (#struct){
        capacity: (int){ 30 }
      }
      out: (#struct){
        cfg: (#struct){
          foo: (#struct){
            enabled: (bool){ true }
            fooField: (string){ "h" }
          }
          bar: (#struct){
            barField: (string){ "x" }
          }
        }
        capacity: (int){ 30 }
      }
    }
  }
  issue3921: (struct){
    top: (struct){
      #A: (#struct){
        b: (string){ string }
      }
      #B: (_){ _ }
      a: (#struct){
        b: (string){ string }
      }
    }
    hidden: (struct){
      #A: (#struct){
        _hidden: (#struct){
          b: (string){ string }
        }
      }
      #B: (#struct){
      }
      a: (#struct){
        _hidden: (#struct){
          b: (string){ string }
        }
      }
    }
    full: (struct){
      out: (#struct){
        #stepMap: (#struct){
          foo: (#struct){
            image: (string){ "bar" }
            #config: (#struct){
              version: (string){ string }
            }
          }
        }
        stepList: (#list){
          0: (#struct){
            image: (string){ "bar" }
            #config: (#struct){
              version: (string){ string }
            }
          }
        }
      }
      #templateList: (#struct){
        #stepMap: (#struct){
        }
        stepList: (#list){
        }
      }
      #defineMap: (#struct){
        #stepMap: (#struct){
          foo: (#struct){
            image: (string){ "bar" }
            #config: (#struct){
              version: (string){ string }
            }
          }
        }
        stepList: (_){ _ }
      }
      #Step: (#struct){
        image: (string){ string }
        #config: (#struct){
          version: (string){ string }
        }
      }
      #StepInner: (#struct){
        image: (string){ string }
      }
    }
  }
  embed: (_|_){
    // [eval]
    simple: (_|_){
      // [eval]
      #A: (#struct){
        b: (int){ 1 }
      }
      a: (_|_){
        // [eval]
        err: (_|_){
          // [eval] embed.simple.a.err: field not allowed:
          //     ./in.cue:4:5
        }
        b: (int){ 1 }
      }
    }
    andInStruct: (_|_){
      // [eval]
      #Foo: (#struct){
        a: (int){ int }
      }
      a: (_|_){
        // [eval]
        err: (_|_){
          // [eval] embed.andInStruct.a.err: field not allowed:
          //     ./in.cue:8:16
        }
        a: (int){ int }
      }
    }
    embedDefWithEmbedding: (_|_){
      // [eval]
      #Foo: (#struct){
        a: (int){ int }
      }
      a: (_|_){
        // [eval]
        err: (_|_){
          // [eval] embed.embedDefWithEmbedding.a.err: field not allowed:
          //     ./in.cue:12:16
        }
        a: (int){ int }
      }
    }
    embedComprehension: (_|_){
      // [eval]
      #Foo: (#struct){
        a: (int){ int }
      }
      a: (_|_){
        // [eval]
        err: (_|_){
          // [eval] embed.embedComprehension.a.err: field not allowed:
          //     ./in.cue:16:16
        }
        a: (int){ int }
      }
    }
    fieldWithAnd: (_|_){
      // [eval]
      #A: (#struct){
      }
      a: (_|_){
        // [eval]
        err: (_|_){
          // [eval] embed.fieldWithAnd.a.err: field not allowed:
          //     ./in.cue:20:13
        }
      }
    }
    embedAndRecursive: (_|_){
      // [eval]
      #A: (#struct){
        a: (int){ int }
      }
      B: (struct){
        x: ~(embed.embedAndRecursive.#A)
      }
      x: (_|_){
        // [eval]
        err: (_|_){
          // [eval] embed.embedAndRecursive.x.err: field not allowed:
          //     ./in.cue:25:11
        }
        a: (int){ int }
      }
    }
    andEmbed: (_|_){
      // [eval]
      #A: (#struct){
        b: (int){ int }
      }
      #B: (#struct){
        b: (int){ int }
      }
      #D: (#struct){
        b: (int){ int }
      }
      d: (_|_){
        // [eval]
        err: (_|_){
          // [eval] embed.andEmbed.d.err: field not allowed:
          //     ./in.cue:31:11
        }
        b: (int){ int }
      }
    }
    nonDef: (struct){
      t1: (struct){
        X: (struct){
          a: (string){ string }
        }
        #Y: (#struct){
          b?: (string){ string }
          a: (string){ string }
        }
        #Z: (#struct){
          b?: (string){ string }
          a: (string){ string }
        }
      }
    }
    defAndHidden: (struct){
      full: (struct){
        _stepCommon: (struct){
          Name: (string){ string }
        }
        #Step: (#struct){
          Path?: (string){ string }
          Name: (string){ string }
        }
        #Command: (#struct){
          Path?: (string){ string }
          Name: (string){ string }
        }
        out: (#struct){
          Name: (string){ "foo" }
          Path?: (string){ string }
        }
      }
    }
    withIndirect: (_|_){
      // [eval]
      A: ~(embed.withIndirect.#B)
      #B: (#struct){
        b: (int){ int }
      }
      err: (_|_){
        // [eval] embed.withIndirect.err: field not allowed:
        //     ./in.cue:87:8
      }
      b: (int){ int }
    }
    normalValidator: (_|_){
      // [eval]
      #X: (#struct){
        a?: (int){ int }
        b?: (int){ int }
      }
      x: (_|_){
        // [eval]
        err: (_|_){
          // [eval] embed.normalValidator.x.err: field not allowed:
          //     ./validators.cue:8:3
          //     ./validators.cue:13:5
        }
        a?: (int){ int }
        b?: (int){ int }
      }
    }
    openValidator: (_|_){
      // [eval]
      t1: (struct){
        #X: (_){
          matchN(0, (#list){
          })
          a?: (int){ int }
          b?: (int){ int }
        }
        x: (#struct){
          err: (int){ 1 }
          a?: (int){ int }
          b?: (int){ int }
        }
      }
      t2: (_|_){
        // [eval]
        Y: (_){ matchN(1, (#list){
            0: (_|_){// 〈1;X〉
            }
          }) }
        X: (struct){
          b?: (_){ matchN(1, (#list){
              0: (_|_){// 〈1;X〉
              }
            }) }
        }
        a: (_|_){
          // [eval]
          b: (_|_){
            // [eval] embed.openValidator.t2.a.b: conflicting values 1 and {b?:Y} (mismatched types int and struct):
            //     ./validators.cue:25:16
            //     ./validators.cue:26:5
            //     ./validators.cue:26:9
            //     ./validators.cue:27:5
            //     ./validators.cue:28:8
            // embed.openValidator.t2.a.b: invalid value 1 (does not satisfy matchN): 0 matched, expected 1:
            //     ./validators.cue:25:5
            //     ./validators.cue:25:12
            //     ./validators.cue:26:9
            //     ./validators.cue:28:8
          }
        }
      }
    }
    nestedValidator: (struct){
      #types: (#struct){
        z?: (list){ list.UniqueItems() }
      }
      x: (#struct){
        y: (#struct){
          z: (#list){
            0: (int){ 1 }
          }
        }
      }
      #def: (#struct){
      }
    }
  }
  and: (_|_){
    // [eval]
    transitive: (_|_){
      // [eval]
      ok: (struct){
        Z: (struct){
          a: (string){ string }
        }
        #Y: (#struct){
          a: (string){ string }
        }
        #X: (#struct){
          a: (string){ string }
        }
        out: (#struct){
          a: (string){ "foo" }
        }
      }
      err: (_|_){
        // [eval]
        Z: (struct){
          a: (string){ string }
        }
        #Y: (#struct){
          a: (string){ string }
        }
        #X: (#struct){
          a: (string){ string }
        }
        out: (_|_){
          // [eval]
          err: (_|_){
            // [eval] and.transitive.err.out.err: field not allowed:
            //     ./in.cue:46:3
          }
          a: (string){ string }
        }
      }
    }
    transitiveWithEmbed: (_|_){
      // [eval]
      ok: (struct){
        Z: (struct){
          a: (string){ string }
        }
        #X: (#struct){
          a: (string){ string }
        }
        #Y: (#struct){
          a: (string){ string }
        }
        out: (#struct){
          a: (string){ "foo" }
        }
      }
      err: (_|_){
        // [eval]
        Z: (struct){
          a: (string){ string }
        }
        #X: (#struct){
          a: (string){ string }
        }
        #Y: (#struct){
          a: (string){ string }
        }
        out: (_|_){
          // [eval]
          err: (_|_){
            // [eval] and.transitiveWithEmbed.err.out.err: field not allowed:
            //     ./in.cue:62:3
          }
          a: (string){ string }
        }
      }
    }
  }
  embedInline: (struct){
    #Schema: (#struct){
      a: (string){ "hello" }
      b: (#struct){
        c: (string){ "foo" }
        d: (string){ "never printed" }
      }
    }
    out: (#struct){
      a: (string){ "hello" }
      b: (#struct){
        c: (string){ "foo" }
        d: (string){ "never printed" }
      }
    }
  }
  issue3853: (struct){
    #Schema: (#struct){
      a: (string){ "hello" }
      b: (#struct){
        c: (string){ "foo" }
        d: (string){ "never printed" }
      }
    }
    out: (string){ "hello" }
  }
  issue3832: (#struct){
    _person: (struct){
      self: (struct){
        firstName: (string){ "Sam" }
      }
    }
    #T: (#struct){
      _subject: (#struct){
        in: (_){ _ }
        out: (#struct){
          let self#2 = (_|_){
            // [incomplete] issue3832.#T._subject.out.self: in.self undefined as in is incomplete (type _):
            //     ./issue3832.cue:8:16
          }
          outFirstName: (_|_){
            // [incomplete] issue3832.#T._subject.out.outFirstName: undefined field: firstName:
            //     ./issue3832.cue:9:24
          }
        }
      }
      _assert: (#struct){ |((#struct){
          pass: (string){ "never" }
          check!: (_){ _ }
        }, (#struct){
          pass: (#struct){
            let self#2 = (_|_){
              // [incomplete] issue3832.#T._assert.pass.self: undefined field: self:
              //     ./issue3832.cue:8:19
            }
            outFirstName: (_|_){
              // [incomplete] issue3832.#T._assert.pass.outFirstName: undefined field: firstName:
              //     ./issue3832.cue:9:24
            }
          }
          invoke!: (_){ _ }
        }) }
      results: (_|_){
        // [incomplete] issue3832.#T.results: unresolved disjunction {pass:"never",check!:_} | {pass:{let self#2=_|_(issue3832.#T._assert.pass.self: undefined field: self),outFirstName:_|_(issue3832.#T._assert.pass.outFirstName: undefined field: firstName)},invoke!:_} (type struct):
        //     ./issue3832.cue:20:12
      }
    }
    _assert: (#struct){
      invoke: (#struct){
        self: (#struct){
          firstName: (string){ "Sam" }
        }
      }
      pass: (#struct){
        let self#2 = (#struct){
          firstName: (string){ "Sam" }
        }
        outFirstName: (string){ "Sam" }
      }
    }
    _subject: (#struct){
      in: (_){ _ }
      out: (#struct){
        let self#2 = (_|_){
          // [incomplete] issue3832._subject.out.self: in.self undefined as in is incomplete (type _):
          //     ./issue3832.cue:8:16
        }
        outFirstName: (_|_){
          // [incomplete] issue3832._subject.out.outFirstName: undefined field: firstName:
          //     ./issue3832.cue:9:24
        }
      }
    }
    results: ~(issue3832._assert.pass)
  }
  issue3833: (_|_){
    // [eval]
    ok: (struct){
      out: (#struct){
        a: (#struct){
          b: (string){ "foo" }
          c: (string){ "foo" }
        }
      }
      #A: (#struct){
        a: (#struct){
          b: (string){ string }
        }
      }
      #C: (#struct){
        c: (string){ string }
      }
      #B: (#struct){
        c: (string){ "foo" }
        b: (string){ "foo" }
      }
    }
    evalv2Issue: (_|_){
      // [eval]
      out: (_|_){
        // [eval]
        a: (_|_){
          // [eval]
          b: (string){ "foo" }
          c: (_|_){
            // [eval] issue3833.evalv2Issue.out.a.c: field not allowed:
            //     ./issue3833.cue:19:6
            //     ./issue3833.cue:21:9
          }
        }
      }
      #A: (#struct){
        a: (#struct){
          b: (string){ string }
        }
      }
      #C: (#struct){
        c: (string){ string }
      }
      #B: (#struct){
        c: (string){ "foo" }
        b: (string){ "foo" }
      }
    }
  }
  issue3837: (struct){
    reduced: (struct){
      A: (#struct){
        extra: (string){ "foo" }
      }
      out: (struct){
        x: (#struct){
          extra: (string){ "foo" }
        }
      }
      #Embed: (#struct){
      }
    }
    full: (struct){
      #Embed: (#struct){
      }
      #A: (#struct){
        extra: (string){ "foo" }
      }
      #B: (#struct){ |((#struct){
          bar: (string){ string }
        }, (#struct){
        }) }
      #C: (#struct){
        bar: (string){ string }
      }
      out: (#struct){
        bar: (string){ "baz" }
        #def: (#struct){
          extra: (string){ "foo" }
        }
      }
    }
  }
  issue3839: (struct){
    reduced: (struct){
      x: (#struct){
        y: (int){ 1 }
      }
      #B: (#struct){
      }
      A: (#struct){
      }
    }
    full: (struct){
      _globals: (struct){
        glb: (struct){
          globalField: (string){ "" }
        }
      }
      #GlobalContext: (#struct){
        globalField: (string){ string }
      }
      #Context: (#struct){
        glb: ~(issue3839.full.#GlobalContext)
        out: ~(issue3839.full.#GlobalContext)
      }
      out: (struct){
        ingress: (#struct){
          #def: (#struct){
            globalField: (string){ "" }
          }
          foo: (int){ 1234 }
          bar: (string){ "http" }
        }
      }
      #Embed: (#struct){
        #def: (#struct){
        }
      }
      #Ingress: (#struct){
        #def: (#struct){
        }
      }
    }
  }
  dedupPattern: (struct){
    t1: (struct){
      p1: (struct){
        A: (struct){
          #Z: (#struct){
          }
          x: (#struct){
            y: (#struct){
              z: (int){ 1 }
            }
          }
        }
        B: (struct){
          #Z: (#struct){
          }
          x: (#struct){
            y: (#struct){
              z: (int){ 1 }
            }
          }
        }
        out: (#struct){
          y: (#struct){
            z: (int){ 1 }
          }
        }
      }
      p2: (struct){
        A: (struct){
          #Z: (#struct){
          }
          x: (#struct){
            y: (#struct){
              z: (int){ 1 }
            }
          }
        }
        B: (struct){
          #Z: (#struct){
          }
          x: (#struct){
            y: (#struct){
              z: (int){ 1 }
            }
          }
        }
        out: (#struct){
          y: (#struct){
            z: (int){ 1 }
          }
        }
      }
    }
  }
  orig: (struct){
    t1: (#struct){
      #Image: (#struct){
        embed: (#struct){
          image: (string){ "foo:v1" }
        }
      }
      #JobConfig: (#struct){
        image: ~(orig.t1.#Image)
        job: (#struct){
          image: (string){ "foo:v1" }
          vcs: (string){ "git" }
          args: (list){
          }
          env: (#struct){
          }
        }
      }
      #Job: (#struct){
        image: (string){ string }
        vcs: (string){ "git" }
        args: (list){
        }
        env: (#struct){
        }
      }
      #Output: (#struct){
        _in: (_){ _ }
        out: (#struct){
        }
      }
      _in: (#struct){
        image: (string){ "foo:v1" }
        vcs: (string){ "git" }
        args: (list){
        }
        env: (#struct){
        }
      }
      out: (#struct){
        image: (string){ "foo:v1" }
        vcs: (string){ "git" }
        args: (list){
        }
        env: (#struct){
        }
      }
    }
    t2: (struct){
      #JobConfig: (#struct){
        image: (#struct){
          spec: (#struct){
            image: (string){ "someimage" }
          }
        }
        job: (#struct){
          image: (string){ "someimage" }
          env: (string){ "FOO" }
        }
      }
      #Job: (#struct){
        image: (string){ string }
        env: (string){ "FOO" }
      }
      #Output: (#struct){
        in: (_){ _ }
        out: (_|_){
          // [incomplete] orig.t2.#Output.out: undefined field: input:
          //     ./issue3858.cue:55:18
        }
      }
      out: (#struct){
        in: (#struct){
          input: (#struct){
            image: (string){ "someimage" }
            env: (string){ "FOO" }
          }
        }
        out: (#struct){
          image: (string){ "someimage" }
          env: (string){ "FOO" }
        }
      }
    }
  }
  reduced: (struct){
    t1: (#struct){
      Y: (struct){
        a: (struct){
          e: (string){ "foo" }
        }
        b: (struct){
          e: (string){ "foo" }
          f: (int){ 1 }
        }
      }
      X: (struct){
        e: (string){ string }
        f: (int){ 1 }
      }
      #Z: (#struct){
        _in: (_){ _ }
        out: (_){ _ }
      }
      _in: (#struct){
        a: (#struct){
          e: (string){ "foo" }
        }
        b: (#struct){
          e: (string){ "foo" }
          f: (int){ 1 }
        }
      }
      out: (#struct){
        a: (#struct){
          e: (string){ "foo" }
        }
        b: (#struct){
          e: (string){ "foo" }
          f: (int){ 1 }
        }
      }
    }
    t2: (#struct){
      Y: (struct){
        a: (struct){
          e: (string){ "foo" }
        }
        b: (struct){
          e: (string){ "foo" }
          f: (int){ 1 }
        }
      }
      X: (struct){
        e: (string){ string }
        f: (int){ 1 }
      }
      #Z: (#struct){
        _in: (_){ _ }
        out: (_){ _ }
      }
      _in: (#struct){
        a: (#struct){
          e: (string){ "foo" }
        }
        b: (#struct){
          e: (string){ "foo" }
          f: (int){ 1 }
        }
      }
      out: ~(reduced.t2._in)
    }
  }
  issue3934: (struct){
    out: (#struct){
      foo: ((null|struct)){ |(*(#struct){
          bar: (int){ 3 }
        }, (#struct){
          extra?: ((null|struct)){ |((null){ null }, (#struct){
            }) }
          bar?: (int){ int }
        }, (null){ null }) }
    }
    #Foo: (#struct){
      foo?: ((null|struct)){ |(*(#struct){
          bar: (int){ 3 }
        }, (#struct){
          bar?: (int){ int }
          extra?: ((null|struct)){ |((null){ null }, (#struct){
            }) }
        }, (null){ null }) }
    }
    #Bar: (#struct){
      bar?: (int){ int }
      extra?: ((null|struct)){ |((null){ null }, (#struct){
        }) }
    }
  }
  issue3964: (struct){
    reduced: (struct){
      #Output: (#struct){
        name: (string){ string }
      }
      #Embedded: (#struct){
        name: (string){ string }
      }
      #Unused: (#struct){
      }
      #Used: (#struct){
      }
    }
    full: (struct){
      out: (#struct){
        name: (string){ "oauth2" }
        used: (string){ "bar" }
      }
      #Output: (#struct){ |((#struct){
          name: (string){ string }
          unused: (string){ string }
        }, (#struct){
          name: (string){ string }
          used: (string){ string }
        }) }
      #Embedded: (#struct){ |((#struct){
          name: (string){ string }
          unused: (string){ string }
        }, (#struct){
          name: (string){ string }
          used: (string){ string }
        }) }
      #Unused: (#struct){
        unused: (string){ string }
      }
      #Used: (#struct){
        used: (string){ string }
      }
    }
  }
  full: (struct){
    #Resource: (#struct){
      someMsg: (string){ string }
      obs: (#struct){ |(*(#struct){
          missing: (bool){ true }
        }, (#struct){
        }) }
      let pickMsg#3 = (#struct){
        msg: (_|_){
          // [incomplete] full.#Resource.pickMsg.msg: invalid interpolation: non-concrete value string (type string):
          //     ./large.cue:7:25
          //     ./large.cue:3:12
        }
      }
      patches: (#list){
        0: (#struct){
          op: (string){ "add" }
          path: (string){ "/metadata" }
          value: (_|_){
            // [incomplete] full.#Resource.pickMsg.msg: invalid interpolation: non-concrete value string (type string):
            //     ./large.cue:7:25
            //     ./large.cue:3:12
          }
        }
      }
    }
    #Patches: (#struct){
    }
    #JSONPatch: (#struct){
      namespace?: (string){ string }
      patch: (list){
      }
      output: (_|_){
        // [incomplete] full.#JSONPatch.output: cannot reference optional field: namespace:
        //     ./large.cue:21:24
      }
    }
    #JSONOp: (#struct){ |((#struct){
        op: (string){ "add" }
        path: (string){ string }
        value: (_){ _ }
      }, (#struct){
        op: (string){ "remove" }
        path: (string){ string }
      }) }
    #Main: (#struct){
      namespace: (string){ string }
      output: (_|_){
        // [incomplete] full.#Main.jsonPatch.output: key value of dynamic field must be concrete, found string:
        //     ./large.cue:21:24
        //     ./large.cue:19:15
      }
      let jsonPatch#4 = (#struct){
        let base#7 = (#struct){
          someMsg: (string){ string }
          obs: (#struct){ |(*(#struct){
              missing: (bool){ true }
            }, (#struct){
            }) }
          let pickMsg#3 = (#struct){
            msg: (_|_){
              // [incomplete] full.#Main.jsonPatch.base.pickMsg.msg: invalid interpolation: non-concrete value string (type string):
              //     ./large.cue:7:25
              //     ./large.cue:3:12
            }
          }
          patches: (#list){
            0: (#struct){
              op: (string){ "add" }
              path: (string){ "/metadata" }
              value: (_|_){
                // [incomplete] full.#Main.jsonPatch.base.pickMsg.msg: invalid interpolation: non-concrete value string (type string):
                //     ./large.cue:7:25
                //     ./large.cue:3:12
              }
            }
          }
        }
        let withMsg#8 = (#struct){
          someMsg: (string){ "foo" }
          obs: (#struct){ |(*(#struct){
              missing: (bool){ true }
            }, (#struct){
            }) }
          let pickMsg#3 = (#struct){
            msg: (string){ "foo" }
          }
          patches: (#list){
            0: (#struct){
              op: (string){ "add" }
              path: (string){ "/metadata" }
              value: (string){ "foo" }
            }
          }
        }
        namespace: (string){ string }
        patch: (#list){
          0: (#struct){
            op: (string){ "add" }
            path: (string){ "/metadata" }
            value: (string){ "foo" }
          }
        }
        output: (_|_){
          // [incomplete] full.#Main.jsonPatch.output: key value of dynamic field must be concrete, found string:
          //     ./large.cue:21:24
          //     ./large.cue:19:15
        }
      }
    }
    out: (#struct){
      ns1: (#list){
        0: (#struct){
          op: (string){ "add" }
          path: (string){ "/metadata" }
          value: (string){ "foo" }
        }
      }
    }
  }
  disjunction: (struct){
    withErr: (struct){
      t1: (struct){
        params: (struct){
        }
        out: (#struct){
          b1: (_|_){
            // [incomplete] disjunction.withErr.t1.out.b1: 4 errors in empty disjunction:
            // disjunction.withErr.t1.out.b1: conflicting values null and {b2:{b3:params.mayExistLater}} (mismatched types null and struct):
            //     ./validators.cue:32:7
            //     ./validators.cue:33:7
            //     ./validators.cue:35:17
            // disjunction.withErr.t1.out.b1.b2: 2 errors in empty disjunction:
            // disjunction.withErr.t1.out.b1.b2: conflicting values null and {b3:params.mayExistLater} (mismatched types null and struct):
            //     ./validators.cue:32:7
            //     ./validators.cue:33:11
            //     ./validators.cue:35:24
            //     ./validators.cue:36:17
            // disjunction.withErr.t1.out.b1.b2.b3: undefined field: mayExistLater:
            //     ./validators.cue:33:22
            b2: (struct){
              b3: (_){ _ }
            }
          }
        }
        #Schema1: (#struct){
          b1?: ((null|struct)){ |((null){ null }, (#struct){
              b2?: ((null|struct)){ |((null){ null }, (#struct){
                  b3?: (string){ string }
                }) }
            }) }
        }
        #Schema2: (#struct){
          b2?: ((null|struct)){ |((null){ null }, (#struct){
              b3?: (string){ string }
            }) }
        }
      }
    }
  }
}
-- diff/-out/evalalpha<==>+out/eval --
diff old new
--- old
+++ new
@@ -1,59 +1,20 @@
 Errors:
 and.transitive.err.out.err: field not allowed:
-    ./in.cue:42:5
-    ./in.cue:43:6
-    ./in.cue:44:6
-    ./in.cue:44:11
-    ./in.cue:45:7
     ./in.cue:46:3
 and.transitiveWithEmbed.err.out.err: field not allowed:
-    ./in.cue:58:5
-    ./in.cue:59:6
-    ./in.cue:59:11
-    ./in.cue:60:6
-    ./in.cue:60:7
-    ./in.cue:61:7
     ./in.cue:62:3
 embed.andEmbed.d.err: field not allowed:
-    ./in.cue:28:6
-    ./in.cue:29:6
-    ./in.cue:30:6
-    ./in.cue:30:7
-    ./in.cue:30:12
-    ./in.cue:31:5
     ./in.cue:31:11
 embed.andInStruct.a.err: field not allowed:
-    ./in.cue:7:8
-    ./in.cue:8:5
-    ./in.cue:8:7
     ./in.cue:8:16
 embed.embedAndRecursive.x.err: field not allowed:
-    ./in.cue:23:6
-    ./in.cue:24:8
-    ./in.cue:25:2
     ./in.cue:25:11
 embed.embedComprehension.a.err: field not allowed:
-    ./in.cue:15:8
-    ./in.cue:15:9
-    ./in.cue:15:17
-    ./in.cue:16:5
-    ./in.cue:16:7
     ./in.cue:16:16
 embed.embedDefWithEmbedding.a.err: field not allowed:
-    ./in.cue:11:8
-    ./in.cue:11:9
-    ./in.cue:12:5
-    ./in.cue:12:7
     ./in.cue:12:16
 embed.fieldWithAnd.a.err: field not allowed:
-    ./in.cue:19:6
-    ./in.cue:20:2
-    ./in.cue:20:7
     ./in.cue:20:13
-embed.normalValidator.x.err: field not allowed:
-    ./validators.cue:7:6
-    ./validators.cue:12:5
-    ./validators.cue:13:5
 embed.openValidator.t2.a.b: conflicting values 1 and {b?:Y} (mismatched types int and struct):
     ./validators.cue:25:16
     ./validators.cue:26:5
@@ -61,35 +22,20 @@
     ./validators.cue:27:5
     ./validators.cue:28:8
 embed.simple.a.err: field not allowed:
-    ./in.cue:2:6
-    ./in.cue:3:5
-    ./in.cue:3:7
     ./in.cue:4:5
 embed.withIndirect.err: field not allowed:
-    ./in.cue:84:22
-    ./in.cue:85:5
-    ./in.cue:86:6
-    ./in.cue:87:2
     ./in.cue:87:8
+issue3833.evalv2Issue.out.a.c: field not allowed:
+    ./issue3833.cue:19:6
+    ./issue3833.cue:21:9
 issue3947.full.out.disallowed: field not allowed:
-    ./disjunction.cue:4:11
     ./disjunction.cue:5:13
-    ./disjunction.cue:6:7
-    ./disjunction.cue:6:17
-issue3957.reduced.c.a: 2 errors in empty disjunction:
-issue3957.reduced.c.a: conflicting values "foo" and "bar":
-    ./disjunction.cue:9:8
-    ./disjunction.cue:10:24
 issue3957.reduced.c.a: field not allowed:
     ./disjunction.cue:9:5
-    ./disjunction.cue:10:5
     ./disjunction.cue:10:11
-    ./disjunction.cue:11:6
-embed.openValidator.t1.x.err: field not allowed:
-    ./validators.cue:17:3
-    ./validators.cue:16:6
-    ./validators.cue:21:5
-    ./validators.cue:22:5
+embed.normalValidator.x.err: field not allowed:
+    ./validators.cue:8:3
+    ./validators.cue:13:5
 embed.openValidator.t2.a.b: invalid value 1 (does not satisfy matchN): 0 matched, expected 1:
     ./validators.cue:25:5
     ./validators.cue:25:12
@@ -102,14 +48,12 @@
   issue3920: (struct){
     out: (#struct){
       a: (#struct){
-        c?: (string){ string }
         b: (string){ "out" }
-      }
-    }
-    #A: (#struct){
-      a?: (#struct){
-        c?: (string){ string }
-      }
+        c?: (string){ string }
+      }
+    }
+    #A: (#struct){
+      a?: ~(issue3920.#B)
     }
     #B: (#struct){
       c?: (string){ string }
@@ -163,10 +107,7 @@
         allowed?: (string){ string }
         disallowed: (_|_){
           // [eval] issue3947.full.out.disallowed: field not allowed:
-          //     ./disjunction.cue:4:11
           //     ./disjunction.cue:5:13
-          //     ./disjunction.cue:6:7
-          //     ./disjunction.cue:6:17
         }
       }
     }
@@ -178,15 +119,9 @@
       c: (_|_){
         // [eval]
         a: (_|_){
-          // [eval] issue3957.reduced.c.a: 2 errors in empty disjunction:
-          // issue3957.reduced.c.a: conflicting values "foo" and "bar":
-          //     ./disjunction.cue:9:8
-          //     ./disjunction.cue:10:24
-          // issue3957.reduced.c.a: field not allowed:
+          // [eval] issue3957.reduced.c.a: field not allowed:
           //     ./disjunction.cue:9:5
-          //     ./disjunction.cue:10:5
           //     ./disjunction.cue:10:11
-          //     ./disjunction.cue:11:6
         }
         b?: (string){ string }
       }
@@ -259,9 +194,6 @@
     }
     nestedWithPatterns: (struct){
       out: (#struct){
-        #meta: (#struct){
-          name?: (int){ int }
-        }
         objs: (#struct){
           obj1: (#struct){
             extra: (string){ "foo" }
@@ -268,6 +200,9 @@
             name?: (int){ int }
           }
         }
+        #meta: (#struct){
+          name?: (int){ int }
+        }
       }
       #Schema: (#struct){
         #meta: (#struct){
@@ -413,14 +348,11 @@
       }
       a: (_|_){
         // [eval]
-        b: (int){ 1 }
         err: (_|_){
           // [eval] embed.simple.a.err: field not allowed:
-          //     ./in.cue:2:6
-          //     ./in.cue:3:5
-          //     ./in.cue:3:7
           //     ./in.cue:4:5
         }
+        b: (int){ 1 }
       }
     }
     andInStruct: (_|_){
@@ -430,14 +362,11 @@
       }
       a: (_|_){
         // [eval]
-        a: (int){ int }
         err: (_|_){
           // [eval] embed.andInStruct.a.err: field not allowed:
-          //     ./in.cue:7:8
-          //     ./in.cue:8:5
-          //     ./in.cue:8:7
           //     ./in.cue:8:16
         }
+        a: (int){ int }
       }
     }
     embedDefWithEmbedding: (_|_){
@@ -447,15 +376,11 @@
       }
       a: (_|_){
         // [eval]
-        a: (int){ int }
         err: (_|_){
           // [eval] embed.embedDefWithEmbedding.a.err: field not allowed:
-          //     ./in.cue:11:8
-          //     ./in.cue:11:9
-          //     ./in.cue:12:5
-          //     ./in.cue:12:7
           //     ./in.cue:12:16
         }
+        a: (int){ int }
       }
     }
     embedComprehension: (_|_){
@@ -465,16 +390,11 @@
       }
       a: (_|_){
         // [eval]
-        a: (int){ int }
         err: (_|_){
           // [eval] embed.embedComprehension.a.err: field not allowed:
-          //     ./in.cue:15:8
-          //     ./in.cue:15:9
-          //     ./in.cue:15:17
-          //     ./in.cue:16:5
-          //     ./in.cue:16:7
           //     ./in.cue:16:16
         }
+        a: (int){ int }
       }
     }
     fieldWithAnd: (_|_){
@@ -485,9 +405,6 @@
         // [eval]
         err: (_|_){
           // [eval] embed.fieldWithAnd.a.err: field not allowed:
-          //     ./in.cue:19:6
-          //     ./in.cue:20:2
-          //     ./in.cue:20:7
           //     ./in.cue:20:13
         }
       }
@@ -498,20 +415,15 @@
         a: (int){ int }
       }
       B: (struct){
-        x: (#struct){
-          a: (int){ int }
-        }
-      }
-      x: (_|_){
-        // [eval]
-        a: (int){ int }
+        x: ~(embed.embedAndRecursive.#A)
+      }
+      x: (_|_){
+        // [eval]
         err: (_|_){
           // [eval] embed.embedAndRecursive.x.err: field not allowed:
-          //     ./in.cue:23:6
-          //     ./in.cue:24:8
-          //     ./in.cue:25:2
           //     ./in.cue:25:11
         }
+        a: (int){ int }
       }
     }
     andEmbed: (_|_){
@@ -527,17 +439,11 @@
       }
       d: (_|_){
         // [eval]
-        b: (int){ int }
         err: (_|_){
           // [eval] embed.andEmbed.d.err: field not allowed:
-          //     ./in.cue:28:6
-          //     ./in.cue:29:6
-          //     ./in.cue:30:6
-          //     ./in.cue:30:7
-          //     ./in.cue:30:12
-          //     ./in.cue:31:5
           //     ./in.cue:31:11
         }
+        b: (int){ int }
       }
     }
     nonDef: (struct){
@@ -546,12 +452,12 @@
           a: (string){ string }
         }
         #Y: (#struct){
-          a: (string){ string }
-          b?: (string){ string }
+          b?: (string){ string }
+          a: (string){ string }
         }
         #Z: (#struct){
-          a: (string){ string }
-          b?: (string){ string }
+          b?: (string){ string }
+          a: (string){ string }
         }
       }
     }
@@ -561,12 +467,12 @@
           Name: (string){ string }
         }
         #Step: (#struct){
-          Name: (string){ string }
-          Path?: (string){ string }
+          Path?: (string){ string }
+          Name: (string){ string }
         }
         #Command: (#struct){
-          Name: (string){ string }
-          Path?: (string){ string }
+          Path?: (string){ string }
+          Name: (string){ string }
         }
         out: (#struct){
           Name: (string){ "foo" }
@@ -576,21 +482,15 @@
     }
     withIndirect: (_|_){
       // [eval]
-      A: (#struct){
-        b: (int){ int }
-      }
-      #B: (#struct){
-        b: (int){ int }
-      }
-      b: (int){ int }
+      A: ~(embed.withIndirect.#B)
+      #B: (#struct){
+        b: (int){ int }
+      }
       err: (_|_){
         // [eval] embed.withIndirect.err: field not allowed:
-        //     ./in.cue:84:22
-        //     ./in.cue:85:5
-        //     ./in.cue:86:6
-        //     ./in.cue:87:2
         //     ./in.cue:87:8
       }
+      b: (int){ int }
     }
     normalValidator: (_|_){
       // [eval]
@@ -600,20 +500,18 @@
       }
       x: (_|_){
         // [eval]
-        a?: (int){ int }
-        b?: (int){ int }
         err: (_|_){
           // [eval] embed.normalValidator.x.err: field not allowed:
-          //     ./validators.cue:7:6
-          //     ./validators.cue:12:5
+          //     ./validators.cue:8:3
           //     ./validators.cue:13:5
         }
+        a?: (int){ int }
+        b?: (int){ int }
       }
     }
     openValidator: (_|_){
       // [eval]
-      t1: (_|_){
-        // [eval]
+      t1: (struct){
         #X: (_){
           matchN(0, (#list){
           })
@@ -620,17 +518,10 @@
           a?: (int){ int }
           b?: (int){ int }
         }
-        x: (_|_){
-          // [eval]
-          a?: (int){ int }
-          b?: (int){ int }
-          err: (_|_){
-            // [eval] embed.openValidator.t1.x.err: field not allowed:
-            //     ./validators.cue:17:3
-            //     ./validators.cue:16:6
-            //     ./validators.cue:21:5
-            //     ./validators.cue:22:5
-          }
+        x: (#struct){
+          err: (int){ 1 }
+          a?: (int){ int }
+          b?: (int){ int }
         }
       }
       t2: (_|_){
@@ -709,16 +600,11 @@
         }
         out: (_|_){
           // [eval]
-          a: (string){ string }
           err: (_|_){
             // [eval] and.transitive.err.out.err: field not allowed:
-            //     ./in.cue:42:5
-            //     ./in.cue:43:6
-            //     ./in.cue:44:6
-            //     ./in.cue:44:11
-            //     ./in.cue:45:7
             //     ./in.cue:46:3
           }
+          a: (string){ string }
         }
       }
     }
@@ -751,17 +637,11 @@
         }
         out: (_|_){
           // [eval]
-          a: (string){ string }
           err: (_|_){
             // [eval] and.transitiveWithEmbed.err.out.err: field not allowed:
-            //     ./in.cue:58:5
-            //     ./in.cue:59:6
-            //     ./in.cue:59:11
-            //     ./in.cue:60:6
-            //     ./in.cue:60:7
-            //     ./in.cue:61:7
             //     ./in.cue:62:3
           }
+          a: (string){ string }
         }
       }
     }
@@ -807,8 +687,8 @@
             //     ./issue3832.cue:8:16
           }
           outFirstName: (_|_){
-            // [incomplete] issue3832.#T._subject.out.self: in.self undefined as in is incomplete (type _):
-            //     ./issue3832.cue:8:16
+            // [incomplete] issue3832.#T._subject.out.outFirstName: undefined field: firstName:
+            //     ./issue3832.cue:9:24
           }
         }
       }
@@ -818,35 +698,27 @@
         }, (#struct){
           pass: (#struct){
             let self#2 = (_|_){
-              // [incomplete] issue3832.#T._assert.pass.self: in.self undefined (in is incomplete):
-              //     ./issue3832.cue:8:16
+              // [incomplete] issue3832.#T._assert.pass.self: undefined field: self:
+              //     ./issue3832.cue:8:19
             }
             outFirstName: (_|_){
-              // [incomplete] issue3832.#T._assert.pass.self: in.self undefined (in is incomplete):
-              //     ./issue3832.cue:8:16
+              // [incomplete] issue3832.#T._assert.pass.outFirstName: undefined field: firstName:
+              //     ./issue3832.cue:9:24
             }
           }
           invoke!: (_){ _ }
         }) }
       results: (_|_){
-        // [incomplete] issue3832.#T.results: unresolved disjunction {pass:"never",check!:_} | {pass:{let self#2=_|_(issue3832.#T._assert.pass.self: in.self undefined (in is incomplete)),outFirstName:_|_(issue3832.#T._assert.pass.self: in.self undefined (in is incomplete))},invoke!:_} (type struct):
+        // [incomplete] issue3832.#T.results: unresolved disjunction {pass:"never",check!:_} | {pass:{let self#2=_|_(issue3832.#T._assert.pass.self: undefined field: self),outFirstName:_|_(issue3832.#T._assert.pass.outFirstName: undefined field: firstName)},invoke!:_} (type struct):
         //     ./issue3832.cue:20:12
       }
     }
-    _subject: (#struct){
-      in: (_){ _ }
-      out: (#struct){
-        let self#2 = (_|_){
-          // [incomplete] issue3832._subject.out.self: in.self undefined as in is incomplete (type _):
-          //     ./issue3832.cue:8:16
-        }
-        outFirstName: (_|_){
-          // [incomplete] issue3832._subject.out.self: in.self undefined as in is incomplete (type _):
-          //     ./issue3832.cue:8:16
-        }
-      }
-    }
     _assert: (#struct){
+      invoke: (#struct){
+        self: (#struct){
+          firstName: (string){ "Sam" }
+        }
+      }
       pass: (#struct){
         let self#2 = (#struct){
           firstName: (string){ "Sam" }
@@ -853,20 +725,24 @@
         }
         outFirstName: (string){ "Sam" }
       }
-      invoke: (struct){
-        self: (struct){
-          firstName: (string){ "Sam" }
-        }
-      }
-    }
-    results: (#struct){
-      let self#2 = (#struct){
-        firstName: (string){ "Sam" }
-      }
-      outFirstName: (string){ "Sam" }
-    }
-  }
-  issue3833: (struct){
+    }
+    _subject: (#struct){
+      in: (_){ _ }
+      out: (#struct){
+        let self#2 = (_|_){
+          // [incomplete] issue3832._subject.out.self: in.self undefined as in is incomplete (type _):
+          //     ./issue3832.cue:8:16
+        }
+        outFirstName: (_|_){
+          // [incomplete] issue3832._subject.out.outFirstName: undefined field: firstName:
+          //     ./issue3832.cue:9:24
+        }
+      }
+    }
+    results: ~(issue3832._assert.pass)
+  }
+  issue3833: (_|_){
+    // [eval]
     ok: (struct){
       out: (#struct){
         a: (#struct){
@@ -887,11 +763,18 @@
         b: (string){ "foo" }
       }
     }
-    evalv2Issue: (struct){
-      out: (#struct){
-        a: (#struct){
-          b: (string){ "foo" }
-          c: (string){ "foo" }
+    evalv2Issue: (_|_){
+      // [eval]
+      out: (_|_){
+        // [eval]
+        a: (_|_){
+          // [eval]
+          b: (string){ "foo" }
+          c: (_|_){
+            // [eval] issue3833.evalv2Issue.out.a.c: field not allowed:
+            //     ./issue3833.cue:19:6
+            //     ./issue3833.cue:21:9
+          }
         }
       }
       #A: (#struct){
@@ -962,12 +845,8 @@
         globalField: (string){ string }
       }
       #Context: (#struct){
-        glb: (#struct){
-          globalField: (string){ string }
-        }
-        out: (#struct){
-          globalField: (string){ string }
-        }
+        glb: ~(issue3839.full.#GlobalContext)
+        out: ~(issue3839.full.#GlobalContext)
       }
       out: (struct){
         ingress: (#struct){
@@ -995,22 +874,22 @@
           #Z: (#struct){
           }
           x: (#struct){
-            y: (struct){
-              z: (int){ 1 }
-            }
-          }
-        }
-        B: (struct){
-          #Z: (#struct){
-          }
-          x: (#struct){
-            y: (struct){
-              z: (int){ 1 }
-            }
-          }
-        }
-        out: (#struct){
-          y: (struct){
+            y: (#struct){
+              z: (int){ 1 }
+            }
+          }
+        }
+        B: (struct){
+          #Z: (#struct){
+          }
+          x: (#struct){
+            y: (#struct){
+              z: (int){ 1 }
+            }
+          }
+        }
+        out: (#struct){
+          y: (#struct){
             z: (int){ 1 }
           }
         }
@@ -1020,22 +899,22 @@
           #Z: (#struct){
           }
           x: (#struct){
-            y: (struct){
-              z: (int){ 1 }
-            }
-          }
-        }
-        B: (struct){
-          #Z: (#struct){
-          }
-          x: (#struct){
-            y: (struct){
-              z: (int){ 1 }
-            }
-          }
-        }
-        out: (#struct){
-          y: (struct){
+            y: (#struct){
+              z: (int){ 1 }
+            }
+          }
+        }
+        B: (struct){
+          #Z: (#struct){
+          }
+          x: (#struct){
+            y: (#struct){
+              z: (int){ 1 }
+            }
+          }
+        }
+        out: (#struct){
+          y: (#struct){
             z: (int){ 1 }
           }
         }
@@ -1050,11 +929,7 @@
         }
       }
       #JobConfig: (#struct){
-        image: (#struct){
-          embed: (#struct){
-            image: (string){ "foo:v1" }
-          }
-        }
+        image: ~(orig.t1.#Image)
         job: (#struct){
           image: (string){ "foo:v1" }
           vcs: (string){ "git" }
@@ -1118,7 +993,7 @@
         }
       }
       out: (#struct){
-        in: (struct){
+        in: (#struct){
           input: (#struct){
             image: (string){ "someimage" }
             env: (string){ "FOO" }
@@ -1150,11 +1025,11 @@
         _in: (_){ _ }
         out: (_){ _ }
       }
-      _in: (struct){
-        a: (struct){
-          e: (string){ "foo" }
-        }
-        b: (struct){
+      _in: (#struct){
+        a: (#struct){
+          e: (string){ "foo" }
+        }
+        b: (#struct){
           e: (string){ "foo" }
           f: (int){ 1 }
         }
@@ -1187,24 +1062,16 @@
         _in: (_){ _ }
         out: (_){ _ }
       }
-      _in: (struct){
-        a: (struct){
-          e: (string){ "foo" }
-        }
-        b: (struct){
-          e: (string){ "foo" }
-          f: (int){ 1 }
-        }
-      }
-      out: (#struct){
-        a: (#struct){
-          e: (string){ "foo" }
-        }
-        b: (#struct){
-          e: (string){ "foo" }
-          f: (int){ 1 }
-        }
-      }
+      _in: (#struct){
+        a: (#struct){
+          e: (string){ "foo" }
+        }
+        b: (#struct){
+          e: (string){ "foo" }
+          f: (int){ 1 }
+        }
+      }
+      out: ~(reduced.t2._in)
     }
   }
   issue3934: (struct){
@@ -1291,7 +1158,7 @@
           op: (string){ "add" }
           path: (string){ "/metadata" }
           value: (_|_){
-            // [incomplete] full.#Resource.patches.0.value: invalid interpolation: non-concrete value string (type string):
+            // [incomplete] full.#Resource.pickMsg.msg: invalid interpolation: non-concrete value string (type string):
             //     ./large.cue:7:25
             //     ./large.cue:3:12
           }
@@ -1320,38 +1187,11 @@
     #Main: (#struct){
       namespace: (string){ string }
       output: (_|_){
-        // [incomplete] full.#Main.output: invalid non-ground value string (must be concrete string):
+        // [incomplete] full.#Main.jsonPatch.output: key value of dynamic field must be concrete, found string:
+        //     ./large.cue:21:24
         //     ./large.cue:19:15
-        //     ./large.cue:41:15
-        _: (#list){
-          0: (#struct){
-            op: (string){ "add" }
-            path: (string){ "/metadata" }
-            value: (string){ "foo" }
-          }
-        }
       }
       let jsonPatch#4 = (#struct){
-        namespace: (string){ string }
-        patch: (#list){
-          0: (#struct){
-            op: (string){ "add" }
-            path: (string){ "/metadata" }
-            value: (string){ "foo" }
-          }
-        }
-        output: (_|_){
-          // [incomplete] full.#Main.jsonPatch.output: invalid non-ground value string (must be concrete string):
-          //     ./large.cue:19:15
-          //     ./large.cue:41:15
-          _: (#list){
-            0: (#struct){
-              op: (string){ "add" }
-              path: (string){ "/metadata" }
-              value: (string){ "foo" }
-            }
-          }
-        }
         let base#7 = (#struct){
           someMsg: (string){ string }
           obs: (#struct){ |(*(#struct){
@@ -1370,7 +1210,7 @@
               op: (string){ "add" }
               path: (string){ "/metadata" }
               value: (_|_){
-                // [incomplete] full.#Main.jsonPatch.base.patches.0.value: invalid interpolation: non-concrete value string (type string):
+                // [incomplete] full.#Main.jsonPatch.base.pickMsg.msg: invalid interpolation: non-concrete value string (type string):
                 //     ./large.cue:7:25
                 //     ./large.cue:3:12
               }
@@ -1394,6 +1234,19 @@
             }
           }
         }
+        namespace: (string){ string }
+        patch: (#list){
+          0: (#struct){
+            op: (string){ "add" }
+            path: (string){ "/metadata" }
+            value: (string){ "foo" }
+          }
+        }
+        output: (_|_){
+          // [incomplete] full.#Main.jsonPatch.output: key value of dynamic field must be concrete, found string:
+          //     ./large.cue:21:24
+          //     ./large.cue:19:15
+        }
       }
     }
     out: (#struct){
@@ -1415,25 +1268,19 @@
           b1: (_|_){
             // [incomplete] disjunction.withErr.t1.out.b1: 4 errors in empty disjunction:
             // disjunction.withErr.t1.out.b1: conflicting values null and {b2:{b3:params.mayExistLater}} (mismatched types null and struct):
+            //     ./validators.cue:32:7
             //     ./validators.cue:33:7
             //     ./validators.cue:35:17
             // disjunction.withErr.t1.out.b1.b2: 2 errors in empty disjunction:
             // disjunction.withErr.t1.out.b1.b2: conflicting values null and {b3:params.mayExistLater} (mismatched types null and struct):
+            //     ./validators.cue:32:7
             //     ./validators.cue:33:11
+            //     ./validators.cue:35:24
             //     ./validators.cue:36:17
             // disjunction.withErr.t1.out.b1.b2.b3: undefined field: mayExistLater:
             //     ./validators.cue:33:22
-            b2: (_|_){
-              // [incomplete] disjunction.withErr.t1.out.b1.b2: 2 errors in empty disjunction:
-              // disjunction.withErr.t1.out.b1.b2: conflicting values null and {b3:params.mayExistLater} (mismatched types null and struct):
-              //     ./validators.cue:33:11
-              //     ./validators.cue:36:17
-              // disjunction.withErr.t1.out.b1.b2.b3: undefined field: mayExistLater:
-              //     ./validators.cue:33:22
-              b3: (_|_){
-                // [incomplete] disjunction.withErr.t1.out.b1.b2.b3: undefined field: mayExistLater:
-                //     ./validators.cue:33:22
-              }
+            b2: (struct){
+              b3: (_){ _ }
             }
           }
         }
-- diff/todo/p1 --
embed.openValidator.t1.err: unexpected pass.
-- diff/todo/p2 --
and.transitive(WithEmbed)?.out.ok: unexpected error
-- diff/explanation --
issue3833.evalv2Issue: now catches an invalid field that was previously allowed.
Note that this is not the same field as the one reported in the issue. This is a
correct fix relative to evalv2.
-- out/eval --
Errors:
and.transitive.err.out.err: field not allowed:
    ./in.cue:42:5
    ./in.cue:43:6
    ./in.cue:44:6
    ./in.cue:44:11
    ./in.cue:45:7
    ./in.cue:46:3
and.transitiveWithEmbed.err.out.err: field not allowed:
    ./in.cue:58:5
    ./in.cue:59:6
    ./in.cue:59:11
    ./in.cue:60:6
    ./in.cue:60:7
    ./in.cue:61:7
    ./in.cue:62:3
embed.andEmbed.d.err: field not allowed:
    ./in.cue:28:6
    ./in.cue:29:6
    ./in.cue:30:6
    ./in.cue:30:7
    ./in.cue:30:12
    ./in.cue:31:5
    ./in.cue:31:11
embed.andInStruct.a.err: field not allowed:
    ./in.cue:7:8
    ./in.cue:8:5
    ./in.cue:8:7
    ./in.cue:8:16
embed.embedAndRecursive.x.err: field not allowed:
    ./in.cue:23:6
    ./in.cue:24:8
    ./in.cue:25:2
    ./in.cue:25:11
embed.embedComprehension.a.err: field not allowed:
    ./in.cue:15:8
    ./in.cue:15:9
    ./in.cue:15:17
    ./in.cue:16:5
    ./in.cue:16:7
    ./in.cue:16:16
embed.embedDefWithEmbedding.a.err: field not allowed:
    ./in.cue:11:8
    ./in.cue:11:9
    ./in.cue:12:5
    ./in.cue:12:7
    ./in.cue:12:16
embed.fieldWithAnd.a.err: field not allowed:
    ./in.cue:19:6
    ./in.cue:20:2
    ./in.cue:20:7
    ./in.cue:20:13
embed.normalValidator.x.err: field not allowed:
    ./validators.cue:7:6
    ./validators.cue:12:5
    ./validators.cue:13:5
embed.openValidator.t2.a.b: conflicting values 1 and {b?:Y} (mismatched types int and struct):
    ./validators.cue:25:16
    ./validators.cue:26:5
    ./validators.cue:26:9
    ./validators.cue:27:5
    ./validators.cue:28:8
embed.simple.a.err: field not allowed:
    ./in.cue:2:6
    ./in.cue:3:5
    ./in.cue:3:7
    ./in.cue:4:5
embed.withIndirect.err: field not allowed:
    ./in.cue:84:22
    ./in.cue:85:5
    ./in.cue:86:6
    ./in.cue:87:2
    ./in.cue:87:8
issue3947.full.out.disallowed: field not allowed:
    ./disjunction.cue:4:11
    ./disjunction.cue:5:13
    ./disjunction.cue:6:7
    ./disjunction.cue:6:17
issue3957.reduced.c.a: 2 errors in empty disjunction:
issue3957.reduced.c.a: conflicting values "foo" and "bar":
    ./disjunction.cue:9:8
    ./disjunction.cue:10:24
issue3957.reduced.c.a: field not allowed:
    ./disjunction.cue:9:5
    ./disjunction.cue:10:5
    ./disjunction.cue:10:11
    ./disjunction.cue:11:6
embed.openValidator.t1.x.err: field not allowed:
    ./validators.cue:17:3
    ./validators.cue:16:6
    ./validators.cue:21:5
    ./validators.cue:22:5
embed.openValidator.t2.a.b: invalid value 1 (does not satisfy matchN): 0 matched, expected 1:
    ./validators.cue:25:5
    ./validators.cue:25:12
    ./validators.cue:26:9
    ./validators.cue:28:8

Result:
(_|_){
  // [eval]
  issue3920: (struct){
    out: (#struct){
      a: (#struct){
        c?: (string){ string }
        b: (string){ "out" }
      }
    }
    #A: (#struct){
      a?: (#struct){
        c?: (string){ string }
      }
    }
    #B: (#struct){
      c?: (string){ string }
    }
  }
  onlyCloseDirectStruct: (struct){
    #foo: (#struct){
    }
    x: (struct){
      y: (struct){
        a: (#struct){
        }
        b: (int){ 1 }
      }
    }
  }
  closeInEmbed: (struct){
    x: (#struct){
      d: (struct){
        e: (int){ 1 }
        f: (int){ int }
      }
    }
  }
  issue4006: (struct){
    #A: (#struct){
      fieldA: (string){ string }
    }
    #B: (#struct){
      fieldA: (string){ string }
    }
    #C: (#struct){
      fieldA: (string){ string }
    }
    out: (#struct){
      fieldA: (string){ string }
    }
  }
  issue3947: (_|_){
    // [eval]
    full: (_|_){
      // [eval]
      #Schema: (#struct){
        allowed?: (string){ string }
      }
      _defaults: (struct){
        disallowed: (_){ |(*(string){ "default value" }, (_){ _ }) }
      }
      out: (_|_){
        // [eval]
        allowed?: (string){ string }
        disallowed: (_|_){
          // [eval] issue3947.full.out.disallowed: field not allowed:
          //     ./disjunction.cue:4:11
          //     ./disjunction.cue:5:13
          //     ./disjunction.cue:6:7
          //     ./disjunction.cue:6:17
        }
      }
    }
  }
  issue3957: (_|_){
    // [eval]
    reduced: (_|_){
      // [eval]
      c: (_|_){
        // [eval]
        a: (_|_){
          // [eval] issue3957.reduced.c.a: 2 errors in empty disjunction:
          // issue3957.reduced.c.a: conflicting values "foo" and "bar":
          //     ./disjunction.cue:9:8
          //     ./disjunction.cue:10:24
          // issue3957.reduced.c.a: field not allowed:
          //     ./disjunction.cue:9:5
          //     ./disjunction.cue:10:5
          //     ./disjunction.cue:10:11
          //     ./disjunction.cue:11:6
        }
        b?: (string){ string }
      }
      #B: (#struct){
        b?: (string){ string }
      }
    }
    full: (struct){
      #oneof: (#struct){ |((#struct){
          a: (string){ string }
        }, (#struct){
          b?: (list){
          }
        }) }
      c: (#struct){
        a: (string){ "bar" }
      }
    }
    derived: (struct){
      t1: (struct){
        #Schema: (#struct){
          in: ((string|list)){ |((string){ string }, (list){
            }) }
          out: (#list){
            0: ((string|list)){ |((string){ string }, (list){
              }) }
          }
        }
        x: (#struct){
          in: (string){ "foo" }
          out: (#list){
            0: (string){ "foo" }
          }
        }
      }
      t2: (struct){
        #Schema: (#struct){
          in: ((string|list)){ |((string){ string }, (list){
            }) }
          let _flat#1 = (#list){
            0: ((string|list)){ |((string){ string }, (list){
              }) }
          }
          out: (#list){
            0: ((string|list)){ |((string){ string }, (list){
              }) }
          }
        }
        out: (#struct){
          in: (string){ "foo" }
          let _flat#1 = (#list){
            0: (string){ "foo" }
          }
          out: (#list){
            0: (string){ "foo" }
          }
        }
      }
    }
  }
  nestedEllipsis: (struct){
    minimal: (struct){
      out: (#struct){
        extra: (string){ "foo" }
      }
      #Schema: (#struct){
      }
      #meta: (#struct){
      }
    }
    nestedWithPatterns: (struct){
      out: (#struct){
        #meta: (#struct){
          name?: (int){ int }
        }
        objs: (#struct){
          obj1: (#struct){
            extra: (string){ "foo" }
            name?: (int){ int }
          }
        }
      }
      #Schema: (#struct){
        #meta: (#struct){
          name?: (int){ int }
        }
        objs?: (#struct){
        }
      }
    }
  }
  issue4015: (struct){
    reduced: (struct){
      #X: (#struct){
      }
      out: (#struct){
        a: (struct){
          b: (string){ "x" }
          c: (string){ "h" }
        }
      }
    }
    nested: (struct){
      #X: (#struct){
        foo: (#struct){
        }
      }
      out: (#struct){
        foo: (#struct){
          a: (struct){
            b: (string){ "x" }
            c: (string){ "h" }
          }
        }
      }
    }
    full: (struct){
      #Schema: (#struct){
        cfg: (#struct){
          foo: (#struct){
            enabled: (bool){ |(*(bool){ false }, (bool){ bool }) }
            fooField: (string){ string }
          }
          bar: (#struct){
            barField: (string){ string }
          }
        }
        capacity: (int){ |(*(int){ 3 }, (int){ int }) }
      }
      #MoreCapacity: (#struct){
        capacity: (int){ 30 }
      }
      out: (#struct){
        cfg: (#struct){
          foo: (#struct){
            enabled: (bool){ true }
            fooField: (string){ "h" }
          }
          bar: (#struct){
            barField: (string){ "x" }
          }
        }
        capacity: (int){ 30 }
      }
    }
  }
  issue3921: (struct){
    top: (struct){
      #A: (#struct){
        b: (string){ string }
      }
      #B: (_){ _ }
      a: (#struct){
        b: (string){ string }
      }
    }
    hidden: (struct){
      #A: (#struct){
        _hidden: (#struct){
          b: (string){ string }
        }
      }
      #B: (#struct){
      }
      a: (#struct){
        _hidden: (#struct){
          b: (string){ string }
        }
      }
    }
    full: (struct){
      out: (#struct){
        #stepMap: (#struct){
          foo: (#struct){
            image: (string){ "bar" }
            #config: (#struct){
              version: (string){ string }
            }
          }
        }
        stepList: (#list){
          0: (#struct){
            image: (string){ "bar" }
            #config: (#struct){
              version: (string){ string }
            }
          }
        }
      }
      #templateList: (#struct){
        #stepMap: (#struct){
        }
        stepList: (#list){
        }
      }
      #defineMap: (#struct){
        #stepMap: (#struct){
          foo: (#struct){
            image: (string){ "bar" }
            #config: (#struct){
              version: (string){ string }
            }
          }
        }
        stepList: (_){ _ }
      }
      #Step: (#struct){
        image: (string){ string }
        #config: (#struct){
          version: (string){ string }
        }
      }
      #StepInner: (#struct){
        image: (string){ string }
      }
    }
  }
  embed: (_|_){
    // [eval]
    simple: (_|_){
      // [eval]
      #A: (#struct){
        b: (int){ 1 }
      }
      a: (_|_){
        // [eval]
        b: (int){ 1 }
        err: (_|_){
          // [eval] embed.simple.a.err: field not allowed:
          //     ./in.cue:2:6
          //     ./in.cue:3:5
          //     ./in.cue:3:7
          //     ./in.cue:4:5
        }
      }
    }
    andInStruct: (_|_){
      // [eval]
      #Foo: (#struct){
        a: (int){ int }
      }
      a: (_|_){
        // [eval]
        a: (int){ int }
        err: (_|_){
          // [eval] embed.andInStruct.a.err: field not allowed:
          //     ./in.cue:7:8
          //     ./in.cue:8:5
          //     ./in.cue:8:7
          //     ./in.cue:8:16
        }
      }
    }
    embedDefWithEmbedding: (_|_){
      // [eval]
      #Foo: (#struct){
        a: (int){ int }
      }
      a: (_|_){
        // [eval]
        a: (int){ int }
        err: (_|_){
          // [eval] embed.embedDefWithEmbedding.a.err: field not allowed:
          //     ./in.cue:11:8
          //     ./in.cue:11:9
          //     ./in.cue:12:5
          //     ./in.cue:12:7
          //     ./in.cue:12:16
        }
      }
    }
    embedComprehension: (_|_){
      // [eval]
      #Foo: (#struct){
        a: (int){ int }
      }
      a: (_|_){
        // [eval]
        a: (int){ int }
        err: (_|_){
          // [eval] embed.embedComprehension.a.err: field not allowed:
          //     ./in.cue:15:8
          //     ./in.cue:15:9
          //     ./in.cue:15:17
          //     ./in.cue:16:5
          //     ./in.cue:16:7
          //     ./in.cue:16:16
        }
      }
    }
    fieldWithAnd: (_|_){
      // [eval]
      #A: (#struct){
      }
      a: (_|_){
        // [eval]
        err: (_|_){
          // [eval] embed.fieldWithAnd.a.err: field not allowed:
          //     ./in.cue:19:6
          //     ./in.cue:20:2
          //     ./in.cue:20:7
          //     ./in.cue:20:13
        }
      }
    }
    embedAndRecursive: (_|_){
      // [eval]
      #A: (#struct){
        a: (int){ int }
      }
      B: (struct){
        x: (#struct){
          a: (int){ int }
        }
      }
      x: (_|_){
        // [eval]
        a: (int){ int }
        err: (_|_){
          // [eval] embed.embedAndRecursive.x.err: field not allowed:
          //     ./in.cue:23:6
          //     ./in.cue:24:8
          //     ./in.cue:25:2
          //     ./in.cue:25:11
        }
      }
    }
    andEmbed: (_|_){
      // [eval]
      #A: (#struct){
        b: (int){ int }
      }
      #B: (#struct){
        b: (int){ int }
      }
      #D: (#struct){
        b: (int){ int }
      }
      d: (_|_){
        // [eval]
        b: (int){ int }
        err: (_|_){
          // [eval] embed.andEmbed.d.err: field not allowed:
          //     ./in.cue:28:6
          //     ./in.cue:29:6
          //     ./in.cue:30:6
          //     ./in.cue:30:7
          //     ./in.cue:30:12
          //     ./in.cue:31:5
          //     ./in.cue:31:11
        }
      }
    }
    nonDef: (struct){
      t1: (struct){
        X: (struct){
          a: (string){ string }
        }
        #Y: (#struct){
          a: (string){ string }
          b?: (string){ string }
        }
        #Z: (#struct){
          a: (string){ string }
          b?: (string){ string }
        }
      }
    }
    defAndHidden: (struct){
      full: (struct){
        _stepCommon: (struct){
          Name: (string){ string }
        }
        #Step: (#struct){
          Name: (string){ string }
          Path?: (string){ string }
        }
        #Command: (#struct){
          Name: (string){ string }
          Path?: (string){ string }
        }
        out: (#struct){
          Name: (string){ "foo" }
          Path?: (string){ string }
        }
      }
    }
    withIndirect: (_|_){
      // [eval]
      A: (#struct){
        b: (int){ int }
      }
      #B: (#struct){
        b: (int){ int }
      }
      b: (int){ int }
      err: (_|_){
        // [eval] embed.withIndirect.err: field not allowed:
        //     ./in.cue:84:22
        //     ./in.cue:85:5
        //     ./in.cue:86:6
        //     ./in.cue:87:2
        //     ./in.cue:87:8
      }
    }
    normalValidator: (_|_){
      // [eval]
      #X: (#struct){
        a?: (int){ int }
        b?: (int){ int }
      }
      x: (_|_){
        // [eval]
        a?: (int){ int }
        b?: (int){ int }
        err: (_|_){
          // [eval] embed.normalValidator.x.err: field not allowed:
          //     ./validators.cue:7:6
          //     ./validators.cue:12:5
          //     ./validators.cue:13:5
        }
      }
    }
    openValidator: (_|_){
      // [eval]
      t1: (_|_){
        // [eval]
        #X: (_){
          matchN(0, (#list){
          })
          a?: (int){ int }
          b?: (int){ int }
        }
        x: (_|_){
          // [eval]
          a?: (int){ int }
          b?: (int){ int }
          err: (_|_){
            // [eval] embed.openValidator.t1.x.err: field not allowed:
            //     ./validators.cue:17:3
            //     ./validators.cue:16:6
            //     ./validators.cue:21:5
            //     ./validators.cue:22:5
          }
        }
      }
      t2: (_|_){
        // [eval]
        Y: (_){ matchN(1, (#list){
            0: (_|_){// 〈1;X〉
            }
          }) }
        X: (struct){
          b?: (_){ matchN(1, (#list){
              0: (_|_){// 〈1;X〉
              }
            }) }
        }
        a: (_|_){
          // [eval]
          b: (_|_){
            // [eval] embed.openValidator.t2.a.b: conflicting values 1 and {b?:Y} (mismatched types int and struct):
            //     ./validators.cue:25:16
            //     ./validators.cue:26:5
            //     ./validators.cue:26:9
            //     ./validators.cue:27:5
            //     ./validators.cue:28:8
            // embed.openValidator.t2.a.b: invalid value 1 (does not satisfy matchN): 0 matched, expected 1:
            //     ./validators.cue:25:5
            //     ./validators.cue:25:12
            //     ./validators.cue:26:9
            //     ./validators.cue:28:8
          }
        }
      }
    }
    nestedValidator: (struct){
      #types: (#struct){
        z?: (list){ list.UniqueItems() }
      }
      x: (#struct){
        y: (#struct){
          z: (#list){
            0: (int){ 1 }
          }
        }
      }
      #def: (#struct){
      }
    }
  }
  and: (_|_){
    // [eval]
    transitive: (_|_){
      // [eval]
      ok: (struct){
        Z: (struct){
          a: (string){ string }
        }
        #Y: (#struct){
          a: (string){ string }
        }
        #X: (#struct){
          a: (string){ string }
        }
        out: (#struct){
          a: (string){ "foo" }
        }
      }
      err: (_|_){
        // [eval]
        Z: (struct){
          a: (string){ string }
        }
        #Y: (#struct){
          a: (string){ string }
        }
        #X: (#struct){
          a: (string){ string }
        }
        out: (_|_){
          // [eval]
          a: (string){ string }
          err: (_|_){
            // [eval] and.transitive.err.out.err: field not allowed:
            //     ./in.cue:42:5
            //     ./in.cue:43:6
            //     ./in.cue:44:6
            //     ./in.cue:44:11
            //     ./in.cue:45:7
            //     ./in.cue:46:3
          }
        }
      }
    }
    transitiveWithEmbed: (_|_){
      // [eval]
      ok: (struct){
        Z: (struct){
          a: (string){ string }
        }
        #X: (#struct){
          a: (string){ string }
        }
        #Y: (#struct){
          a: (string){ string }
        }
        out: (#struct){
          a: (string){ "foo" }
        }
      }
      err: (_|_){
        // [eval]
        Z: (struct){
          a: (string){ string }
        }
        #X: (#struct){
          a: (string){ string }
        }
        #Y: (#struct){
          a: (string){ string }
        }
        out: (_|_){
          // [eval]
          a: (string){ string }
          err: (_|_){
            // [eval] and.transitiveWithEmbed.err.out.err: field not allowed:
            //     ./in.cue:58:5
            //     ./in.cue:59:6
            //     ./in.cue:59:11
            //     ./in.cue:60:6
            //     ./in.cue:60:7
            //     ./in.cue:61:7
            //     ./in.cue:62:3
          }
        }
      }
    }
  }
  embedInline: (struct){
    #Schema: (#struct){
      a: (string){ "hello" }
      b: (#struct){
        c: (string){ "foo" }
        d: (string){ "never printed" }
      }
    }
    out: (#struct){
      a: (string){ "hello" }
      b: (#struct){
        c: (string){ "foo" }
        d: (string){ "never printed" }
      }
    }
  }
  issue3853: (struct){
    #Schema: (#struct){
      a: (string){ "hello" }
      b: (#struct){
        c: (string){ "foo" }
        d: (string){ "never printed" }
      }
    }
    out: (string){ "hello" }
  }
  issue3832: (#struct){
    _person: (struct){
      self: (struct){
        firstName: (string){ "Sam" }
      }
    }
    #T: (#struct){
      _subject: (#struct){
        in: (_){ _ }
        out: (#struct){
          let self#2 = (_|_){
            // [incomplete] issue3832.#T._subject.out.self: in.self undefined as in is incomplete (type _):
            //     ./issue3832.cue:8:16
          }
          outFirstName: (_|_){
            // [incomplete] issue3832.#T._subject.out.self: in.self undefined as in is incomplete (type _):
            //     ./issue3832.cue:8:16
          }
        }
      }
      _assert: (#struct){ |((#struct){
          pass: (string){ "never" }
          check!: (_){ _ }
        }, (#struct){
          pass: (#struct){
            let self#2 = (_|_){
              // [incomplete] issue3832.#T._assert.pass.self: in.self undefined (in is incomplete):
              //     ./issue3832.cue:8:16
            }
            outFirstName: (_|_){
              // [incomplete] issue3832.#T._assert.pass.self: in.self undefined (in is incomplete):
              //     ./issue3832.cue:8:16
            }
          }
          invoke!: (_){ _ }
        }) }
      results: (_|_){
        // [incomplete] issue3832.#T.results: unresolved disjunction {pass:"never",check!:_} | {pass:{let self#2=_|_(issue3832.#T._assert.pass.self: in.self undefined (in is incomplete)),outFirstName:_|_(issue3832.#T._assert.pass.self: in.self undefined (in is incomplete))},invoke!:_} (type struct):
        //     ./issue3832.cue:20:12
      }
    }
    _subject: (#struct){
      in: (_){ _ }
      out: (#struct){
        let self#2 = (_|_){
          // [incomplete] issue3832._subject.out.self: in.self undefined as in is incomplete (type _):
          //     ./issue3832.cue:8:16
        }
        outFirstName: (_|_){
          // [incomplete] issue3832._subject.out.self: in.self undefined as in is incomplete (type _):
          //     ./issue3832.cue:8:16
        }
      }
    }
    _assert: (#struct){
      pass: (#struct){
        let self#2 = (#struct){
          firstName: (string){ "Sam" }
        }
        outFirstName: (string){ "Sam" }
      }
      invoke: (struct){
        self: (struct){
          firstName: (string){ "Sam" }
        }
      }
    }
    results: (#struct){
      let self#2 = (#struct){
        firstName: (string){ "Sam" }
      }
      outFirstName: (string){ "Sam" }
    }
  }
  issue3833: (struct){
    ok: (struct){
      out: (#struct){
        a: (#struct){
          b: (string){ "foo" }
          c: (string){ "foo" }
        }
      }
      #A: (#struct){
        a: (#struct){
          b: (string){ string }
        }
      }
      #C: (#struct){
        c: (string){ string }
      }
      #B: (#struct){
        c: (string){ "foo" }
        b: (string){ "foo" }
      }
    }
    evalv2Issue: (struct){
      out: (#struct){
        a: (#struct){
          b: (string){ "foo" }
          c: (string){ "foo" }
        }
      }
      #A: (#struct){
        a: (#struct){
          b: (string){ string }
        }
      }
      #C: (#struct){
        c: (string){ string }
      }
      #B: (#struct){
        c: (string){ "foo" }
        b: (string){ "foo" }
      }
    }
  }
  issue3837: (struct){
    reduced: (struct){
      A: (#struct){
        extra: (string){ "foo" }
      }
      out: (struct){
        x: (#struct){
          extra: (string){ "foo" }
        }
      }
      #Embed: (#struct){
      }
    }
    full: (struct){
      #Embed: (#struct){
      }
      #A: (#struct){
        extra: (string){ "foo" }
      }
      #B: (#struct){ |((#struct){
          bar: (string){ string }
        }, (#struct){
        }) }
      #C: (#struct){
        bar: (string){ string }
      }
      out: (#struct){
        bar: (string){ "baz" }
        #def: (#struct){
          extra: (string){ "foo" }
        }
      }
    }
  }
  issue3839: (struct){
    reduced: (struct){
      x: (#struct){
        y: (int){ 1 }
      }
      #B: (#struct){
      }
      A: (#struct){
      }
    }
    full: (struct){
      _globals: (struct){
        glb: (struct){
          globalField: (string){ "" }
        }
      }
      #GlobalContext: (#struct){
        globalField: (string){ string }
      }
      #Context: (#struct){
        glb: (#struct){
          globalField: (string){ string }
        }
        out: (#struct){
          globalField: (string){ string }
        }
      }
      out: (struct){
        ingress: (#struct){
          #def: (#struct){
            globalField: (string){ "" }
          }
          foo: (int){ 1234 }
          bar: (string){ "http" }
        }
      }
      #Embed: (#struct){
        #def: (#struct){
        }
      }
      #Ingress: (#struct){
        #def: (#struct){
        }
      }
    }
  }
  dedupPattern: (struct){
    t1: (struct){
      p1: (struct){
        A: (struct){
          #Z: (#struct){
          }
          x: (#struct){
            y: (struct){
              z: (int){ 1 }
            }
          }
        }
        B: (struct){
          #Z: (#struct){
          }
          x: (#struct){
            y: (struct){
              z: (int){ 1 }
            }
          }
        }
        out: (#struct){
          y: (struct){
            z: (int){ 1 }
          }
        }
      }
      p2: (struct){
        A: (struct){
          #Z: (#struct){
          }
          x: (#struct){
            y: (struct){
              z: (int){ 1 }
            }
          }
        }
        B: (struct){
          #Z: (#struct){
          }
          x: (#struct){
            y: (struct){
              z: (int){ 1 }
            }
          }
        }
        out: (#struct){
          y: (struct){
            z: (int){ 1 }
          }
        }
      }
    }
  }
  orig: (struct){
    t1: (#struct){
      #Image: (#struct){
        embed: (#struct){
          image: (string){ "foo:v1" }
        }
      }
      #JobConfig: (#struct){
        image: (#struct){
          embed: (#struct){
            image: (string){ "foo:v1" }
          }
        }
        job: (#struct){
          image: (string){ "foo:v1" }
          vcs: (string){ "git" }
          args: (list){
          }
          env: (#struct){
          }
        }
      }
      #Job: (#struct){
        image: (string){ string }
        vcs: (string){ "git" }
        args: (list){
        }
        env: (#struct){
        }
      }
      #Output: (#struct){
        _in: (_){ _ }
        out: (#struct){
        }
      }
      _in: (#struct){
        image: (string){ "foo:v1" }
        vcs: (string){ "git" }
        args: (list){
        }
        env: (#struct){
        }
      }
      out: (#struct){
        image: (string){ "foo:v1" }
        vcs: (string){ "git" }
        args: (list){
        }
        env: (#struct){
        }
      }
    }
    t2: (struct){
      #JobConfig: (#struct){
        image: (#struct){
          spec: (#struct){
            image: (string){ "someimage" }
          }
        }
        job: (#struct){
          image: (string){ "someimage" }
          env: (string){ "FOO" }
        }
      }
      #Job: (#struct){
        image: (string){ string }
        env: (string){ "FOO" }
      }
      #Output: (#struct){
        in: (_){ _ }
        out: (_|_){
          // [incomplete] orig.t2.#Output.out: undefined field: input:
          //     ./issue3858.cue:55:18
        }
      }
      out: (#struct){
        in: (struct){
          input: (#struct){
            image: (string){ "someimage" }
            env: (string){ "FOO" }
          }
        }
        out: (#struct){
          image: (string){ "someimage" }
          env: (string){ "FOO" }
        }
      }
    }
  }
  reduced: (struct){
    t1: (#struct){
      Y: (struct){
        a: (struct){
          e: (string){ "foo" }
        }
        b: (struct){
          e: (string){ "foo" }
          f: (int){ 1 }
        }
      }
      X: (struct){
        e: (string){ string }
        f: (int){ 1 }
      }
      #Z: (#struct){
        _in: (_){ _ }
        out: (_){ _ }
      }
      _in: (struct){
        a: (struct){
          e: (string){ "foo" }
        }
        b: (struct){
          e: (string){ "foo" }
          f: (int){ 1 }
        }
      }
      out: (#struct){
        a: (#struct){
          e: (string){ "foo" }
        }
        b: (#struct){
          e: (string){ "foo" }
          f: (int){ 1 }
        }
      }
    }
    t2: (#struct){
      Y: (struct){
        a: (struct){
          e: (string){ "foo" }
        }
        b: (struct){
          e: (string){ "foo" }
          f: (int){ 1 }
        }
      }
      X: (struct){
        e: (string){ string }
        f: (int){ 1 }
      }
      #Z: (#struct){
        _in: (_){ _ }
        out: (_){ _ }
      }
      _in: (struct){
        a: (struct){
          e: (string){ "foo" }
        }
        b: (struct){
          e: (string){ "foo" }
          f: (int){ 1 }
        }
      }
      out: (#struct){
        a: (#struct){
          e: (string){ "foo" }
        }
        b: (#struct){
          e: (string){ "foo" }
          f: (int){ 1 }
        }
      }
    }
  }
  issue3934: (struct){
    out: (#struct){
      foo: ((null|struct)){ |(*(#struct){
          bar: (int){ 3 }
        }, (#struct){
          extra?: ((null|struct)){ |((null){ null }, (#struct){
            }) }
          bar?: (int){ int }
        }, (null){ null }) }
    }
    #Foo: (#struct){
      foo?: ((null|struct)){ |(*(#struct){
          bar: (int){ 3 }
        }, (#struct){
          bar?: (int){ int }
          extra?: ((null|struct)){ |((null){ null }, (#struct){
            }) }
        }, (null){ null }) }
    }
    #Bar: (#struct){
      bar?: (int){ int }
      extra?: ((null|struct)){ |((null){ null }, (#struct){
        }) }
    }
  }
  issue3964: (struct){
    reduced: (struct){
      #Output: (#struct){
        name: (string){ string }
      }
      #Embedded: (#struct){
        name: (string){ string }
      }
      #Unused: (#struct){
      }
      #Used: (#struct){
      }
    }
    full: (struct){
      out: (#struct){
        name: (string){ "oauth2" }
        used: (string){ "bar" }
      }
      #Output: (#struct){ |((#struct){
          name: (string){ string }
          unused: (string){ string }
        }, (#struct){
          name: (string){ string }
          used: (string){ string }
        }) }
      #Embedded: (#struct){ |((#struct){
          name: (string){ string }
          unused: (string){ string }
        }, (#struct){
          name: (string){ string }
          used: (string){ string }
        }) }
      #Unused: (#struct){
        unused: (string){ string }
      }
      #Used: (#struct){
        used: (string){ string }
      }
    }
  }
  full: (struct){
    #Resource: (#struct){
      someMsg: (string){ string }
      obs: (#struct){ |(*(#struct){
          missing: (bool){ true }
        }, (#struct){
        }) }
      let pickMsg#3 = (#struct){
        msg: (_|_){
          // [incomplete] full.#Resource.pickMsg.msg: invalid interpolation: non-concrete value string (type string):
          //     ./large.cue:7:25
          //     ./large.cue:3:12
        }
      }
      patches: (#list){
        0: (#struct){
          op: (string){ "add" }
          path: (string){ "/metadata" }
          value: (_|_){
            // [incomplete] full.#Resource.patches.0.value: invalid interpolation: non-concrete value string (type string):
            //     ./large.cue:7:25
            //     ./large.cue:3:12
          }
        }
      }
    }
    #Patches: (#struct){
    }
    #JSONPatch: (#struct){
      namespace?: (string){ string }
      patch: (list){
      }
      output: (_|_){
        // [incomplete] full.#JSONPatch.output: cannot reference optional field: namespace:
        //     ./large.cue:21:24
      }
    }
    #JSONOp: (#struct){ |((#struct){
        op: (string){ "add" }
        path: (string){ string }
        value: (_){ _ }
      }, (#struct){
        op: (string){ "remove" }
        path: (string){ string }
      }) }
    #Main: (#struct){
      namespace: (string){ string }
      output: (_|_){
        // [incomplete] full.#Main.output: invalid non-ground value string (must be concrete string):
        //     ./large.cue:19:15
        //     ./large.cue:41:15
        _: (#list){
          0: (#struct){
            op: (string){ "add" }
            path: (string){ "/metadata" }
            value: (string){ "foo" }
          }
        }
      }
      let jsonPatch#4 = (#struct){
        namespace: (string){ string }
        patch: (#list){
          0: (#struct){
            op: (string){ "add" }
            path: (string){ "/metadata" }
            value: (string){ "foo" }
          }
        }
        output: (_|_){
          // [incomplete] full.#Main.jsonPatch.output: invalid non-ground value string (must be concrete string):
          //     ./large.cue:19:15
          //     ./large.cue:41:15
          _: (#list){
            0: (#struct){
              op: (string){ "add" }
              path: (string){ "/metadata" }
              value: (string){ "foo" }
            }
          }
        }
        let base#7 = (#struct){
          someMsg: (string){ string }
          obs: (#struct){ |(*(#struct){
              missing: (bool){ true }
            }, (#struct){
            }) }
          let pickMsg#3 = (#struct){
            msg: (_|_){
              // [incomplete] full.#Main.jsonPatch.base.pickMsg.msg: invalid interpolation: non-concrete value string (type string):
              //     ./large.cue:7:25
              //     ./large.cue:3:12
            }
          }
          patches: (#list){
            0: (#struct){
              op: (string){ "add" }
              path: (string){ "/metadata" }
              value: (_|_){
                // [incomplete] full.#Main.jsonPatch.base.patches.0.value: invalid interpolation: non-concrete value string (type string):
                //     ./large.cue:7:25
                //     ./large.cue:3:12
              }
            }
          }
        }
        let withMsg#8 = (#struct){
          someMsg: (string){ "foo" }
          obs: (#struct){ |(*(#struct){
              missing: (bool){ true }
            }, (#struct){
            }) }
          let pickMsg#3 = (#struct){
            msg: (string){ "foo" }
          }
          patches: (#list){
            0: (#struct){
              op: (string){ "add" }
              path: (string){ "/metadata" }
              value: (string){ "foo" }
            }
          }
        }
      }
    }
    out: (#struct){
      ns1: (#list){
        0: (#struct){
          op: (string){ "add" }
          path: (string){ "/metadata" }
          value: (string){ "foo" }
        }
      }
    }
  }
  disjunction: (struct){
    withErr: (struct){
      t1: (struct){
        params: (struct){
        }
        out: (#struct){
          b1: (_|_){
            // [incomplete] disjunction.withErr.t1.out.b1: 4 errors in empty disjunction:
            // disjunction.withErr.t1.out.b1: conflicting values null and {b2:{b3:params.mayExistLater}} (mismatched types null and struct):
            //     ./validators.cue:33:7
            //     ./validators.cue:35:17
            // disjunction.withErr.t1.out.b1.b2: 2 errors in empty disjunction:
            // disjunction.withErr.t1.out.b1.b2: conflicting values null and {b3:params.mayExistLater} (mismatched types null and struct):
            //     ./validators.cue:33:11
            //     ./validators.cue:36:17
            // disjunction.withErr.t1.out.b1.b2.b3: undefined field: mayExistLater:
            //     ./validators.cue:33:22
            b2: (_|_){
              // [incomplete] disjunction.withErr.t1.out.b1.b2: 2 errors in empty disjunction:
              // disjunction.withErr.t1.out.b1.b2: conflicting values null and {b3:params.mayExistLater} (mismatched types null and struct):
              //     ./validators.cue:33:11
              //     ./validators.cue:36:17
              // disjunction.withErr.t1.out.b1.b2.b3: undefined field: mayExistLater:
              //     ./validators.cue:33:22
              b3: (_|_){
                // [incomplete] disjunction.withErr.t1.out.b1.b2.b3: undefined field: mayExistLater:
                //     ./validators.cue:33:22
              }
            }
          }
        }
        #Schema1: (#struct){
          b1?: ((null|struct)){ |((null){ null }, (#struct){
              b2?: ((null|struct)){ |((null){ null }, (#struct){
                  b3?: (string){ string }
                }) }
            }) }
        }
        #Schema2: (#struct){
          b2?: ((null|struct)){ |((null){ null }, (#struct){
              b3?: (string){ string }
            }) }
        }
      }
    }
  }
}
-- out/compile --
--- chaineddef.cue
{
  issue3920: {
    out: {
      〈1;#A〉
      a: {
        b: "out"
      }
    }
    #A: {
      a?: 〈1;#B〉
    }
    #B: {
      c?: string
    }
  }
  onlyCloseDirectStruct: {
    #foo: {}
    x: {
      y: {
        {
          a: 〈3;#foo〉
        }
      }
    }
    x: {
      y: {
        b: 1
      }
    }
  }
  closeInEmbed: {
    x: {
      close({
        {
          ["d"]: {
            f: int
          }
        }
      })
    }
    x: {
      d: {
        e: 1
      }
    }
  }
}
--- cycle.cue
{
  issue4006: {
    #A: {
      〈1;#B〉
      fieldA: string
    }
    #B: {
      〈1;#A〉
    }
    #C: (〈0;#A〉 & {})
    out: (〈0;#C〉 & 〈0;#B〉)
  }
}
--- disjunction.cue
{
  issue3947: {
    full: {
      #Schema: {
        allowed?: string
      }
      _defaults: {
        disallowed: (_|*"default value")
      }
      out: (〈0;#Schema〉 & 〈0;_defaults〉)
    }
  }
  issue3957: {
    reduced: {
      c: {
        a: "bar"
      }
      c: (〈0;#B〉 & {
        a: (string|*"foo")
      })
      #B: {
        b?: string
      }
    }
  }
  issue3957: {
    full: {
      #oneof: ({
        a: string
      }|{
        b?: [
          ...string,
        ]
      })
      c: (〈0;#oneof〉 & {
        a: (string|*"foo")
      })
      c: {
        a: "bar"
      }
    }
  }
  issue3957: {
    derived: {
      t1: {
        #Schema: {
          in: (string|[
            ...string,
          ])
          out: 〈import;list〉.FlattenN([
            〈1;in〉,
          ], 1)
        }
        x: (〈0;#Schema〉 & {
          in: "foo"
        })
      }
    }
  }
  issue3957: {
    derived: {
      t2: {
        #Schema: {
          in: (string|[
            ...string,
          ])
          let _flat#1 = 〈import;list〉.FlattenN([
            〈1;in〉,
          ], 1)
          out: 〈0;let _flat#1〉
        }
        out: (〈0;#Schema〉 & {
          in: "foo"
        })
      }
    }
  }
}
--- ellipsis.cue
{
  nestedEllipsis: {
    minimal: {
      out: (〈0;#Schema〉 & {
        extra: "foo"
      })
      #Schema: {
        〈1;#meta〉
        ...
      }
      #meta: {}
    }
  }
  nestedEllipsis: {
    nestedWithPatterns: {
      out: (〈0;#Schema〉 & {
        objs: {
          obj1: {
            extra: "foo"
          }
        }
      })
      #Schema: {
        [_]: {
          [_]: {
            〈2;#meta〉
            ...
          }
        }
        #meta: {
          name?: int
        }
        objs?: _
      }
    }
  }
  issue4015: {
    reduced: {
      #X: {
        ...
      }
      out: {
        〈1;#X〉
        a: {
          b: string
        }
      }
      out: {
        a: {
          c: "h"
          b: "x"
        }
      }
    }
  }
  issue4015: {
    nested: {
      #X: {
        foo: {
          ...
        }
      }
      out: {
        〈1;#X〉
        foo: {
          a: {
            b: string
          }
        }
      }
      out: {
        foo: {
          a: {
            c: "h"
            b: "x"
          }
        }
      }
    }
  }
  issue4015: {
    full: {
      #Schema: {
        cfg: {
          foo: {
            enabled: (bool|*false)
            fooField: string
          }
          bar: {
            barField: string
          }
        }
        capacity: (int|*3)
      }
      #MoreCapacity: {
        capacity: 30
        ...
      }
      out: 〈0;#Schema〉
      out: {
        〈1;#MoreCapacity〉
        cfg: {
          foo: {
            enabled: true
          }
        }
      }
      out: {
        cfg: {
          foo: {
            fooField: "h"
          }
          bar: {
            barField: "x"
          }
        }
      }
    }
  }
}
--- embedelim.cue
{
  issue3921: {
    top: {
      #A: 〈0;#B〉
      #A: {
        b: string
      }
      #B: _
      a: {
        (〈1;#A〉 & {})
      }
    }
  }
  issue3921: {
    hidden: {
      #A: 〈0;#B〉
      #A: {
        _hidden: {
          b: string
        }
      }
      #B: {}
      a: {
        (〈1;#A〉 & {
          _hidden: {}
        })
      }
    }
  }
  issue3921: {
    full: {
      out: (〈0;#templateList〉 & 〈0;#defineMap〉)
      #templateList: {
        #stepMap: {
          [string]: _
        }
        stepList: [
          for _, c in 〈1;#stepMap〉 {
            〈1;c〉
          },
        ]
      }
      #defineMap: {
        #stepMap: {
          foo: (〈2;#Step〉 & {
            image: "bar"
            #config: {}
          })
        }
        stepList: _
      }
      #Step: (〈0;#StepInner〉 & {
        image: string
        #config: {
          version: string
        }
      })
      #StepInner: {
        image: string
      }
    }
  }
}
--- in.cue
{
  embed: {
    simple: {
      #A: {
        b: 1
      }
      a: {
        〈1;#A〉
      }
      a: {
        err: 1
      }
    }
  }
  embed: {
    andInStruct: {
      #Foo: {
        a: int
      }
      a: {
        (〈1;#Foo〉 & {
          err: 2
        })
      }
    }
  }
  embed: {
    embedDefWithEmbedding: {
      #Foo: {
        {
          a: int
        }
      }
      a: {
        (〈1;#Foo〉 & {
          err: 2
        })
      }
    }
  }
  embed: {
    embedComprehension: {
      #Foo: {
        if true {
          a: int
        }
      }
      a: {
        (〈1;#Foo〉 & {
          err: 2
        })
      }
    }
  }
  embed: {
    fieldWithAnd: {
      #A: {}
      {
        a: (〈1;#A〉 & {
          err: 3
        })
      }
    }
  }
  embed: {
    embedAndRecursive: {
      #A: {
        a: int
      }
      B: {
        x: 〈1;#A〉
      }
      (〈0;B〉 & {
        x: {
          err: 2
        }
      })
    }
  }
  embed: {
    andEmbed: {
      #A: {
        b: int
      }
      #B: {
        b: int
      }
      #D: {
        (〈1;#A〉 & 〈1;#B〉)
      }
      d: (〈0;#D〉 & {
        err: 3
      })
    }
  }
  and: {
    transitive: {
      ok: {
        Z: {
          a: string
        }
        #Y: 〈0;Z〉
        #X: (〈0;#Y〉 & 〈0;Z〉)
        out: (〈0;#X〉 & {
          a: "foo"
        })
      }
    }
  }
  and: {
    transitive: {
      err: {
        Z: {
          a: string
        }
        #Y: 〈0;Z〉
        #X: (〈0;#Y〉 & 〈0;Z〉)
        out: (〈0;#X〉 & {
          err: "foo"
        })
      }
    }
  }
  and: {
    transitiveWithEmbed: {
      ok: {
        Z: {
          a: string
        }
        #X: (〈0;#Y〉 & 〈0;Z〉)
        #Y: {
          〈1;Z〉
        }
        out: (〈0;#X〉 & {
          a: "foo"
        })
      }
    }
  }
  and: {
    transitiveWithEmbed: {
      err: {
        Z: {
          a: string
        }
        #X: (〈0;#Y〉 & 〈0;Z〉)
        #Y: {
          〈1;Z〉
        }
        out: (〈0;#X〉 & {
          err: "foo"
        })
      }
    }
  }
  embed: {
    nonDef: {
      t1: {
        X: {
          a: string
        }
        #Y: (〈0;#Z〉 & 〈0;X〉)
        #Z: {
          〈1;X〉
          b?: string
        }
      }
    }
  }
  embed: {
    defAndHidden: {
      full: {
        _stepCommon: {
          Name: string
        }
        #Step: (〈0;#Command〉 & 〈0;_stepCommon〉)
        #Command: {
          〈1;_stepCommon〉
          Path?: string
        }
        out: (〈0;#Step〉 & {
          Name: "foo"
        })
      }
    }
  }
  embed: {
    withIndirect: {
      A: 〈0;#B〉
      #B: {
        b: int
      }
      (〈0;A〉 & {
        err: 2
      })
    }
  }
}
--- inline.cue
{
  embedInline: {
    #Schema: {
      a: "hello"
      b: {
        {
          x: {
            c: "foo"
          }
        }.x
      }
      b: {
        c: string
        d: "never printed"
      }
    }
    out: (〈0;#Schema〉 & _|_(no sharing))
  }
  issue3853: {
    #Schema: {
      a: "hello"
      b: {
        {
          x: {
            c: "foo"
          }
        }.x
      }
      b: {
        c: string
        d: "never printed"
      }
    }
    out: {
      x: (〈1;#Schema〉 & {}).a
    }.x
  }
}
--- issue3832.cue
{
  issue3832: {
    _person: {
      self: {
        firstName: "Sam"
      }
    }
    #T: {
      _subject: {
        in: _
        out: {
          let self#2 = 〈1;in〉.self
          outFirstName: 〈0;let self#2〉.firstName
        }
      }
      _assert: {
        pass: _
      }
      _assert: ({
        check!: _
        pass: "never"
      }|{
        invoke!: _
        pass: (〈1;_subject〉 & {
          in: 〈1;invoke〉
        }).out
      })
      results: 〈0;_assert〉.pass
    }
    (〈0;#T〉 & {
      _assert: {
        invoke: 〈2;_person〉
      }
    })
  }
}
--- issue3833.cue
{
  issue3833: {
    ok: {
      out: {
        (〈1;#A〉 & {
          a: 〈2;#B〉
        })
      }
      #A: {
        a: {
          b: string
          ...
        }
        ...
      }
      #C: {
        c: string
      }
      #B: {
        (〈1;#C〉 & {
          c: "foo"
        })
        b: "foo"
      }
    }
  }
  issue3833: {
    evalv2Issue: {
      out: {
        (〈1;#A〉 & {
          a: 〈2;#B〉
        })
      }
      #A: {
        a: {
          b: string
        }
        ...
      }
      #C: {
        c: string
      }
      #B: {
        (〈1;#C〉 & {
          c: "foo"
        })
        b: "foo"
      }
    }
  }
}
--- issue3837.cue
{
  issue3837: {
    reduced: {
      A: {
        〈1;#Embed〉
        extra: "foo"
      }
      out: {
        {
          x: (〈2;A〉 & _|_(no sharing))
        }
      }
      #Embed: {}
    }
  }
  issue3837: {
    full: {
      #Embed: {}
      #A: {
        〈1;#Embed〉
        extra: "foo"
      }
      #B: (〈0;#C〉|{})
      #C: {
        bar: string
      }
      out: (〈0;#B〉 & {
        bar: "baz"
        {
          #def: (〈2;#A〉 & _|_(no sharing))
        }
      })
    }
  }
}
--- issue3839.cue
{
  issue3839: {
    reduced: {
      x: {
        (〈1;A〉 & _|_(no sharing))
      }
      x: {
        y: 1
      }
      #B: {}
      A: {
        〈1;#B〉
        ...
      }
    }
  }
  issue3839: {
    full: {
      _globals: {
        glb: {
          globalField: ""
        }
      }
      #GlobalContext: {
        globalField: string
      }
      #Context: {
        glb: 〈1;#GlobalContext〉
        out: 〈0;glb〉
      }
      out: {
        ingress: {
          (〈2;#Ingress〉 & {
            #def: (〈3;#Context〉 & 〈3;_globals〉).out
          })
        }
        ingress?: {
          foo: 1234
          bar: "http"
        }
      }
      #Embed: {
        #def: {
          ...
        }
      }
      #Ingress: {
        〈1;#Embed〉
        ...
      }
    }
  }
}
--- issue3843.cue
{
  dedupPattern: {
    t1: {
      p1: {
        A: {
          #Z: {
            [string]: _
          }
          x: 〈0;#Z〉
          x: {
            y: {
              z: 1
            }
          }
        }
        B: (〈0;A〉 & _|_(no sharing))
        out: (〈0;A〉.#Z & 〈0;B〉.x)
      }
    }
  }
  dedupPattern: {
    t1: {
      p2: {
        A: {
          #Z: {
            [string]: _
          }
          x: 〈0;#Z〉
          x: {
            y: {
              z: 1
            }
          }
        }
        B: (〈0;A〉 & _|_(no sharing))
        out: (〈0;B〉.x & 〈0;A〉.#Z)
      }
    }
  }
}
--- issue3858.cue
{
  orig: {
    t1: {
      #Image: {
        embed: {
          image: "foo:v1"
        }
      }
      #JobConfig: {
        image: 〈1;#Image〉
        job: (〈1;#Job〉 & {
          〈1;image〉.embed
        })
      }
      #Job: {
        image: string
        vcs: "git"
        args: [
          ...string,
        ]
        env: {
          [string]: string
        }
      }
      #Output: {
        _in: _
        out: (〈0;_in〉 & {})
      }
      (〈0;#Output〉 & {
        _in: (〈1;#JobConfig〉 & {}).job
      })
    }
  }
  reduced: {
    t1: {
      Y: {
        a: {
          e: "foo"
        }
        b: (〈1;X〉 & {
          〈1;a〉
        })
      }
      X: {
        e: string
        f: 1
      }
      #Z: {
        _in: _
        out: (〈0;_in〉 & _|_(no sharing))
      }
      (〈0;#Z〉 & {
        _in: 〈1;Y〉
      })
    }
  }
  orig: {
    t2: {
      #JobConfig: {
        image: {
          spec: {
            image: "someimage"
          }
        }
        job: (〈1;#Job〉 & {
          〈1;image〉.spec
        })
      }
      #Job: {
        image: string
        env: "FOO"
      }
      #Output: {
        in: _
        out: (〈0;in〉 & {}).input
      }
      out: (〈0;#Output〉 & {
        in: {
          input: (〈2;#JobConfig〉 & {}).job
        }
      })
    }
  }
  reduced: {
    t2: {
      Y: {
        a: {
          e: "foo"
        }
        b: (〈1;X〉 & {
          〈1;a〉
        })
      }
      X: {
        e: string
        f: 1
      }
      #Z: {
        _in: _
        out: 〈0;_in〉
      }
      (〈0;#Z〉 & {
        _in: 〈1;Y〉
      })
    }
  }
}
--- issue3934.cue
{
  issue3934: {
    out: (〈0;#Foo〉 & {
      foo: {
        if false {
          extra: {
            nested: 123
          }
        }
      }
    })
    #Foo: {
      foo?: (null|〈1;#Bar〉|*{
        bar: 3
      })
    }
    #Bar: {
      bar?: int
      extra?: (null|{
        ...
      })
    }
  }
}
--- issue3964.cue
{
  issue3964: {
    reduced: {
      #Output: {
        〈1;#Embedded〉
      }
      #Embedded: {
        name: string
        (〈1;#Unused〉|〈1;#Used〉)
      }
      #Unused: {}
      #Used: {}
    }
  }
  issue3964: {
    full: {
      out: (〈0;#Output〉 & {
        name: "oauth2"
        used: "bar"
      })
      #Output: {
        〈1;#Embedded〉
      }
      #Embedded: {
        name: string
        (〈1;#Unused〉|〈1;#Used〉)
      }
      #Unused: {
        unused: string
      }
      #Used: {
        used: string
      }
    }
  }
}
--- large.cue
{
  full: {
    #Resource: {
      someMsg: string
      obs: ({}|*{
        missing: true
      })
      let pickMsg#3 = [
        if 〈1;obs〉.missing {
          msg: "\(〈2;someMsg〉)"
        },
        {
          msg: "bar"
        },
      ][0]
      patches: [
        {
          op: "add"
          path: "/metadata"
          value: 〈2;let pickMsg#3〉.msg
        },
      ]
    }
    #Patches: {
      [string]: _
    }
    #JSONPatch: {
      namespace?: string
      patch: [
        ...〈2;#JSONOp〉,
      ]
      output: (〈1;#Patches〉 & {
        〈1;namespace〉: 〈1;patch〉
      })
    }
    #JSONOp: ({
      op: "add"
      path: string
      value: _
    }|{
      op: "remove"
      path: string
    })
    #Main: {
      namespace: string
      output: 〈0;let jsonPatch#4〉.output
      let jsonPatch#4 = (〈1;#JSONPatch〉 & {
        let base#7 = (〈2;#Resource〉 & {})
        let withMsg#8 = (〈0;let base#7〉 & {
          someMsg: "foo"
        })
        namespace: 〈1;namespace〉
        patch: 〈0;let withMsg#8〉.patches
      })
    }
    out: (〈0;#Main〉 & {
      namespace: "ns1"
    }).output
  }
}
--- validators.cue
{
  embed: {
    normalValidator: {
      #X: {
        〈import;struct〉.MaxFields(1)
        a?: int
        b?: int
      }
      x: 〈0;#X〉
      x: {
        err: 1
      }
    }
  }
  embed: {
    openValidator: {
      t1: {
        #X: {
          matchN(0, [])
          a?: int
          b?: int
        }
        x: 〈0;#X〉
        x: {
          err: 1
        }
      }
    }
  }
  embed: {
    openValidator: {
      t2: {
        Y: matchN(1, [
          〈1;X〉,
        ])
        X: {
          b?: 〈1;Y〉
        }
        a: 〈0;X〉
        a: {
          b: 1
        }
      }
    }
  }
  disjunction: {
    withErr: {
      t1: {
        params: {}
        out: (〈0;#Schema1〉 & {
          b1: {
            b2: {
              b3: 〈3;params〉.mayExistLater
            }
          }
        })
        #Schema1: {
          b1?: (null|〈1;#Schema2〉)
        }
        #Schema2: {
          b2?: (null|{
            b3?: string
          })
        }
      }
    }
  }
  embed: {
    nestedValidator: {
      #types: {
        z?: 〈import;list〉.UniqueItems
      }
      x: {
        y: {
          z: [
            1,
          ]
        }
      }
      x: {
        〈1;#def〉
        y?: 〈1;#types〉
      }
      #def: {}
    }
  }
}
