// These tests are related to issue 2351.

-- in.cue --

// TODO: fix this test
conjunct: t1: {
	#early: *"X" | string
	#early
} & {
	#early: *"X" | string
	string
}

conjunct: t2: {
	#early: *"X" | string
	#early
}
conjunct: t2: {
	#early: *"X" | string
	string
}

conjunct: t3: conjunct.t1 & conjunct.t2

handleComprehensions: {
	if false {
		subs: #sub2 & 2
	}
	#sub2: 2
}
-- out/eval/stats --
Leaks:  0
Freed:  43
Reused: 35
Allocs: 8
Retain: 0

Unifications: 11
Conjuncts:    71
Disjuncts:    43
-- out/eval --
(struct){
  conjunct: (struct){
    t1: (string){ |(*(string){
        "X"
        #early: (string){ |(*(string){ "X" }, (string){ string }) }
      }, (string){
        string
        #early: (string){ |(*(string){ "X" }, (string){ string }) }
      }) }
    t2: (string){ |(*(string){
        "X"
        #early: (string){ |(*(string){ "X" }, (string){ string }) }
      }, (string){
        string
        #early: (string){ |(*(string){ "X" }, (string){ string }) }
      }) }
    t3: (_|_){
      // [incomplete] conjunct.t3: 2 errors in empty disjunction:
      // conjunct.t3: cannot add field #early: was already used:
      //     ./in.cue:7:2
      // conjunct.t3: cannot add field #early: was already used:
      //     ./in.cue:16:2
      #early: (string){ |(*(string){ "X" }, (string){ string }) }
    }
  }
  handleComprehensions: (struct){
    #sub2: (int){ 2 }
  }
}
-- out/compile --
--- in.cue
{
  conjunct: {
    t1: ({
      #early: (*"X"|string)
      〈0;#early〉
    } & {
      #early: (*"X"|string)
      string
    })
  }
  conjunct: {
    t2: {
      #early: (*"X"|string)
      〈0;#early〉
    }
  }
  conjunct: {
    t2: {
      #early: (*"X"|string)
      string
    }
  }
  conjunct: {
    t3: (〈1;conjunct〉.t1 & 〈1;conjunct〉.t2)
  }
  handleComprehensions: {
    if false {
      subs: (〈1;#sub2〉 & 2)
    }
    #sub2: 2
  }
}
