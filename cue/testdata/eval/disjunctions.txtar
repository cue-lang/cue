-- in.cue --
a:  *1 | int
aa: *1 | *2 | int

b: {
	name: "int"
	val:  int
} | {
	name: "str"
	val:  string
}

d: b & {val:  3}
c: b & {name: "int", val: 3}
e: b & {val:  "foo"}
f: b & {name: "str", val: 3}

// Disjunct elimination based on type.
e1: {
	a: null | {bar: 2}
	b: (a & {}).bar
}

d1: {
	a: (null | {c:      1}) & {}
	b: {} & (null | {c: 1})
}

d2: {
	a: ([...] | {c:      1}) & {}
	b: {} & ([...] | {c: 1})
}

d3: {
	a: (string | {c:      1}) & {}
	b: {} & (string | {c: 1})
}

d4: {
	a: (string | {c:      1}) & {}
	b: {} & (string | {c: 1})
}

d5: {
	a: (number | {c:      1}) & {}
	b: {} & (number | {c: 1})
}

d6: {
	a: (int | {c:      1}) & {}
	b: {} & (int | {c: 1})
}

t10: {
	schema: test
	schema: string | {name: string}
	#A: {string | {name: string}}

	test: name: "Test"
	test: #A
}

t10: {
	schema: string | {name: string}
	schema: test
	#A: {string | {name: string}}

	test: name: "Test"
	test: #A
}

t10: {
	#A: {string | {name: string}}

	test: name: "Test"
	test: #A

	schema: string | {name: string}
	schema: test
}

t11: {
	a: #A
	a: b

	b:  #A & ["b"]
	#A: ["a" | "b"] | {}
}

t11: {
	b:  #A & ["b"]
	#A: ["a" | "b"] | {}

	a: b
	a: #A
}

cross: {
	a: *"word" | string
	a: string | *"word"
}

d100: {
	// Should we allow a selector to imply a struct or list? Would be convenient.
	// This would be a spec change. Disallow for now.
	i: null | {bar: 2}
	j: i.bar
}

issue641: {
	#A: {
		type: "a"
		x:    ""
	}

	#B: {
		type: "b"
		x:    string
	}

	#C: {
		b: #A | #B
	}

	e: [string]: #C & {
		b: #A | #B
	}

	e: foobar: #C & {
		b: #B & {
			x: "foobar"
		}
	}
}
-- issue3406.cue --
issue3406: {
	out: d & { d }
	d: kind: "foo" | "bar"
	d: { kind: "foo" } | { kind: "bar" }
}
-- issue3411.cue --
issue3411: {
	x: y?: [...string]
	x: {y: ["foo"]} | *{y: ["bar"]}
}
-- issue3490.cue --
issue3490: nested: p1: {
	("a"|"b") | "b"
	"a"|"b"
}
issue3490: nested: p2: {
	"a"|"b"
	("a"|"b") | "b"
}
issue3490: full: {
	data: [...#Schema]
	data: [#Schema & {}]
	#Schema: {
		runs?: "foo" | ([#D1] | [#D1, #D2])
		#D1: "d1"
		#D2: "d2"
	}
}
-- issue3434.cue --
issue3434: t1: {
	({} | {})
	{["x"]: 1}
	{["y"]: 2}
}
issue3434: full: {
	out: #Schema & {
		steps: [{run: "example"}]
	}
	#Schema: {
		steps: [...{run: string}]
		#matrixConfig: string | [...#matrixConfig]
		matrix?: ({...} | string) & {
			{[=~"^foo"]: [...{[string]: #matrixConfig}]}
			{[=~"^bar"]: [...#matrixConfig] | string}
		}
	}
}
-- issue3597.cue --
issue3597: t1: {
	#Schema: {
		_ok: bool
		{} | {
			_ok: true
			let Ok = _ok
			{} | {x: Ok}
		}
	}

	[string]: #Schema

	foo: bar
	bar: {}
}
issue3597: t2: {
	ok: true
	X: _ | {
		let Ok = ok
		_ | {x: Ok}
	}
	foo: X & {X}
}
-- dependencies.cue --
issue3606: {
	data: {
		notAllowed: true
	} & #S
	
	#S: string | {}
}
issue3672: {
	#A: string | {y: true}
	#B: #A | {a: "append"} | {b: "prepend"}

	#fn: {
		#C: #B
		#out: x: [...#C]
	}

	// The unification inline appears to be critical
	#def: (#fn & {}).#out
	
	v: #def
	v: x: [{y: true}] // Should be one element
}
issue3681: {
	// Order dependent! These two fields need to go first.
	out: one: #strDefaultDef
	out: two: "\(strDefault)"

	strDefault: *"fallback" | string
	#strDefaultDef: strDefault
}
issue3699: {
	reduced: p1: {
		y: { if x.z { 1 } }
		x: *{z: true} | {}
	}
	reduced: p2: {
		y: { if x.z { 1 } }
		x: *{z: true} | {}
	}
	reduced: full: {
		_res: {
			_fooTrue: {} | *{foo: true}
			_msgSwitch: [
				if _fooTrue.foo { msg: "foo" },
				{ msg: "bar" },
			][0]
			out: _msgSwitch.msg
		}
		let res = {
			out: (_res & {}).out
		}
		out: res.out
	}
}
-- indexelim.cue --
import "math/bits"

indexElimination: {
	inStruct: x: { a: *x[0] | 0 }.a
	inList1: x: [x[0]][0]
	inList2: x: [*x[0] | 0][0]
	issue3124: full: {
		x: [...bool]
		x: [true, false, true, true]
		y: [for _, v in x {[if v {1}, 0][0]}]
		z: [for i, v in y {bits.Set(*z[i-1] | 0, len(y)-i-1, v)}][3]
	}
}
-- out/eval/stats --
Leaks:  36
Freed:  709
Reused: 695
Allocs: 50
Retain: 77

Unifications: 408
Conjuncts:    1394
Disjuncts:    756
-- out/evalalpha --
Errors:
f: 2 errors in empty disjunction:
f.name: conflicting values "int" and "str":
    ./in.cue:5:8
    ./in.cue:15:15
f.val: conflicting values 3 and string (mismatched types int and string):
    ./in.cue:9:8
    ./in.cue:15:27
issue3606.data: 2 errors in empty disjunction:
issue3606.data: conflicting values string and {notAllowed:true} (mismatched types string and struct):
    ./dependencies.cue:2:8
    ./dependencies.cue:6:6
issue3606.data.notAllowed: field not allowed:
    ./dependencies.cue:3:3

Result:
(_|_){
  // [eval]
  issue3606: (_|_){
    // [eval]
    data: (_|_){
      // [eval] issue3606.data: 2 errors in empty disjunction:
      // issue3606.data: conflicting values string and {notAllowed:true} (mismatched types string and struct):
      //     ./dependencies.cue:2:8
      //     ./dependencies.cue:6:6
      // issue3606.data.notAllowed: field not allowed:
      //     ./dependencies.cue:3:3
      notAllowed: (bool){ true }
    }
    #S: ((string|struct)){ |((string){ string }, (#struct){
      }) }
  }
  issue3672: (struct){
    #A: ((string|struct)){ |((string){ string }, (#struct){
        y: (bool){ true }
      }) }
    #B: ((string|struct)){ |((string){ string }, (#struct){
        y: (bool){ true }
      }, (#struct){
        a: (string){ "append" }
      }, (#struct){
        b: (string){ "prepend" }
      }) }
    #fn: (#struct){
      #C: ((string|struct)){ |((string){ string }, (#struct){
          y: (bool){ true }
        }, (#struct){
          a: (string){ "append" }
        }, (#struct){
          b: (string){ "prepend" }
        }) }
      #out: (#struct){
        x: (list){
        }
      }
    }
    #def: (#struct){
      x: (list){
      }
    }
    v: (#struct){
      x: (#list){
        0: (#struct){
          y: (bool){ true }
        }
      }
    }
  }
  issue3681: (struct){
    out: (struct){
      one: (string){ |(*(string){ "fallback" }, (string){ string }) }
      two: (string){ "fallback" }
    }
    strDefault: (string){ |(*(string){ "fallback" }, (string){ string }) }
    #strDefaultDef: (string){ |(*(string){ "fallback" }, (string){ string }) }
  }
  issue3699: (struct){
    reduced: (struct){
      p1: (struct){
        y: (int){ 1 }
        x: (struct){ |(*(struct){
            z: (bool){ true }
          }, (struct){
          }) }
      }
      p2: (struct){
        y: (int){ 1 }
        x: (struct){ |(*(struct){
            z: (bool){ true }
          }, (struct){
          }) }
      }
      full: (struct){
        _res: (struct){
          _fooTrue: (struct){ |(*(struct){
              foo: (bool){ true }
            }, (struct){
            }) }
          _msgSwitch: (struct){
            msg: (string){ "foo" }
          }
          out: (string){ "foo" }
        }
        let res#1 = (struct){
          out: (string){ "foo" }
        }
        out: (string){ "foo" }
      }
    }
  }
  a: (int){ |(*(int){ 1 }, (int){ int }) }
  aa: (int){ |(*(int){ 1 }, *(int){ 2 }, (int){ int }) }
  b: (struct){ |((struct){
      name: (string){ "int" }
      val: (int){ int }
    }, (struct){
      name: (string){ "str" }
      val: (string){ string }
    }) }
  d: (struct){
    val: (int){ 3 }
    name: (string){ "int" }
  }
  c: (struct){
    name: (string){ "int" }
    val: (int){ 3 }
  }
  e: (struct){
    val: (string){ "foo" }
    name: (string){ "str" }
  }
  f: (_|_){
    // [eval] f: 2 errors in empty disjunction:
    // f.name: conflicting values "int" and "str":
    //     ./in.cue:5:8
    //     ./in.cue:15:15
    // f.val: conflicting values 3 and string (mismatched types int and string):
    //     ./in.cue:9:8
    //     ./in.cue:15:27
    name: (string){ "str" }
    val: (int){ 3 }
  }
  e1: (struct){
    a: ((null|struct)){ |((null){ null }, (struct){
        bar: (int){ 2 }
      }) }
    b: (int){ 2 }
  }
  d1: (struct){
    a: (struct){
      c: (int){ 1 }
    }
    b: (struct){
      c: (int){ 1 }
    }
  }
  d2: (struct){
    a: (struct){
      c: (int){ 1 }
    }
    b: (struct){
      c: (int){ 1 }
    }
  }
  d3: (struct){
    a: (struct){
      c: (int){ 1 }
    }
    b: (struct){
      c: (int){ 1 }
    }
  }
  d4: (struct){
    a: (struct){
      c: (int){ 1 }
    }
    b: (struct){
      c: (int){ 1 }
    }
  }
  d5: (struct){
    a: (struct){
      c: (int){ 1 }
    }
    b: (struct){
      c: (int){ 1 }
    }
  }
  d6: (struct){
    a: (struct){
      c: (int){ 1 }
    }
    b: (struct){
      c: (int){ 1 }
    }
  }
  t10: (struct){
    schema: (#struct){
      name: (string){ "Test" }
    }
    #A: ((string|struct)){ |((string){ string }, (#struct){
        name: (string){ string }
      }) }
    test: (#struct){
      name: (string){ "Test" }
    }
  }
  t11: (struct){
    a: (#list){
      0: (string){ "b" }
    }
    b: (#list){
      0: (string){ "b" }
    }
    #A: ((list|struct)){ |((#list){
        0: (string){ |((string){ "a" }, (string){ "b" }) }
      }, (#struct){
      }) }
  }
  cross: (struct){
    a: (string){ |(*(string){ "word" }, (string){ string }) }
  }
  d100: (struct){
    i: ((null|struct)){ |((null){ null }, (struct){
        bar: (int){ 2 }
      }) }
    j: (_|_){
      // [incomplete] d100.j: unresolved disjunction null | {bar:2} (type (null|struct)):
      //     ./in.cue:106:5
    }
  }
  issue641: (struct){
    #A: (#struct){
      type: (string){ "a" }
      x: (string){ "" }
    }
    #B: (#struct){
      type: (string){ "b" }
      x: (string){ string }
    }
    #C: (#struct){
      b: (#struct){ |((#struct){
          type: (string){ "a" }
          x: (string){ "" }
        }, (#struct){
          type: (string){ "b" }
          x: (string){ string }
        }) }
    }
    e: (struct){
      foobar: (#struct){
        b: (#struct){
          x: (string){ "foobar" }
          type: (string){ "b" }
        }
      }
    }
  }
  indexElimination: (struct){
    inStruct: (struct){
      x: (_){ |(*(_){ _ }, (int){ 0 }) }
    }
    inList1: (struct){
      x: (_){ _ }
    }
    inList2: (struct){
      x: (_){ |(*(_){ _ }, (int){ 0 }) }
    }
    issue3124: (struct){
      full: (struct){
        x: (#list){
          0: (bool){ true }
          1: (bool){ false }
          2: (bool){ true }
          3: (bool){ true }
        }
        y: (#list){
          0: (int){ 1 }
          1: (int){ 0 }
          2: (int){ 1 }
          3: (int){ 1 }
        }
        z: (_|_){
          // [incomplete] indexElimination.issue3124.full.z: error in call to math/bits.Set: non-concrete value _:
          //     ./indexelim.cue:11:22
        }
      }
    }
  }
  issue3406: (struct){
    out: (struct){ |((struct){
        kind: (string){ "foo" }
      }, (struct){
        kind: (string){ "bar" }
      }) }
    d: (struct){ |((struct){
        kind: (string){ "foo" }
      }, (struct){
        kind: (string){ "bar" }
      }) }
  }
  issue3411: (struct){
    x: (struct){ |(*(struct){
        y: (#list){
          0: (string){ "bar" }
        }
      }, (struct){
        y: (#list){
          0: (string){ "foo" }
        }
      }) }
  }
  issue3434: (struct){
    t1: (struct){
    }
    full: (struct){
      out: (#struct){
        steps: (#list){
          0: (#struct){
            run: (string){ "example" }
          }
        }
        #matrixConfig: ((string|list)){ |((string){ string }, (list){
          }) }
        matrix?: (#struct){
        }
      }
      #Schema: (#struct){
        steps: (list){
        }
        #matrixConfig: ((string|list)){ |((string){ string }, (list){
          }) }
        matrix?: (#struct){
        }
      }
    }
  }
  issue3490: (struct){
    nested: (struct){
      p1: (string){ |((string){ "a" }, (string){ "b" }) }
      p2: (string){ |((string){ "a" }, (string){ "b" }) }
    }
    full: (struct){
      data: (#list){
        0: (#struct){
          runs?: ((string|list)){ |((string){ "foo" }, (#list){
              0: (string){ "d1" }
            }, (#list){
              0: (string){ "d1" }
              1: (string){ "d2" }
            }) }
          #D1: (string){ "d1" }
          #D2: (string){ "d2" }
        }
      }
      #Schema: (#struct){
        runs?: ((string|list)){ |((string){ "foo" }, (#list){
            0: (string){ "d1" }
          }, (#list){
            0: (string){ "d1" }
            1: (string){ "d2" }
          }) }
        #D1: (string){ "d1" }
        #D2: (string){ "d2" }
      }
    }
  }
  issue3597: (struct){
    t1: (struct){
      #Schema: (#struct){ |((#struct){
          _ok: (bool){ bool }
        }, (#struct){
          _ok: (bool){ true }
          let Ok#2 = (bool){ true }
        }, (#struct){
          _ok: (bool){ true }
          let Ok#2 = (bool){ true }
          x: (bool){ true }
        }) }
      foo: (#struct){ |((#struct){
          _ok: (bool){ bool }
        }, (#struct){
          _ok: (bool){ true }
          let Ok#2 = (bool){ true }
        }, (#struct){
          _ok: (bool){ true }
          let Ok#2multi = 〈0;_ok〉
          x: (bool){ true }
        }) }
      bar: (#struct){ |((#struct){
          _ok: (bool){ bool }
        }, (#struct){
          _ok: (bool){ true }
          let Ok#2 = (bool){ true }
        }, (#struct){
          _ok: (bool){ true }
          let Ok#2 = (bool){ true }
          x: (bool){ true }
        }) }
    }
    t2: (struct){
      ok: (bool){ true }
      X: (_){ |((_){ _ }, (_){
          _
          let Ok#3 = (bool){ true }
        }, (struct){
          let Ok#3 = (bool){ true }
          x: (bool){ true }
        }) }
      foo: (_){ |((_){ _ }, (_){
          _
          let Ok#3 = (bool){ true }
        }, (struct){
          let Ok#3 = (bool){ true }
          x: (bool){ true }
        }) }
    }
  }
}
-- diff/-out/evalalpha<==>+out/eval --
diff old new
--- old
+++ new
@@ -2,11 +2,9 @@
 f: 2 errors in empty disjunction:
 f.name: conflicting values "int" and "str":
     ./in.cue:5:8
-    ./in.cue:15:4
     ./in.cue:15:15
 f.val: conflicting values 3 and string (mismatched types int and string):
     ./in.cue:9:8
-    ./in.cue:15:4
     ./in.cue:15:27
 issue3606.data: 2 errors in empty disjunction:
 issue3606.data: conflicting values string and {notAllowed:true} (mismatched types string and struct):
@@ -14,8 +12,6 @@
     ./dependencies.cue:6:6
 issue3606.data.notAllowed: field not allowed:
     ./dependencies.cue:3:3
-    ./dependencies.cue:4:6
-    ./dependencies.cue:6:15
 
 Result:
 (_|_){
@@ -29,14 +25,7 @@
       //     ./dependencies.cue:6:6
       // issue3606.data.notAllowed: field not allowed:
       //     ./dependencies.cue:3:3
-      //     ./dependencies.cue:4:6
-      //     ./dependencies.cue:6:15
-      notAllowed: (_|_){
-        // [eval] issue3606.data.notAllowed: field not allowed:
-        //     ./dependencies.cue:3:3
-        //     ./dependencies.cue:4:6
-        //     ./dependencies.cue:6:15
-      }
+      notAllowed: (bool){ true }
     }
     #S: ((string|struct)){ |((string){ string }, (#struct){
       }) }
@@ -144,19 +133,12 @@
     // [eval] f: 2 errors in empty disjunction:
     // f.name: conflicting values "int" and "str":
     //     ./in.cue:5:8
-    //     ./in.cue:15:4
     //     ./in.cue:15:15
     // f.val: conflicting values 3 and string (mismatched types int and string):
     //     ./in.cue:9:8
-    //     ./in.cue:15:4
     //     ./in.cue:15:27
     name: (string){ "str" }
-    val: (_|_){
-      // [eval] f.val: conflicting values 3 and string (mismatched types int and string):
-      //     ./in.cue:9:8
-      //     ./in.cue:15:4
-      //     ./in.cue:15:27
-    }
+    val: (int){ 3 }
   }
   e1: (struct){
     a: ((null|struct)){ |((null){ null }, (struct){
@@ -268,8 +250,8 @@
     e: (struct){
       foobar: (#struct){
         b: (#struct){
-          type: (string){ "b" }
           x: (string){ "foobar" }
+          type: (string){ "b" }
         }
       }
     }
@@ -276,16 +258,13 @@
   }
   indexElimination: (struct){
     inStruct: (struct){
-      x: (int){ 0 }
+      x: (_){ |(*(_){ _ }, (int){ 0 }) }
     }
     inList1: (struct){
-      x: (_|_){
-        // [incomplete] indexElimination.inList1.x: cycle error referencing 0:
-        //     ./indexelim.cue:5:17
-      }
+      x: (_){ _ }
     }
     inList2: (struct){
-      x: (int){ 0 }
+      x: (_){ |(*(_){ _ }, (int){ 0 }) }
     }
     issue3124: (struct){
       full: (struct){
@@ -301,7 +280,10 @@
           2: (int){ 1 }
           3: (int){ 1 }
         }
-        z: (int){ 1 }
+        z: (_|_){
+          // [incomplete] indexElimination.issue3124.full.z: error in call to math/bits.Set: non-concrete value _:
+          //     ./indexelim.cue:11:22
+        }
       }
     }
   }
-- diff/todo/p3 --
Missing error positions.
  It is probably okay to show name and val fields with original values, as long
  as it is made clear that f does not unify with disjunctions and positions are
  conveyed properly.
-- out/eval --
Errors:
f: 2 errors in empty disjunction:
f.name: conflicting values "int" and "str":
    ./in.cue:5:8
    ./in.cue:15:4
    ./in.cue:15:15
f.val: conflicting values 3 and string (mismatched types int and string):
    ./in.cue:9:8
    ./in.cue:15:4
    ./in.cue:15:27
issue3606.data: 2 errors in empty disjunction:
issue3606.data: conflicting values string and {notAllowed:true} (mismatched types string and struct):
    ./dependencies.cue:2:8
    ./dependencies.cue:6:6
issue3606.data.notAllowed: field not allowed:
    ./dependencies.cue:3:3
    ./dependencies.cue:4:6
    ./dependencies.cue:6:15

Result:
(_|_){
  // [eval]
  issue3606: (_|_){
    // [eval]
    data: (_|_){
      // [eval] issue3606.data: 2 errors in empty disjunction:
      // issue3606.data: conflicting values string and {notAllowed:true} (mismatched types string and struct):
      //     ./dependencies.cue:2:8
      //     ./dependencies.cue:6:6
      // issue3606.data.notAllowed: field not allowed:
      //     ./dependencies.cue:3:3
      //     ./dependencies.cue:4:6
      //     ./dependencies.cue:6:15
      notAllowed: (_|_){
        // [eval] issue3606.data.notAllowed: field not allowed:
        //     ./dependencies.cue:3:3
        //     ./dependencies.cue:4:6
        //     ./dependencies.cue:6:15
      }
    }
    #S: ((string|struct)){ |((string){ string }, (#struct){
      }) }
  }
  issue3672: (struct){
    #A: ((string|struct)){ |((string){ string }, (#struct){
        y: (bool){ true }
      }) }
    #B: ((string|struct)){ |((string){ string }, (#struct){
        y: (bool){ true }
      }, (#struct){
        a: (string){ "append" }
      }, (#struct){
        b: (string){ "prepend" }
      }) }
    #fn: (#struct){
      #C: ((string|struct)){ |((string){ string }, (#struct){
          y: (bool){ true }
        }, (#struct){
          a: (string){ "append" }
        }, (#struct){
          b: (string){ "prepend" }
        }) }
      #out: (#struct){
        x: (list){
        }
      }
    }
    #def: (#struct){
      x: (list){
      }
    }
    v: (#struct){
      x: (#list){
        0: (#struct){
          y: (bool){ true }
        }
      }
    }
  }
  issue3681: (struct){
    out: (struct){
      one: (string){ |(*(string){ "fallback" }, (string){ string }) }
      two: (string){ "fallback" }
    }
    strDefault: (string){ |(*(string){ "fallback" }, (string){ string }) }
    #strDefaultDef: (string){ |(*(string){ "fallback" }, (string){ string }) }
  }
  issue3699: (struct){
    reduced: (struct){
      p1: (struct){
        y: (int){ 1 }
        x: (struct){ |(*(struct){
            z: (bool){ true }
          }, (struct){
          }) }
      }
      p2: (struct){
        y: (int){ 1 }
        x: (struct){ |(*(struct){
            z: (bool){ true }
          }, (struct){
          }) }
      }
      full: (struct){
        _res: (struct){
          _fooTrue: (struct){ |(*(struct){
              foo: (bool){ true }
            }, (struct){
            }) }
          _msgSwitch: (struct){
            msg: (string){ "foo" }
          }
          out: (string){ "foo" }
        }
        let res#1 = (struct){
          out: (string){ "foo" }
        }
        out: (string){ "foo" }
      }
    }
  }
  a: (int){ |(*(int){ 1 }, (int){ int }) }
  aa: (int){ |(*(int){ 1 }, *(int){ 2 }, (int){ int }) }
  b: (struct){ |((struct){
      name: (string){ "int" }
      val: (int){ int }
    }, (struct){
      name: (string){ "str" }
      val: (string){ string }
    }) }
  d: (struct){
    val: (int){ 3 }
    name: (string){ "int" }
  }
  c: (struct){
    name: (string){ "int" }
    val: (int){ 3 }
  }
  e: (struct){
    val: (string){ "foo" }
    name: (string){ "str" }
  }
  f: (_|_){
    // [eval] f: 2 errors in empty disjunction:
    // f.name: conflicting values "int" and "str":
    //     ./in.cue:5:8
    //     ./in.cue:15:4
    //     ./in.cue:15:15
    // f.val: conflicting values 3 and string (mismatched types int and string):
    //     ./in.cue:9:8
    //     ./in.cue:15:4
    //     ./in.cue:15:27
    name: (string){ "str" }
    val: (_|_){
      // [eval] f.val: conflicting values 3 and string (mismatched types int and string):
      //     ./in.cue:9:8
      //     ./in.cue:15:4
      //     ./in.cue:15:27
    }
  }
  e1: (struct){
    a: ((null|struct)){ |((null){ null }, (struct){
        bar: (int){ 2 }
      }) }
    b: (int){ 2 }
  }
  d1: (struct){
    a: (struct){
      c: (int){ 1 }
    }
    b: (struct){
      c: (int){ 1 }
    }
  }
  d2: (struct){
    a: (struct){
      c: (int){ 1 }
    }
    b: (struct){
      c: (int){ 1 }
    }
  }
  d3: (struct){
    a: (struct){
      c: (int){ 1 }
    }
    b: (struct){
      c: (int){ 1 }
    }
  }
  d4: (struct){
    a: (struct){
      c: (int){ 1 }
    }
    b: (struct){
      c: (int){ 1 }
    }
  }
  d5: (struct){
    a: (struct){
      c: (int){ 1 }
    }
    b: (struct){
      c: (int){ 1 }
    }
  }
  d6: (struct){
    a: (struct){
      c: (int){ 1 }
    }
    b: (struct){
      c: (int){ 1 }
    }
  }
  t10: (struct){
    schema: (#struct){
      name: (string){ "Test" }
    }
    #A: ((string|struct)){ |((string){ string }, (#struct){
        name: (string){ string }
      }) }
    test: (#struct){
      name: (string){ "Test" }
    }
  }
  t11: (struct){
    a: (#list){
      0: (string){ "b" }
    }
    b: (#list){
      0: (string){ "b" }
    }
    #A: ((list|struct)){ |((#list){
        0: (string){ |((string){ "a" }, (string){ "b" }) }
      }, (#struct){
      }) }
  }
  cross: (struct){
    a: (string){ |(*(string){ "word" }, (string){ string }) }
  }
  d100: (struct){
    i: ((null|struct)){ |((null){ null }, (struct){
        bar: (int){ 2 }
      }) }
    j: (_|_){
      // [incomplete] d100.j: unresolved disjunction null | {bar:2} (type (null|struct)):
      //     ./in.cue:106:5
    }
  }
  issue641: (struct){
    #A: (#struct){
      type: (string){ "a" }
      x: (string){ "" }
    }
    #B: (#struct){
      type: (string){ "b" }
      x: (string){ string }
    }
    #C: (#struct){
      b: (#struct){ |((#struct){
          type: (string){ "a" }
          x: (string){ "" }
        }, (#struct){
          type: (string){ "b" }
          x: (string){ string }
        }) }
    }
    e: (struct){
      foobar: (#struct){
        b: (#struct){
          type: (string){ "b" }
          x: (string){ "foobar" }
        }
      }
    }
  }
  indexElimination: (struct){
    inStruct: (struct){
      x: (int){ 0 }
    }
    inList1: (struct){
      x: (_|_){
        // [incomplete] indexElimination.inList1.x: cycle error referencing 0:
        //     ./indexelim.cue:5:17
      }
    }
    inList2: (struct){
      x: (int){ 0 }
    }
    issue3124: (struct){
      full: (struct){
        x: (#list){
          0: (bool){ true }
          1: (bool){ false }
          2: (bool){ true }
          3: (bool){ true }
        }
        y: (#list){
          0: (int){ 1 }
          1: (int){ 0 }
          2: (int){ 1 }
          3: (int){ 1 }
        }
        z: (int){ 1 }
      }
    }
  }
  issue3406: (struct){
    out: (struct){ |((struct){
        kind: (string){ "foo" }
      }, (struct){
        kind: (string){ "bar" }
      }) }
    d: (struct){ |((struct){
        kind: (string){ "foo" }
      }, (struct){
        kind: (string){ "bar" }
      }) }
  }
  issue3411: (struct){
    x: (struct){ |(*(struct){
        y: (#list){
          0: (string){ "bar" }
        }
      }, (struct){
        y: (#list){
          0: (string){ "foo" }
        }
      }) }
  }
  issue3434: (struct){
    t1: (struct){
    }
    full: (struct){
      out: (#struct){
        steps: (#list){
          0: (#struct){
            run: (string){ "example" }
          }
        }
        #matrixConfig: ((string|list)){ |((string){ string }, (list){
          }) }
        matrix?: (#struct){
        }
      }
      #Schema: (#struct){
        steps: (list){
        }
        #matrixConfig: ((string|list)){ |((string){ string }, (list){
          }) }
        matrix?: (#struct){
        }
      }
    }
  }
  issue3490: (struct){
    nested: (struct){
      p1: (string){ |((string){ "a" }, (string){ "b" }) }
      p2: (string){ |((string){ "a" }, (string){ "b" }) }
    }
    full: (struct){
      data: (#list){
        0: (#struct){
          runs?: ((string|list)){ |((string){ "foo" }, (#list){
              0: (string){ "d1" }
            }, (#list){
              0: (string){ "d1" }
              1: (string){ "d2" }
            }) }
          #D1: (string){ "d1" }
          #D2: (string){ "d2" }
        }
      }
      #Schema: (#struct){
        runs?: ((string|list)){ |((string){ "foo" }, (#list){
            0: (string){ "d1" }
          }, (#list){
            0: (string){ "d1" }
            1: (string){ "d2" }
          }) }
        #D1: (string){ "d1" }
        #D2: (string){ "d2" }
      }
    }
  }
  issue3597: (struct){
    t1: (struct){
      #Schema: (#struct){ |((#struct){
          _ok: (bool){ bool }
        }, (#struct){
          _ok: (bool){ true }
          let Ok#2 = (bool){ true }
        }, (#struct){
          _ok: (bool){ true }
          let Ok#2 = (bool){ true }
          x: (bool){ true }
        }) }
      foo: (#struct){ |((#struct){
          _ok: (bool){ bool }
        }, (#struct){
          _ok: (bool){ true }
          let Ok#2 = (bool){ true }
        }, (#struct){
          _ok: (bool){ true }
          let Ok#2multi = 〈0;_ok〉
          x: (bool){ true }
        }) }
      bar: (#struct){ |((#struct){
          _ok: (bool){ bool }
        }, (#struct){
          _ok: (bool){ true }
          let Ok#2 = (bool){ true }
        }, (#struct){
          _ok: (bool){ true }
          let Ok#2 = (bool){ true }
          x: (bool){ true }
        }) }
    }
    t2: (struct){
      ok: (bool){ true }
      X: (_){ |((_){ _ }, (_){
          _
          let Ok#3 = (bool){ true }
        }, (struct){
          let Ok#3 = (bool){ true }
          x: (bool){ true }
        }) }
      foo: (_){ |((_){ _ }, (_){
          _
          let Ok#3 = (bool){ true }
        }, (struct){
          let Ok#3 = (bool){ true }
          x: (bool){ true }
        }) }
    }
  }
}
-- out/compile --
--- dependencies.cue
{
  issue3606: {
    data: ({
      notAllowed: true
    } & 〈0;#S〉)
    #S: (string|{})
  }
  issue3672: {
    #A: (string|{
      y: true
    })
    #B: (〈0;#A〉|{
      a: "append"
    }|{
      b: "prepend"
    })
    #fn: {
      #C: 〈1;#B〉
      #out: {
        x: [
          ...〈2;#C〉,
        ]
      }
    }
    #def: (〈0;#fn〉 & {}).#out
    v: 〈0;#def〉
    v: {
      x: [
        {
          y: true
        },
      ]
    }
  }
  issue3681: {
    out: {
      one: 〈1;#strDefaultDef〉
    }
    out: {
      two: "\(〈1;strDefault〉)"
    }
    strDefault: (*"fallback"|string)
    #strDefaultDef: 〈0;strDefault〉
  }
  issue3699: {
    reduced: {
      p1: {
        y: {
          if 〈1;x〉.z {
            1
          }
        }
        x: (*{
          z: true
        }|{})
      }
    }
    reduced: {
      p2: {
        y: {
          if 〈1;x〉.z {
            1
          }
        }
        x: (*{
          z: true
        }|{})
      }
    }
    reduced: {
      full: {
        _res: {
          _fooTrue: ({}|*{
            foo: true
          })
          _msgSwitch: [
            if 〈1;_fooTrue〉.foo {
              msg: "foo"
            },
            {
              msg: "bar"
            },
          ][0]
          out: 〈0;_msgSwitch〉.msg
        }
        let res#1 = {
          out: (〈1;_res〉 & {}).out
        }
        out: 〈0;let res#1〉.out
      }
    }
  }
}
--- in.cue
{
  a: (*1|int)
  aa: (*1|*2|int)
  b: ({
    name: "int"
    val: int
  }|{
    name: "str"
    val: string
  })
  d: (〈0;b〉 & {
    val: 3
  })
  c: (〈0;b〉 & {
    name: "int"
    val: 3
  })
  e: (〈0;b〉 & {
    val: "foo"
  })
  f: (〈0;b〉 & {
    name: "str"
    val: 3
  })
  e1: {
    a: (null|{
      bar: 2
    })
    b: (〈0;a〉 & {}).bar
  }
  d1: {
    a: ((null|{
      c: 1
    }) & {})
    b: ({} & (null|{
      c: 1
    }))
  }
  d2: {
    a: (([
      ...,
    ]|{
      c: 1
    }) & {})
    b: ({} & ([
      ...,
    ]|{
      c: 1
    }))
  }
  d3: {
    a: ((string|{
      c: 1
    }) & {})
    b: ({} & (string|{
      c: 1
    }))
  }
  d4: {
    a: ((string|{
      c: 1
    }) & {})
    b: ({} & (string|{
      c: 1
    }))
  }
  d5: {
    a: ((number|{
      c: 1
    }) & {})
    b: ({} & (number|{
      c: 1
    }))
  }
  d6: {
    a: ((int|{
      c: 1
    }) & {})
    b: ({} & (int|{
      c: 1
    }))
  }
  t10: {
    schema: 〈0;test〉
    schema: (string|{
      name: string
    })
    #A: {
      (string|{
        name: string
      })
    }
    test: {
      name: "Test"
    }
    test: 〈0;#A〉
  }
  t10: {
    schema: (string|{
      name: string
    })
    schema: 〈0;test〉
    #A: {
      (string|{
        name: string
      })
    }
    test: {
      name: "Test"
    }
    test: 〈0;#A〉
  }
  t10: {
    #A: {
      (string|{
        name: string
      })
    }
    test: {
      name: "Test"
    }
    test: 〈0;#A〉
    schema: (string|{
      name: string
    })
    schema: 〈0;test〉
  }
  t11: {
    a: 〈0;#A〉
    a: 〈0;b〉
    b: (〈0;#A〉 & [
      "b",
    ])
    #A: ([
      ("a"|"b"),
    ]|{})
  }
  t11: {
    b: (〈0;#A〉 & [
      "b",
    ])
    #A: ([
      ("a"|"b"),
    ]|{})
    a: 〈0;b〉
    a: 〈0;#A〉
  }
  cross: {
    a: (*"word"|string)
    a: (string|*"word")
  }
  d100: {
    i: (null|{
      bar: 2
    })
    j: 〈0;i〉.bar
  }
  issue641: {
    #A: {
      type: "a"
      x: ""
    }
    #B: {
      type: "b"
      x: string
    }
    #C: {
      b: (〈1;#A〉|〈1;#B〉)
    }
    e: {
      [string]: (〈1;#C〉 & {
        b: (〈2;#A〉|〈2;#B〉)
      })
    }
    e: {
      foobar: (〈1;#C〉 & {
        b: (〈2;#B〉 & {
          x: "foobar"
        })
      })
    }
  }
}
--- indexelim.cue
{
  indexElimination: {
    inStruct: {
      x: {
        a: (*〈1;x〉[0]|0)
      }.a
    }
    inList1: {
      x: [
        〈1;x〉[0],
      ][0]
    }
    inList2: {
      x: [
        (*〈1;x〉[0]|0),
      ][0]
    }
    issue3124: {
      full: {
        x: [
          ...bool,
        ]
        x: [
          true,
          false,
          true,
          true,
        ]
        y: [
          for _, v in 〈1;x〉 {
            [
              if 〈2;v〉 {
                1
              },
              0,
            ][0]
          },
        ]
        z: [
          for i, v in 〈1;y〉 {
            〈import;"math/bits"〉.Set((*〈3;z〉[(〈1;i〉 - 1)]|0), ((len(〈3;y〉) - 〈1;i〉) - 1), 〈1;v〉)
          },
        ][3]
      }
    }
  }
}
--- issue3406.cue
{
  issue3406: {
    out: (〈0;d〉 & {
      〈1;d〉
    })
    d: {
      kind: ("foo"|"bar")
    }
    d: ({
      kind: "foo"
    }|{
      kind: "bar"
    })
  }
}
--- issue3411.cue
{
  issue3411: {
    x: {
      y?: [
        ...string,
      ]
    }
    x: ({
      y: [
        "foo",
      ]
    }|*{
      y: [
        "bar",
      ]
    })
  }
}
--- issue3434.cue
{
  issue3434: {
    t1: {
      ({}|{})
      {
        ["x"]: 1
      }
      {
        ["y"]: 2
      }
    }
  }
  issue3434: {
    full: {
      out: (〈0;#Schema〉 & {
        steps: [
          {
            run: "example"
          },
        ]
      })
      #Schema: {
        steps: [
          ...{
            run: string
          },
        ]
        #matrixConfig: (string|[
          ...〈1;#matrixConfig〉,
        ])
        matrix?: (({
          ...
        }|string) & {
          {
            [=~"^foo"]: [
              ...{
                [string]: 〈4;#matrixConfig〉
              },
            ]
          }
          {
            [=~"^bar"]: ([
              ...〈3;#matrixConfig〉,
            ]|string)
          }
        })
      }
    }
  }
}
--- issue3490.cue
{
  issue3490: {
    nested: {
      p1: {
        (("a"|"b")|"b")
        ("a"|"b")
      }
    }
  }
  issue3490: {
    nested: {
      p2: {
        ("a"|"b")
        (("a"|"b")|"b")
      }
    }
  }
  issue3490: {
    full: {
      data: [
        ...〈1;#Schema〉,
      ]
      data: [
        (〈1;#Schema〉 & {}),
      ]
      #Schema: {
        runs?: ("foo"|([
          〈1;#D1〉,
        ]|[
          〈1;#D1〉,
          〈1;#D2〉,
        ]))
        #D1: "d1"
        #D2: "d2"
      }
    }
  }
}
--- issue3597.cue
{
  issue3597: {
    t1: {
      #Schema: {
        _ok: bool
        ({}|{
          _ok: true
          let Ok#2 = 〈0;_ok〉
          ({}|{
            x: 〈1;let Ok#2〉
          })
        })
      }
      [string]: 〈0;#Schema〉
      foo: 〈0;bar〉
      bar: {}
    }
  }
  issue3597: {
    t2: {
      ok: true
      X: (_|{
        let Ok#3 = 〈1;ok〉
        (_|{
          x: 〈1;let Ok#3〉
        })
      })
      foo: (〈0;X〉 & {
        〈1;X〉
      })
    }
  }
}
