-- in.cue --
foo: string
bar: close({})

if bar.missing == "x" {
	let _bar = bar
	foo: _bar
}
-- out/compile --
--- in.cue
{
  foo: string
  bar: close({})
  if (〈0;bar〉.missing == "x") {
    let _bar#1 = 〈1;bar〉
    foo: 〈0;let _bar#1〉
  }
}
-- out/eval/stats --
Leaks:  1
Freed:  4
Reused: 1
Allocs: 4
Retain: 2

Unifications: 5
Conjuncts:    5
Disjuncts:    6

NumCloseIDs: 1
-- out/eval --
Errors:
undefined field: missing:
    ./in.cue:4:8

Result:
(_|_){
  // [eval] undefined field: missing:
  //     ./in.cue:4:8
  foo: (string){ string }
  bar: (#struct){
  }
  let _bar#1 = (_){ _ }
}
-- out/evalalpha --
Errors:
undefined field: missing:
    ./in.cue:4:8

Result:
(_|_){
  // [eval]
  foo: (_|_){
    // [eval] undefined field: missing:
    //     ./in.cue:4:8
  }
  bar: (#struct){
  }
  let _bar#1multi = 〈1;bar〉
}
-- diff/-out/evalalpha<==>+out/eval --
diff old new
--- old
+++ new
@@ -4,10 +4,12 @@
 
 Result:
 (_|_){
-  // [eval] undefined field: missing:
-  //     ./in.cue:4:8
-  foo: (string){ string }
+  // [eval]
+  foo: (_|_){
+    // [eval] undefined field: missing:
+    //     ./in.cue:4:8
+  }
   bar: (#struct){
   }
-  let _bar#1 = (_){ _ }
+  let _bar#1multi = 〈1;bar〉
 }
-- diff/explanation --
Error is reported at `foo` instead of at top level. This is a result of the
pushdown semantics of `foo`: the comprehension task is pushed down from top
level to `foo` and thus the error is reported there.