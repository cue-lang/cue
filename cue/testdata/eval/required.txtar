-- in.cue --
self: t1: {
	a?: int
}

self: t2: {
	a!: int
	a!: int
}

unify: t1: p1: {
	a!: int
	a: int
}

unify: t1: p2: {
	a: int
	a!: int
}

unify: t2: p1: {
	a!: int
	a?: int
}

unify: t2: p2: {
	a?: int
	a!: int
}
#Def: t1: {
	a!: int
}

allowed: issue2306: {
	#A: a!: int
	#A: #B

	#B: b!: int
}

reference: {
	toWithinDefinition: p1:{
		#Foo: a!: int
		b: #Foo.a
	}
	toWithinDefinition: p2:{
		b: #Foo.a
		#Foo: a!: int
	}
	toFieldFromDefinition: p1: {
		#Foo: a!: int
		b: #Foo
		c: b.a
	}
	toFieldFromDefinition: p2: {
		c: b.a
		b: #Foo
		#Foo: a!: int
	}
	toNonDefinition: p1: {
		x: y!: _
		b: x.y
	}
	toNonDefinition: p2: {
		b: x.y
		x: y!: _
	}
	toConcrete: p1: {
		a!: 1
		b: a + 1
	}
	toConcrete: p2: {
		b: a + 1
		a!: 1
	}
}
-- issue3918.cue --
import "strings"

issue3918: reduced: {
	#disjuncts: {
		in!: [...string]
		out: strings.Join(in, "|")
	}

	x: (#disjuncts & {
		in: ["foo", "bar"]
	}).out
}
issue3918: noFunction: {
	#disjuncts: {
		in!: [...string]
		out: in
	}
	_foo: #disjuncts & {}
	x: _foo.out
}
// A required field error is incomplete error. Ensure that setting a vertex
// to this error does not escalate it to an evaluation error.
doNotEscalateError: {
	a: {
		in:  _
		out: in.self
	}
	b: {
		required!: _
		pass:    (a & {in: required}).out
	}
}
-- out/compile --
--- in.cue
{
  self: {
    t1: {
      a?: int
    }
  }
  self: {
    t2: {
      a!: int
      a!: int
    }
  }
  unify: {
    t1: {
      p1: {
        a!: int
        a: int
      }
    }
  }
  unify: {
    t1: {
      p2: {
        a: int
        a!: int
      }
    }
  }
  unify: {
    t2: {
      p1: {
        a!: int
        a?: int
      }
    }
  }
  unify: {
    t2: {
      p2: {
        a?: int
        a!: int
      }
    }
  }
  #Def: {
    t1: {
      a!: int
    }
  }
  allowed: {
    issue2306: {
      #A: {
        a!: int
      }
      #A: 〈0;#B〉
      #B: {
        b!: int
      }
    }
  }
  reference: {
    toWithinDefinition: {
      p1: {
        #Foo: {
          a!: int
        }
        b: 〈0;#Foo〉.a
      }
    }
    toWithinDefinition: {
      p2: {
        b: 〈0;#Foo〉.a
        #Foo: {
          a!: int
        }
      }
    }
    toFieldFromDefinition: {
      p1: {
        #Foo: {
          a!: int
        }
        b: 〈0;#Foo〉
        c: 〈0;b〉.a
      }
    }
    toFieldFromDefinition: {
      p2: {
        c: 〈0;b〉.a
        b: 〈0;#Foo〉
        #Foo: {
          a!: int
        }
      }
    }
    toNonDefinition: {
      p1: {
        x: {
          y!: _
        }
        b: 〈0;x〉.y
      }
    }
    toNonDefinition: {
      p2: {
        b: 〈0;x〉.y
        x: {
          y!: _
        }
      }
    }
    toConcrete: {
      p1: {
        a!: 1
        b: (〈0;a〉 + 1)
      }
    }
    toConcrete: {
      p2: {
        b: (〈0;a〉 + 1)
        a!: 1
      }
    }
  }
}
--- issue3918.cue
{
  issue3918: {
    reduced: {
      #disjuncts: {
        in!: [
          ...string,
        ]
        out: 〈import;strings〉.Join(〈0;in〉, "|")
      }
      x: (〈0;#disjuncts〉 & {
        in: [
          "foo",
          "bar",
        ]
      }).out
    }
  }
  issue3918: {
    noFunction: {
      #disjuncts: {
        in!: [
          ...string,
        ]
        out: 〈0;in〉
      }
      _foo: (〈0;#disjuncts〉 & {})
      x: 〈0;_foo〉.out
    }
  }
  doNotEscalateError: {
    a: {
      in: _
      out: 〈0;in〉.self
    }
    b: {
      required!: _
      pass: (〈1;a〉 & {
        in: 〈1;required〉
      }).out
    }
  }
}
-- out/eval/stats --
Leaks:  0
Freed:  66
Reused: 58
Allocs: 8
Retain: 10

Unifications: 66
Conjuncts:    90
Disjuncts:    76
-- out/evalalpha --
(_|_){
  // [eval]
  self: (struct){
    t1: (struct){
      a?: (int){ int }
    }
    t2: (struct){
      a!: (int){ int }
    }
  }
  unify: (struct){
    t1: (struct){
      p1: (struct){
        a: (int){ int }
      }
      p2: (struct){
        a: (int){ int }
      }
    }
    t2: (struct){
      p1: (struct){
        a!: (int){ int }
      }
      p2: (struct){
        a!: (int){ int }
      }
    }
  }
  #Def: (#struct){
    t1: (#struct){
      a!: (int){ int }
    }
  }
  allowed: (_|_){
    // [eval]
    issue2306: (_|_){
      // [eval]
      #A: (_|_){
        // [eval]
        a!: (_|_){
          // [eval] allowed.issue2306.#A.a: field not allowed:
          //     ./in.cue:34:6
        }
        b!: (int){ int }
      }
      #B: (#struct){
        b!: (int){ int }
      }
    }
  }
  reference: (struct){
    toWithinDefinition: (struct){
      p1: (struct){
        #Foo: (#struct){
          a!: (int){ int }
        }
        b: (_|_){
          // [incomplete] reference.toWithinDefinition.p1.b: required field missing: a:
          //     ./in.cue:43:11
        }
      }
      p2: (struct){
        b: (_|_){
          // [incomplete] reference.toWithinDefinition.p2.b: required field missing: a:
          //     ./in.cue:46:11
        }
        #Foo: (#struct){
          a!: (int){ int }
        }
      }
    }
    toFieldFromDefinition: (struct){
      p1: (struct){
        #Foo: (#struct){
          a!: (int){ int }
        }
        b: ~(reference.toFieldFromDefinition.p1.#Foo)
        c: (_|_){
          // [incomplete] reference.toFieldFromDefinition.p1.c: required field missing: a:
          //     ./in.cue:52:8
        }
      }
      p2: (struct){
        c: (_|_){
          // [incomplete] reference.toFieldFromDefinition.p2.c: required field missing: a:
          //     ./in.cue:55:8
        }
        b: ~(reference.toFieldFromDefinition.p2.#Foo)
        #Foo: (#struct){
          a!: (int){ int }
        }
      }
    }
    toNonDefinition: (struct){
      p1: (struct){
        x: (struct){
          y!: (_){ _ }
        }
        b: (_|_){
          // [incomplete] reference.toNonDefinition.p1.b: required field missing: y:
          //     ./in.cue:61:8
        }
      }
      p2: (struct){
        b: (_|_){
          // [incomplete] reference.toNonDefinition.p2.b: required field missing: y:
          //     ./in.cue:64:8
        }
        x: (struct){
          y!: (_){ _ }
        }
      }
    }
    toConcrete: (struct){
      p1: (struct){
        a!: (int){ 1 }
        b: (_|_){
          // [incomplete] reference.toConcrete.p1.b: required field missing: a:
          //     ./in.cue:69:6
        }
      }
      p2: (struct){
        b: (_|_){
          // [incomplete] reference.toConcrete.p2.b: required field missing: a:
          //     ./in.cue:72:6
        }
        a!: (int){ 1 }
      }
    }
  }
  issue3918: (struct){
    reduced: (struct){
      #disjuncts: (#struct){
        in!: (list){
        }
        out: (_|_){
          // [incomplete] issue3918.reduced.#disjuncts.out: required field missing: in:
          //     ./issue3918.cue:6:21
        }
      }
      x: (string){ "foo|bar" }
    }
    noFunction: (struct){
      #disjuncts: (#struct){
        in!: (list){
        }
        out: (_|_){
          // [incomplete] issue3918.noFunction.#disjuncts.out: required field missing: in:
          //     ./issue3918.cue:16:8
        }
      }
      _foo: (#struct){
        in!: (list){
        }
        out: (_|_){
          // [incomplete] issue3918.noFunction._foo.out: required field missing: in:
          //     ./issue3918.cue:16:8
        }
      }
      x: (_|_){
        // [incomplete] issue3918.noFunction._foo.out: required field missing: in:
        //     ./issue3918.cue:16:8
      }
    }
  }
  doNotEscalateError: (struct){
    a: (struct){
      in: (_){ _ }
      out: (_|_){
        // [incomplete] doNotEscalateError.a.out: in.self undefined as in is incomplete (type _):
        //     ./issue3918.cue:26:8
      }
    }
    b: (struct){
      required!: (_){ _ }
      pass: (_|_){
        // [incomplete] doNotEscalateError.b.pass: undefined field: self:
        //     ./issue3918.cue:26:11
      }
    }
  }
}
-- diff/-out/evalalpha<==>+out/eval --
diff old new
--- old
+++ new
@@ -40,8 +40,6 @@
         a!: (_|_){
           // [eval] allowed.issue2306.#A.a: field not allowed:
           //     ./in.cue:34:6
-          //     ./in.cue:35:6
-          //     ./in.cue:37:6
         }
         b!: (int){ int }
       }
@@ -56,10 +54,16 @@
         #Foo: (#struct){
           a!: (int){ int }
         }
-        b: (int){ int }
-      }
-      p2: (struct){
-        b: (int){ int }
+        b: (_|_){
+          // [incomplete] reference.toWithinDefinition.p1.b: required field missing: a:
+          //     ./in.cue:43:11
+        }
+      }
+      p2: (struct){
+        b: (_|_){
+          // [incomplete] reference.toWithinDefinition.p2.b: required field missing: a:
+          //     ./in.cue:46:11
+        }
         #Foo: (#struct){
           a!: (int){ int }
         }
@@ -70,16 +74,18 @@
         #Foo: (#struct){
           a!: (int){ int }
         }
-        b: (#struct){
-          a!: (int){ int }
-        }
-        c: (int){ int }
-      }
-      p2: (struct){
-        c: (int){ int }
-        b: (#struct){
-          a!: (int){ int }
-        }
+        b: ~(reference.toFieldFromDefinition.p1.#Foo)
+        c: (_|_){
+          // [incomplete] reference.toFieldFromDefinition.p1.c: required field missing: a:
+          //     ./in.cue:52:8
+        }
+      }
+      p2: (struct){
+        c: (_|_){
+          // [incomplete] reference.toFieldFromDefinition.p2.c: required field missing: a:
+          //     ./in.cue:55:8
+        }
+        b: ~(reference.toFieldFromDefinition.p2.#Foo)
         #Foo: (#struct){
           a!: (int){ int }
         }
@@ -90,10 +96,16 @@
         x: (struct){
           y!: (_){ _ }
         }
-        b: (_){ _ }
-      }
-      p2: (struct){
-        b: (_){ _ }
+        b: (_|_){
+          // [incomplete] reference.toNonDefinition.p1.b: required field missing: y:
+          //     ./in.cue:61:8
+        }
+      }
+      p2: (struct){
+        b: (_|_){
+          // [incomplete] reference.toNonDefinition.p2.b: required field missing: y:
+          //     ./in.cue:64:8
+        }
         x: (struct){
           y!: (_){ _ }
         }
@@ -102,11 +114,68 @@
     toConcrete: (struct){
       p1: (struct){
         a!: (int){ 1 }
-        b: (int){ 2 }
-      }
-      p2: (struct){
-        b: (int){ 2 }
-        a!: (int){ 1 }
+        b: (_|_){
+          // [incomplete] reference.toConcrete.p1.b: required field missing: a:
+          //     ./in.cue:69:6
+        }
+      }
+      p2: (struct){
+        b: (_|_){
+          // [incomplete] reference.toConcrete.p2.b: required field missing: a:
+          //     ./in.cue:72:6
+        }
+        a!: (int){ 1 }
+      }
+    }
+  }
+  issue3918: (struct){
+    reduced: (struct){
+      #disjuncts: (#struct){
+        in!: (list){
+        }
+        out: (_|_){
+          // [incomplete] issue3918.reduced.#disjuncts.out: required field missing: in:
+          //     ./issue3918.cue:6:21
+        }
+      }
+      x: (string){ "foo|bar" }
+    }
+    noFunction: (struct){
+      #disjuncts: (#struct){
+        in!: (list){
+        }
+        out: (_|_){
+          // [incomplete] issue3918.noFunction.#disjuncts.out: required field missing: in:
+          //     ./issue3918.cue:16:8
+        }
+      }
+      _foo: (#struct){
+        in!: (list){
+        }
+        out: (_|_){
+          // [incomplete] issue3918.noFunction._foo.out: required field missing: in:
+          //     ./issue3918.cue:16:8
+        }
+      }
+      x: (_|_){
+        // [incomplete] issue3918.noFunction._foo.out: required field missing: in:
+        //     ./issue3918.cue:16:8
+      }
+    }
+  }
+  doNotEscalateError: (struct){
+    a: (struct){
+      in: (_){ _ }
+      out: (_|_){
+        // [incomplete] doNotEscalateError.a.out: in.self undefined as in is incomplete (type _):
+        //     ./issue3918.cue:26:8
+      }
+    }
+    b: (struct){
+      required!: (_){ _ }
+      pass: (_|_){
+        // [incomplete] doNotEscalateError.b.pass: undefined field: self:
+        //     ./issue3918.cue:26:11
       }
     }
   }
-- diff/todo/p2 --
Missing position.
-- out/eval --
(_|_){
  // [eval]
  self: (struct){
    t1: (struct){
      a?: (int){ int }
    }
    t2: (struct){
      a!: (int){ int }
    }
  }
  unify: (struct){
    t1: (struct){
      p1: (struct){
        a: (int){ int }
      }
      p2: (struct){
        a: (int){ int }
      }
    }
    t2: (struct){
      p1: (struct){
        a!: (int){ int }
      }
      p2: (struct){
        a!: (int){ int }
      }
    }
  }
  #Def: (#struct){
    t1: (#struct){
      a!: (int){ int }
    }
  }
  allowed: (_|_){
    // [eval]
    issue2306: (_|_){
      // [eval]
      #A: (_|_){
        // [eval]
        a!: (_|_){
          // [eval] allowed.issue2306.#A.a: field not allowed:
          //     ./in.cue:34:6
          //     ./in.cue:35:6
          //     ./in.cue:37:6
        }
        b!: (int){ int }
      }
      #B: (#struct){
        b!: (int){ int }
      }
    }
  }
  reference: (struct){
    toWithinDefinition: (struct){
      p1: (struct){
        #Foo: (#struct){
          a!: (int){ int }
        }
        b: (int){ int }
      }
      p2: (struct){
        b: (int){ int }
        #Foo: (#struct){
          a!: (int){ int }
        }
      }
    }
    toFieldFromDefinition: (struct){
      p1: (struct){
        #Foo: (#struct){
          a!: (int){ int }
        }
        b: (#struct){
          a!: (int){ int }
        }
        c: (int){ int }
      }
      p2: (struct){
        c: (int){ int }
        b: (#struct){
          a!: (int){ int }
        }
        #Foo: (#struct){
          a!: (int){ int }
        }
      }
    }
    toNonDefinition: (struct){
      p1: (struct){
        x: (struct){
          y!: (_){ _ }
        }
        b: (_){ _ }
      }
      p2: (struct){
        b: (_){ _ }
        x: (struct){
          y!: (_){ _ }
        }
      }
    }
    toConcrete: (struct){
      p1: (struct){
        a!: (int){ 1 }
        b: (int){ 2 }
      }
      p2: (struct){
        b: (int){ 2 }
        a!: (int){ 1 }
      }
    }
  }
}
