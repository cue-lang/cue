#name: references from template to concrete
#evalFull
-- in.cue --
res: [t]
t: [X=string]: {
	a: c + b.str
	b: str: string
	c: "X"
}
t: x: {b: str: "DDDD"}
-- out/compile --
--- in.cue
{
  res: [
    〈1;t〉,
  ]
  t: {
    [string]: {
      a: (〈0;c〉 + 〈0;b〉.str)
      b: {
        str: string
      }
      c: "X"
    }
  }
  t: {
    x: {
      b: {
        str: "DDDD"
      }
    }
  }
}
-- out/eval/stats --
Leaks:  0
Freed:  14
Reused: 7
Allocs: 7
Retain: 3

Unifications: 14
Conjuncts:    21
Disjuncts:    15
-- out/evalalpha --
(struct){
  res: (#list){
    0: ~(t)
  }
  t: (struct){
    x: (struct){
      b: (struct){
        str: (string){ "DDDD" }
      }
      a: (string){ "XDDDD" }
      c: (string){ "X" }
    }
  }
}
-- diff/-out/evalalpha<==>+out/eval --
diff old new
--- old
+++ new
@@ -1,14 +1,6 @@
 (struct){
   res: (#list){
-    0: (struct){
-      x: (struct){
-        b: (struct){
-          str: (string){ "DDDD" }
-        }
-        a: (string){ "XDDDD" }
-        c: (string){ "X" }
-      }
-    }
+    0: ~(t)
   }
   t: (struct){
     x: (struct){
-- out/eval --
(struct){
  res: (#list){
    0: (struct){
      x: (struct){
        b: (struct){
          str: (string){ "DDDD" }
        }
        a: (string){ "XDDDD" }
        c: (string){ "X" }
      }
    }
  }
  t: (struct){
    x: (struct){
      b: (struct){
        str: (string){ "DDDD" }
      }
      a: (string){ "XDDDD" }
      c: (string){ "X" }
    }
  }
}
