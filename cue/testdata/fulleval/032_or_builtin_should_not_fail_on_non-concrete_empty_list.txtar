# DO NOT EDIT; generated by go run testdata/gen.go
#
#name: or builtin should not fail on non-concrete empty list
#evalFull
-- in.cue --
#Workflow: {
	jobs: {
		[jobID=string]: {
		}
	}
	#JobID: or([ for k, _ in jobs {k}])
}

foo: #Workflow & {
	jobs: foo: {
	}
}
-- out/def --
#Workflow: {
	jobs: {
		[jobID=string]: {}
	}
	#JobID: or([ for k, _ in jobs { k } ])
}
foo: #Workflow & {
	jobs: {
		foo: {}
	}
}
-- out/export --
foo: {
	jobs: {
		foo: {}
	}
}
-- out/yaml --
foo:
  jobs:
    foo: {}
-- out/json --
{"foo":{"jobs":{"foo":{}}}}
-- out/legacy-debug --
<0>{#Workflow: <1>C{jobs: <2>{[]: <3>(jobID: string)-><4>C{}, }, #JobID: or ([ <5>for k, _ in <6>.jobs yield <5>.k ])}, foo: <7>C{jobs: <8>{[]: <9>(jobID: string)-><10>C{}, foo: <11>C{}}, #JobID: "foo"}}
-- out/eval/stats --
Leaks:  6
Freed:  11
Reused: 6
Allocs: 11
Retain: 6

Unifications: 15
Conjuncts:    32
Disjuncts:    17
-- out/eval --
(struct){
  #Workflow: (#struct){
    jobs: (#struct){
    }
    #JobID: (_|_){
      // [incomplete] empty list in call to or:
      //     ./in.cue:6:10
    }
  }
  foo: (#struct){
    jobs: (#struct){
      foo: (#struct){
      }
    }
    #JobID: (string){ "foo" }
  }
}
-- out/compile --
--- in.cue
{
  #Workflow: {
    jobs: {
      [string]: {}
    }
    #JobID: or([
      for k, _ in 〈1;jobs〉 {
        〈1;k〉
      },
    ])
  }
  foo: (〈0;#Workflow〉 & {
    jobs: {
      foo: {}
    }
  })
}
