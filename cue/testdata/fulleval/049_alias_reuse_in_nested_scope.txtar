#name: alias reuse in nested scope
#evalFull
-- in.cue --
#Foo: {
	let X = or([for k, _ in {} {k}])
	connection: [X]: X
}
#A: {
	foo: "key"
	let X = foo
	a: foo: [X]: X
}
#B: {
	foo: string
	let X = foo
	a: foo: [X]: X
}
b: #B & {foo: "key"}
-- out/eval/stats --
Leaks:  10
Freed:  19
Reused: 15
Allocs: 14
Retain: 10

Unifications: 29
Conjuncts:    40
Disjuncts:    29
-- out/eval --
(struct){
  #Foo: (#struct){
    let X#1 = (_|_){
      // [incomplete] empty list in call to or:
      //     ./in.cue:2:10
    }
    connection: (_|_){
      // [incomplete] empty list in call to or:
      //     ./in.cue:2:10
    }
  }
  #A: (#struct){
    foo: (string){ "key" }
    let X#2 = (string){ "key" }
    a: (#struct){
      foo: (#struct){
      }
    }
  }
  #B: (#struct){
    foo: (string){ string }
    let X#3 = (string){ string }
    a: (#struct){
      foo: (#struct){
      }
    }
  }
  b: (#struct){
    foo: (string){ "key" }
    let X#3 = (string){ "key" }
    a: (#struct){
      foo: (#struct){
      }
    }
  }
}
-- out/compile --
--- in.cue
{
  #Foo: {
    let X#1 = or([
      for k, _ in {} {
        〈1;k〉
      },
    ])
    connection: {
      [〈1;let X#1〉]: 〈1;let X#1〉
    }
  }
  #A: {
    foo: "key"
    let X#2 = 〈0;foo〉
    a: {
      foo: {
        [〈2;let X#2〉]: 〈2;let X#2〉
      }
    }
  }
  #B: {
    foo: string
    let X#3 = 〈0;foo〉
    a: {
      foo: {
        [〈2;let X#3〉]: 〈2;let X#3〉
      }
    }
  }
  b: (〈0;#B〉 & {
    foo: "key"
  })
}
