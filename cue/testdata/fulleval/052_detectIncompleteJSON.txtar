#name: detectIncompleteJSON
#evalFull
-- in.cue --
package foobar

import "encoding/json"

#Spec: {
	_vars: {something: string}
	data: {
		#foo: {
			use: _vars.something
		}
		baz:    json.Marshal(_vars.something)
		foobar: json.Marshal(#foo)
	}
}
Val: #Spec & {
	_vars: something: "var-string"
}
-- out/eval --
(struct){
  #Spec: (#struct){
    _vars(:foobar): (#struct){
      something: (string){ string }
    }
    data: (#struct){
      #foo: (#struct){
        use: (string){ string }
      }
      baz: (_|_){
        // [incomplete] #Spec.data.baz: non-concrete argument 0:
        //     ./in.cue:11:11
      }
      foobar: (_|_){
        // [incomplete] cannot convert incomplete value "string" to JSON:
        //     ./in.cue:6:21
      }
    }
  }
  Val: (#struct){
    _vars(:foobar): (#struct){
      something: (string){ "var-string" }
    }
    data: (#struct){
      #foo: (#struct){
        use: (string){ "var-string" }
      }
      baz: (string){ "\"var-string\"" }
      foobar: (string){ "{\"use\":\"var-string\"}" }
    }
  }
}
-- out/compile --
--- in.cue
{
  #Spec: {
    _vars: {
      something: string
    }
    data: {
      #foo: {
        use: 〈2;_vars〉.something
      }
      baz: 〈import;"encoding/json"〉.Marshal(〈1;_vars〉.something)
      foobar: 〈import;"encoding/json"〉.Marshal(〈0;#foo〉)
    }
  }
  Val: (〈0;#Spec〉 & {
    _vars: {
      something: "var-string"
    }
  })
}
