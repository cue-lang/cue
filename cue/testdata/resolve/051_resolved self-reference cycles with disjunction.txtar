# DO NOT EDIT; generated by go run testdata/gen.go
#
#name: resolved self-reference cycles with disjunction
#evalPartial
-- in.cue --
// The second disjunct in xa1 is not resolvable and can be
// eliminated:
//   xa4 & 9
//   (xa2 + 2) & 9
//   ((xa3 + 2) + 2) & 9
//   (((6 & xa1-2) + 2) + 2) & 9
//   ((6 + 2) + 2) & 9 // 6 == xa1-2
//   10 & 9 => _|_
// The remaining values resolve.
xa1: (xa2 & 8) | (xa4 & 9)
xa2: xa3 + 2
xa3: 6 & xa1-2
xa4: xa2 + 2

// The second disjunct in xb4 can be eliminated as both disjuncts
// of xb3 result in an incompatible sum when substituted.
xb1: (xb2 & 8) | (xb4 & 9)
xb2: xb3 + 2
xb3: (6 & (xb1 - 2)) | (xb4 & 9)
xb4: xb2 + 2

// Another variant with more disjunctions. xc1 remains with two
// possibilities. Technically, only the first value is valid.
// However, to fully determine that, all options of the remaining
// disjunction will have to be evaluated algebraically, which is
// not done.
xc1: xc2 & 8 | xc4 & 9 | xc5 & 9
xc2: xc3 + 2
xc3: 6 & xc1-2
xc4: xc2 + 1
xc5: xc2 + 2

// The above is resolved by setting xd1 explicitly.
xd1: xd2 & 8 | xd4 & 9 | xd5 & 9
xd2: xd3 + 2
xd3: 6 & xd1-2
xd4: xd2 + 1
xd5: xd2 + 2
xd1: 8

// The above is resolved by setting xd1 explicitly to the wrong
// value, resulting in an error.
xe1: xe2 & 8 | xe4 & 9 | xe5 & 9
xe2: xe3 + 2
xe3: 6 & xe1-2
xe4: xe2 + 1
xe5: xe2 + 2
xe1: 9

// Only one solution.
xf1: xf2 & 8 | xf4 & 9
xf2: xf3 + 2
xf3: 6 & xf1-2 | xf4 & 9
xf4: xf2 + 2

z1: z2+1 | z3+5
z2: z3 + 2
z3: z1 - 3
z3: 8
-- out/def --
// The second disjunct in xa1 is not resolvable and can be
// eliminated:
//   xa4 & 9
//   (xa2 + 2) & 9
//   ((xa3 + 2) + 2) & 9
//   (((6 & xa1-2) + 2) + 2) & 9
//   ((6 + 2) + 2) & 9 // 6 == xa1-2
//   10 & 9 => _|_
// The remaining values resolve.
xa1: 8
xa2: 8
xa4: 10
xa3: 6

// The second disjunct in xb4 can be eliminated as both disjuncts
// of xb3 result in an incompatible sum when substituted.
xb1: 8
xb2: 8
xb4: 10
xb3: 6

// Another variant with more disjunctions. xc1 remains with two
// possibilities. Technically, only the first value is valid.
// However, to fully determine that, all options of the remaining
// disjunction will have to be evaluated algebraically, which is
// not done.
xc1: xc2 & 8 | xc4 & 9 | xc5 & 9
xc2: xc3 + 2
xc4: xc2 + 1
xc5: xc2 + 2
xc3: 6 & xc1-2

// The above is resolved by setting xd1 explicitly.
xd1: 8
xd2: 8
xd4: 9
xd5: 10
xd3: 6

// The above is resolved by setting xd1 explicitly to the wrong
// value, resulting in an error.
xe1: _|_ // conflicting values 6 and 7
xe2: _|_ // conflicting values 6 and 7
xe4: _|_ // conflicting values 6 and 7
xe5: _|_ // conflicting values 6 and 7
xe3: _|_ // conflicting values 6 and 7

// Only one solution.
xf1: 8
xf2: 8
xf4: 10
xf3: 6
z1:  z2+1 | z3+5
z2:  z3 + 2
z3:  z1-3 & 8
-- out/legacy-debug --
<0>{xa1: 8, xa2: 8, xa4: 10, xa3: 6, xb1: 8, xb2: 8, xb4: 10, xb3: 6, xc1: ((<1>.xc2 & 8) | (<1>.xc4 & 9) | (<1>.xc5 & 9)), xc2: (<1>.xc3 + 2), xc4: (<1>.xc2 + 1), xc5: (<1>.xc2 + 2), xc3: (6 & (<1>.xc1 - 2)), xd1: 8, xd2: 8, xd4: 9, xd5: 10, xd3: 6, xe1: _|_((6 & 7):conflicting values 6 and 7), xe2: _|_((6 & 7):conflicting values 6 and 7), xe4: _|_((6 & 7):conflicting values 6 and 7), xe5: _|_((6 & 7):conflicting values 6 and 7), xe3: _|_((6 & 7):conflicting values 6 and 7), xf1: 8, xf2: 8, xf4: 10, xf3: 6, z1: ((<1>.z2 + 1) | (<1>.z3 + 5)), z2: (<1>.z3 + 2), z3: ((<1>.z1 - 3) & 8)}
