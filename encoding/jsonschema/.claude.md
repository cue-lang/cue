● Summary: making changes to encoding/jsonschema

  Key Architecture Findings

  Extract vs Generate Flow

  - Extract (JSON Schema → CUE): Converts JSON Schema keywords into CUE builtin calls
    - if/then/else keywords → matchIf(ifExpr, thenExpr, elseExpr) call
    - oneOf/anyOf/allOf/not → matchN(constraint, [items]) call
    - contains/minContains/maxContains → list.MatchN(constraint, schema) call
  - Generate (CUE → JSON Schema): Reverse transformation, converts builtin calls back to JSON Schema
    - Located in encoding/jsonschema/generate.go

  Implementation Pattern for Function Recognition

  In generate.go, the makeCallItem function (around line 400+) handles builtin function recognition:

	case "matchIf":
		// matchIf is generated by Extract for if/then/else constraints.
		// - matchIf(ifExpr, thenExpr, elseExpr)
		if len(args) != 4 {
			// Unrecognized form, accept anything
			return &itemTrue{}
		}

		return &itemIfThenElse{
			ifElem:   g.makeItem(args[1]),
			thenElem: trueAsNil(g.makeItem(args[2])),
			elseElem: trueAsNil(g.makeItem(args[3])),
		}

	case "list.MatchN":
		// list.MatchN is generated by Extract for contains/minContains/maxContains.
		// - list.MatchN(>=1, schema) represents contains with minContains: 1
		// - list.MatchN(>=N & <=M, schema) represents contains with minContains and maxContains
		// Must parse constraint expression (>=N, >=N & <=M) to extract min/max values
		// Returns itemAllOf{itemType{array}, itemContains{elem, min, max}}

  Item Types

  The item interface represents JSON Schema constructs:
  - itemOneOf, itemAnyOf, itemAllOf, itemNot - combinators
  - itemTrue - represents "no constraint" (top/_)
  - itemFalse - represents "impossible constraint" (bottom)
  - itemContains - represents contains/minContains/maxContains (defined in generate_items.go)
  - itemIfThenElse - represents if/then/else conditionals

  Testing Patterns

  1. Generate tests: Place in testdata/generate/*.txtar
    - Format: .txtar files with input CUE and expected JSON Schema output
    - Run with: go test -run TestGenerate ./encoding/jsonschema
    - Update golden files: CUE_UPDATE=1 go test ...
  2. External tests: JSON Schema test suite in testdata/external/tests/
    - Automatically skip/unskip based on pass/fail
    - Update skip markers: CUE_UPDATE=1 go test -run TestExternal ...
    - Tests marked with skip field are tracked in JSON files
  3. Field ordering: cmpSchemaLabels determines the ordering of fields in
     JSON Schema output.

  Sibling Functions Reference

  For implementing similar features in makeCallItem:
  - matchN (line 598+): Handles oneOf/anyOf/allOf/not - reference for handling list arguments and constraints
  - list.MatchN (line 509+): Handles contains - shows constraint parsing pattern (>=N, >=N & <=M)
  - matchIf (line ~593): Handles if/then/else - reference for conditional logic

  These follow the pattern:
  1. Validate arg count (return itemTrue{} if unrecognized)
  2. Parse/extract constraint values using cue.Value methods (Expr(), Int64(), etc.)
  3. Convert args using g.makeItem()
  4. Return appropriate item type (often wrapped in itemAllOf)

  Related Files

  - constraints_array.go:79-101 (constraintContains) - Where Extract generates list.MatchN calls for contains
  - constraints_combinator.go:217 - Where Extract generates matchIf calls
  - generate_items.go - Item type definitions and generate() methods
    - itemContains - generates contains/minContains/maxContains keywords
    - itemIfThenElse - generates if/then/else keywords
  - testdata/txtar/contains.txtar - Extract test showing list.MatchN output from contains
  - testdata/generate/contains.txtar - Generate test showing list.MatchN → contains conversion
