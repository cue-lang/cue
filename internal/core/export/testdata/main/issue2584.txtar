# issue #2584

-- in.cue --
F1: sub1: sub2: L
F2: {
	(string): _
	L
}
D: {}
let L = D
-- out/self/default --
-- out/definition --

let L = D
F1: {
	sub1: {
		sub2: L
	}
}
F2: {
	(string): _
	L
}
D: {}
-- out/doc-v3 --
[]
[F1]
[F1 sub1]
[F1 sub1 sub2]
[F2]
[D]
[L]
-- diff/doc/explanation --
An incomplete dynamic field does not manifest itself as an invalid field
in the new evaluator. This is probably for the better.
-- out/doc --
[]
[F1]
[F1 sub1]
[F1 sub1 sub2]
[F2]
[D]
[L]
-- out/value-v3 --
== Simplified
{
	let L = D
	F1: {
		sub1: {
			sub2: {}
		}
	}
	F2: {
		(string): _
		L
	}
	D: {}
}
== Raw
{
	let L = D
	F1: {
		sub1: {
			sub2: {}
		}
	}
	F2: {
		(string): _
		L
	}
	D: {}
}
== Final
{
	F1: {
		sub1: {
			sub2: {}
		}
	}
	F2: _|_ // F2: key value of dynamic field must be concrete, found string
	D: {}
}
== All
{
	let L = D
	F1: {
		sub1: {
			sub2: {}
		}
	}
	F2: {
		(string): _
		L
	}
	D: {}
}
== Eval
{
	let L = D
	F1: {
		sub1: {
			sub2: {}
		}
	}
	F2: {
		(string): _
		L
	}
	D: {}
}
-- diff/value/todo/p2 --
Seemingly benign change in error message.
-- out/value --
== Simplified
{
	let L = D
	F1: {
		sub1: {
			sub2: {}
		}
	}
	F2: {
		(string): _
		L
	}
	D: {}
}
== Raw
{
	let L = D
	F1: {
		sub1: {
			sub2: {}
		}
	}
	F2: {
		(string): _
		L
	}
	D: {}
}
== Final
{
	F1: {
		sub1: {
			sub2: {}
		}
	}
	F2: _|_ // F2: key value of dynamic field must be concrete, found string
	D: {}
}
== All
{
	let L = D
	F1: {
		sub1: {
			sub2: {}
		}
	}
	F2: {
		(string): _
		L
	}
	D: {}
}
== Eval
{
	let L = D
	F1: {
		sub1: {
			sub2: {}
		}
	}
	F2: {
		(string): _
		L
	}
	D: {}
}
