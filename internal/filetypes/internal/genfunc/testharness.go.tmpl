//go:build ignore

// This file is used as a header for the test code generated by [GenerateGoFuncForCUEStruct]
// so that we can compile it and use it to test the actual generated code.

package main

import (
	"os"
	"encoding/json"
	"fmt"
)

type result struct {
	Error string		`json:"error,omitempty"`
	Data map[string] {{.TypeName}}	`json:"data,omitempty"`
}

type mapType = map[string] {{.TypeName}}

func main() {
	r, err := main1()
	var data []byte
	if err != nil {
		data, _ = json.Marshal(result{Error: err.Error()})
	} else {
		data, _ = json.Marshal(result{Data: r})
	}
	os.Stdout.Write(data)
}

func main1() (mapType, error) {
	if len(os.Args) != 2 {
		// Should not happen.
		return nil, fmt.Errorf("usage: test.go testdata")
	}
	testData := []byte(os.Args[1])
	var m mapType
	if err := json.Unmarshal(testData, &m); err != nil {
		// Should not happen.
		return nil, fmt.Errorf("could not unmarshal test data: %v", err)
	}
	var t {{.StructName}}
	if err := t.unmarshalFromMap(m); err != nil {
		return nil, fmt.Errorf("unmarshalFromMap: %v", err)
	}
	t1, err := {{.FuncName}}(t)
	if err != nil {
		return nil, fmt.Errorf("unify: %v", err)
	}
	return t1.marshalToMap(), nil
}

// Redefining this rather than using internal/opt means we don't need
// to import internal CUE packages inside the generated test code.
// TODO there's probably a better solution.

type opt[T any] struct {
	x       T
	present bool
}

func (o opt[T]) IsPresent() bool {
	return o.present
}

func (o opt[T]) Value() T {
	return o.x
}

func some[T any](x T) opt[T] {
	return opt[T]{
		x:       x,
		present: true,
	}
}
